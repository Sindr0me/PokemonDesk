/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n/*!\r\n  Copyright (c) 2017 Jed Watson.\r\n  Licensed under the MIT License (MIT), see\r\n  http://jedwatson.github.io/classnames\r\n*/\r\n/* global define */\r\n(function () {\r\n    'use strict';\r\n    var hasOwn = {}.hasOwnProperty;\r\n    function classNames() {\r\n        var classes = [];\r\n        for (var i = 0; i < arguments.length; i++) {\r\n            var arg = arguments[i];\r\n            if (!arg)\r\n                continue;\r\n            var argType = typeof arg;\r\n            if (argType === 'string' || argType === 'number') {\r\n                classes.push(arg);\r\n            }\r\n            else if (Array.isArray(arg) && arg.length) {\r\n                var inner = classNames.apply(null, arg);\r\n                if (inner) {\r\n                    classes.push(inner);\r\n                }\r\n            }\r\n            else if (argType === 'object') {\r\n                for (var key in arg) {\r\n                    if (hasOwn.call(arg, key) && arg[key]) {\r\n                        classes.push(key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return classes.join(' ');\r\n    }\r\n    if ( true && module.exports) {\r\n        classNames.default = classNames;\r\n        module.exports = classNames;\r\n    }\r\n    else if (true) {\r\n        // register as 'classnames', consistent with npm package name\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n            return classNames;\r\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    }\r\n    else {}\r\n}());\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcz80ZDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7OztFQUlFO0FBQ0YsbUJBQW1CO0FBRW5CLENBQUM7SUFDQSxZQUFZLENBQUM7SUFFYixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDO0lBRS9CLFNBQVMsVUFBVTtRQUNsQixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDMUMsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxHQUFHO2dCQUFFLFNBQVM7WUFFbkIsSUFBSSxPQUFPLEdBQUcsT0FBTyxHQUFHLENBQUM7WUFFekIsSUFBSSxPQUFPLEtBQUssUUFBUSxJQUFJLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQ2pELE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDbEI7aUJBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUU7Z0JBQzVDLElBQUksS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLEtBQUssRUFBRTtvQkFDVixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNwQjthQUNEO2lCQUFNLElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRTtnQkFDaEMsS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUU7b0JBQ3BCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUN0QyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUNsQjtpQkFDRDthQUNEO1NBQ0Q7UUFFRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELElBQUksS0FBNkIsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1FBQ3BELFVBQVUsQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDO0tBQzVCO1NBQU0sSUFBSSxJQUE0RSxFQUFFO1FBQ3hGLDZEQUE2RDtRQUM3RCxpQ0FBcUIsRUFBRSxtQ0FBRTtZQUN4QixPQUFPLFVBQVUsQ0FBQztRQUNuQixDQUFDO0FBQUEsb0dBQUMsQ0FBQztLQUNIO1NBQU0sRUFFTjtBQUNGLENBQUMsRUFBRSxDQUFDLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/classnames/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/App.modules.scss":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./node_modules/sass-loader/dist/cjs.js!./src/App.modules.scss ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default.a);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \".App-modules__header__2kXAQ {\\n  font-size: 64px; }\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/App.modules.scss\"],\"names\":[],\"mappings\":\"AAAA;EACI,eAAe,EAAA\",\"sourcesContent\":[\".header {\\r\\n    font-size: 64px;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"header\": \"App-modules__header__2kXAQ\"\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLm1vZHVsZXMuc2Nzcz80M2QwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNzSDtBQUM3QjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsc0dBQXFDO0FBQy9GO0FBQ0EsOEJBQThCLFFBQVMsZ0NBQWdDLG9CQUFvQixFQUFFLFNBQVMscUZBQXFGLDRDQUE0Qyx3QkFBd0IsS0FBSyx1QkFBdUI7QUFDM1I7QUFDQTtBQUNBO0FBQ0E7QUFDZSxzRkFBdUIsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9BcHAubW9kdWxlcy5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuQXBwLW1vZHVsZXNfX2hlYWRlcl9fMmtYQVEge1xcbiAgZm9udC1zaXplOiA2NHB4OyB9XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9BcHAubW9kdWxlcy5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0ksZUFBZSxFQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5oZWFkZXIge1xcclxcbiAgICBmb250LXNpemU6IDY0cHg7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImhlYWRlclwiOiBcIkFwcC1tb2R1bGVzX19oZWFkZXJfXzJrWEFRXCJcbn07XG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/App.modules.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/custom.css":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./node_modules/sass-loader/dist/cjs.js!./src/custom.css ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default.a);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \".color {\\n  color: green; }\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/custom.css\"],\"names\":[],\"mappings\":\"AAAA;EACI,YAAY,EAAA\",\"sourcesContent\":[\".color {\\r\\n    color: green;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3VzdG9tLmNzcz85ZGNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNzSDtBQUM3QjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsc0dBQXFDO0FBQy9GO0FBQ0EsOEJBQThCLFFBQVMsV0FBVyxpQkFBaUIsRUFBRSxTQUFTLCtFQUErRSwyQ0FBMkMscUJBQXFCLEtBQUssdUJBQXVCO0FBQ3pQO0FBQ2Usc0ZBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvY3VzdG9tLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmNvbG9yIHtcXG4gIGNvbG9yOiBncmVlbjsgfVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvY3VzdG9tLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNJLFlBQVksRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuY29sb3Ige1xcclxcbiAgICBjb2xvcjogZ3JlZW47XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/custom.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/index.css":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--5-1!./node_modules/sass-loader/dist/cjs.js!./src/index.css ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default.a);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"body {\\n  min-width: 100vh;\\n  background-color: yellow; }\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/index.css\"],\"names\":[],\"mappings\":\"AAAA;EACI,gBAAgB;EAChB,wBAAwB,EAAA\",\"sourcesContent\":[\"body {\\r\\n    min-width: 100vh;\\r\\n    background-color: yellow;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguY3NzP2U3MzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ3NIO0FBQzdCO0FBQ3pGLDhCQUE4QixtRkFBMkIsQ0FBQyxzR0FBcUM7QUFDL0Y7QUFDQSw4QkFBOEIsUUFBUyxTQUFTLHFCQUFxQiw2QkFBNkIsRUFBRSxTQUFTLDhFQUE4RSxZQUFZLDRDQUE0Qyx5QkFBeUIsaUNBQWlDLEtBQUssdUJBQXVCO0FBQ3pVO0FBQ2Usc0ZBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvaW5kZXguY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gIG1pbi13aWR0aDogMTAwdmg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB5ZWxsb3c7IH1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL2luZGV4LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNJLGdCQUFnQjtFQUNoQix3QkFBd0IsRUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJib2R5IHtcXHJcXG4gICAgbWluLXdpZHRoOiAxMDB2aDtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogeWVsbG93O1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/index.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\n// eslint-disable-next-line func-names\r\nmodule.exports = function (cssWithMappingToString) {\r\n    var list = []; // return the list of modules as css string\r\n    list.toString = function toString() {\r\n        return this.map(function (item) {\r\n            var content = cssWithMappingToString(item);\r\n            if (item[2]) {\r\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\r\n            }\r\n            return content;\r\n        }).join('');\r\n    }; // import a list of modules into the list\r\n    // eslint-disable-next-line func-names\r\n    list.i = function (modules, mediaQuery, dedupe) {\r\n        if (typeof modules === 'string') {\r\n            // eslint-disable-next-line no-param-reassign\r\n            modules = [[null, modules, '']];\r\n        }\r\n        var alreadyImportedModules = {};\r\n        if (dedupe) {\r\n            for (var i = 0; i < this.length; i++) {\r\n                // eslint-disable-next-line prefer-destructuring\r\n                var id = this[i][0];\r\n                if (id != null) {\r\n                    alreadyImportedModules[id] = true;\r\n                }\r\n            }\r\n        }\r\n        for (var _i = 0; _i < modules.length; _i++) {\r\n            var item = [].concat(modules[_i]);\r\n            if (dedupe && alreadyImportedModules[item[0]]) {\r\n                // eslint-disable-next-line no-continue\r\n                continue;\r\n            }\r\n            if (mediaQuery) {\r\n                if (!item[2]) {\r\n                    item[2] = mediaQuery;\r\n                }\r\n                else {\r\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\r\n                }\r\n            }\r\n            list.push(item);\r\n        }\r\n    };\r\n    return list;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7O0VBR0U7QUFDRiw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBQ3RDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxzQkFBc0I7SUFDL0MsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsMkNBQTJDO0lBRTFELElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxRQUFRO1FBQy9CLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUk7WUFDNUIsSUFBSSxPQUFPLEdBQUcsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFM0MsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ1gsT0FBTyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2FBQzdEO1lBRUQsT0FBTyxPQUFPLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ2QsQ0FBQyxDQUFDLENBQUMseUNBQXlDO0lBQzVDLHNDQUFzQztJQUd0QyxJQUFJLENBQUMsQ0FBQyxHQUFHLFVBQVUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNO1FBQzVDLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQy9CLDZDQUE2QztZQUM3QyxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksc0JBQXNCLEdBQUcsRUFBRSxDQUFDO1FBRWhDLElBQUksTUFBTSxFQUFFO1lBQ1YsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BDLGdEQUFnRDtnQkFDaEQsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVwQixJQUFJLEVBQUUsSUFBSSxJQUFJLEVBQUU7b0JBQ2Qsc0JBQXNCLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDO2lCQUNuQzthQUNGO1NBQ0Y7UUFFRCxLQUFLLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRTtZQUMxQyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRWxDLElBQUksTUFBTSxJQUFJLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUM3Qyx1Q0FBdUM7Z0JBQ3ZDLFNBQVM7YUFDVjtZQUVELElBQUksVUFBVSxFQUFFO2dCQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQ1osSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQztpQkFDdEI7cUJBQU07b0JBQ0wsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDMUQ7YUFDRjtZQUVELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakI7SUFDSCxDQUFDLENBQUM7SUFFRixPQUFPLElBQUksQ0FBQztBQUNkLENBQUMsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o)\r\n    return; if (typeof o === \"string\")\r\n    return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor)\r\n    n = o.constructor.name; if (n === \"Map\" || n === \"Set\")\r\n    return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\r\n    return _arrayLikeToArray(o, minLen); }\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)\r\n    len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {\r\n    arr2[i] = arr[i];\r\n} return arr2; }\r\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr)))\r\n    return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try {\r\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\r\n        _arr.push(_s.value);\r\n        if (i && _arr.length === i)\r\n            break;\r\n    }\r\n}\r\ncatch (err) {\r\n    _d = true;\r\n    _e = err;\r\n}\r\nfinally {\r\n    try {\r\n        if (!_n && _i[\"return\"] != null)\r\n            _i[\"return\"]();\r\n    }\r\n    finally {\r\n        if (_d)\r\n            throw _e;\r\n    }\r\n} return _arr; }\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr))\r\n    return arr; }\r\nmodule.exports = function cssWithMappingToString(item) {\r\n    var _item = _slicedToArray(item, 4), content = _item[1], cssMapping = _item[3];\r\n    if (typeof btoa === 'function') {\r\n        // eslint-disable-next-line no-undef\r\n        var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\r\n        var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\r\n        var sourceMapping = \"/*# \".concat(data, \" */\");\r\n        var sourceURLs = cssMapping.sources.map(function (source) {\r\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\r\n        });\r\n        return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\r\n    }\r\n    return [content].join('\\n');\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcz83NWU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBUyxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksMkJBQTJCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRTlKLFNBQVMsZ0JBQWdCLEtBQUssTUFBTSxJQUFJLFNBQVMsQ0FBQywySUFBMkksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVqTSxTQUFTLDJCQUEyQixDQUFDLENBQUMsRUFBRSxNQUFNLElBQUksSUFBSSxDQUFDLENBQUM7SUFBRSxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRO0lBQUUsT0FBTyxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxXQUFXO0lBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxLQUFLO0lBQUUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssV0FBVyxJQUFJLDBDQUEwQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFBRSxPQUFPLGlCQUFpQixDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFaGEsU0FBUyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU07SUFBRSxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0lBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUFFLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBRXZMLFNBQVMscUJBQXFCLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUMsSUFBSTtJQUFFLEtBQUssSUFBSSxFQUFFLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLEVBQUU7UUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUFFLE1BQU07S0FBRTtDQUFFO0FBQUMsT0FBTyxHQUFHLEVBQUU7SUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQztDQUFFO1FBQVM7SUFBRSxJQUFJO1FBQUUsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSTtZQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO0tBQUU7WUFBUztRQUFFLElBQUksRUFBRTtZQUFFLE1BQU0sRUFBRSxDQUFDO0tBQUU7Q0FBRSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUV6ZSxTQUFTLGVBQWUsQ0FBQyxHQUFHLElBQUksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztJQUFFLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUVyRSxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsc0JBQXNCLENBQUMsSUFBSTtJQUNuRCxJQUFJLEtBQUssR0FBRyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUMvQixPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUNsQixVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTFCLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFFO1FBQzlCLG9DQUFvQztRQUNwQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUUsSUFBSSxJQUFJLEdBQUcsOERBQThELENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3pGLElBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQy9DLElBQUksVUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsTUFBTTtZQUN0RCxPQUFPLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3hFO0lBRUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\nobject-assign\r\n(c) Sindre Sorhus\r\n@license MIT\r\n*/\r\n\r\n/* eslint-disable no-unused-vars */\r\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\r\nfunction toObject(val) {\r\n    if (val === null || val === undefined) {\r\n        throw new TypeError('Object.assign cannot be called with null or undefined');\r\n    }\r\n    return Object(val);\r\n}\r\nfunction shouldUseNative() {\r\n    try {\r\n        if (!Object.assign) {\r\n            return false;\r\n        }\r\n        // Detect buggy property enumeration order in older V8 versions.\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\r\n        var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\r\n        test1[5] = 'de';\r\n        if (Object.getOwnPropertyNames(test1)[0] === '5') {\r\n            return false;\r\n        }\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\r\n        var test2 = {};\r\n        for (var i = 0; i < 10; i++) {\r\n            test2['_' + String.fromCharCode(i)] = i;\r\n        }\r\n        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\r\n            return test2[n];\r\n        });\r\n        if (order2.join('') !== '0123456789') {\r\n            return false;\r\n        }\r\n        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\r\n        var test3 = {};\r\n        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\r\n            test3[letter] = letter;\r\n        });\r\n        if (Object.keys(Object.assign({}, test3)).join('') !==\r\n            'abcdefghijklmnopqrst') {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        // We don't expect any of the above to throw, but better to be safe.\r\n        return false;\r\n    }\r\n}\r\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\r\n    var from;\r\n    var to = toObject(target);\r\n    var symbols;\r\n    for (var s = 1; s < arguments.length; s++) {\r\n        from = Object(arguments[s]);\r\n        for (var key in from) {\r\n            if (hasOwnProperty.call(from, key)) {\r\n                to[key] = from[key];\r\n            }\r\n        }\r\n        if (getOwnPropertySymbols) {\r\n            symbols = getOwnPropertySymbols(from);\r\n            for (var i = 0; i < symbols.length; i++) {\r\n                if (propIsEnumerable.call(from, symbols[i])) {\r\n                    to[symbols[i]] = from[symbols[i]];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return to;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0VBSUU7QUFFVztBQUNiLG1DQUFtQztBQUNuQyxJQUFJLHFCQUFxQixHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQztBQUN6RCxJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztBQUNyRCxJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUM7QUFFN0QsU0FBUyxRQUFRLENBQUMsR0FBRztJQUNwQixJQUFJLEdBQUcsS0FBSyxJQUFJLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtRQUN0QyxNQUFNLElBQUksU0FBUyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7S0FDN0U7SUFFRCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNwQixDQUFDO0FBRUQsU0FBUyxlQUFlO0lBQ3ZCLElBQUk7UUFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNuQixPQUFPLEtBQUssQ0FBQztTQUNiO1FBRUQsZ0VBQWdFO1FBRWhFLHVEQUF1RDtRQUN2RCxJQUFJLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFFLHNDQUFzQztRQUN0RSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLElBQUksTUFBTSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRTtZQUNqRCxPQUFPLEtBQUssQ0FBQztTQUNiO1FBRUQsdURBQXVEO1FBQ3ZELElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztRQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUIsS0FBSyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hDO1FBQ0QsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7WUFDN0QsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssWUFBWSxFQUFFO1lBQ3JDLE9BQU8sS0FBSyxDQUFDO1NBQ2I7UUFFRCx1REFBdUQ7UUFDdkQsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ2Ysc0JBQXNCLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLE1BQU07WUFDeEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDaEQsc0JBQXNCLEVBQUU7WUFDekIsT0FBTyxLQUFLLENBQUM7U0FDYjtRQUVELE9BQU8sSUFBSSxDQUFDO0tBQ1o7SUFBQyxPQUFPLEdBQUcsRUFBRTtRQUNiLG9FQUFvRTtRQUNwRSxPQUFPLEtBQUssQ0FBQztLQUNiO0FBQ0YsQ0FBQztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFVBQVUsTUFBTSxFQUFFLE1BQU07SUFDNUUsSUFBSSxJQUFJLENBQUM7SUFDVCxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsSUFBSSxPQUFPLENBQUM7SUFFWixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVCLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3JCLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7Z0JBQ25DLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDcEI7U0FDRDtRQUVELElBQUkscUJBQXFCLEVBQUU7WUFDMUIsT0FBTyxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQzVDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2xDO2FBQ0Q7U0FDRDtLQUNEO0lBRUQsT0FBTyxFQUFFLENBQUM7QUFDWCxDQUFDLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v17.0.1\r\n * react-dom.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nif (true) {\r\n    (function () {\r\n        'use strict';\r\n        var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\r\n        var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\r\n        var Scheduler = __webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");\r\n        var tracing = __webpack_require__(/*! scheduler/tracing */ \"./node_modules/scheduler/tracing.js\");\r\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n        // by calls to these methods by a Babel plugin.\r\n        //\r\n        // In PROD (or in packages without access to React internals),\r\n        // they are left as they are instead.\r\n        function warn(format) {\r\n            {\r\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                    args[_key - 1] = arguments[_key];\r\n                }\r\n                printWarning('warn', format, args);\r\n            }\r\n        }\r\n        function error(format) {\r\n            {\r\n                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n                    args[_key2 - 1] = arguments[_key2];\r\n                }\r\n                printWarning('error', format, args);\r\n            }\r\n        }\r\n        function printWarning(level, format, args) {\r\n            // When changing this logic, you might want to also\r\n            // update consoleWithStackDev.www.js as well.\r\n            {\r\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n                if (stack !== '') {\r\n                    format += '%s';\r\n                    args = args.concat([stack]);\r\n                }\r\n                var argsWithFormat = args.map(function (item) {\r\n                    return '' + item;\r\n                }); // Careful: RN currently depends on this prefix\r\n                argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n                // breaks IE9: https://github.com/facebook/react/issues/13610\r\n                // eslint-disable-next-line react-internal/no-production-logging\r\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n            }\r\n        }\r\n        if (!React) {\r\n            {\r\n                throw Error(\"ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.\");\r\n            }\r\n        }\r\n        var FunctionComponent = 0;\r\n        var ClassComponent = 1;\r\n        var IndeterminateComponent = 2; // Before we know whether it is function or class\r\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\r\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\r\n        var HostComponent = 5;\r\n        var HostText = 6;\r\n        var Fragment = 7;\r\n        var Mode = 8;\r\n        var ContextConsumer = 9;\r\n        var ContextProvider = 10;\r\n        var ForwardRef = 11;\r\n        var Profiler = 12;\r\n        var SuspenseComponent = 13;\r\n        var MemoComponent = 14;\r\n        var SimpleMemoComponent = 15;\r\n        var LazyComponent = 16;\r\n        var IncompleteClassComponent = 17;\r\n        var DehydratedFragment = 18;\r\n        var SuspenseListComponent = 19;\r\n        var FundamentalComponent = 20;\r\n        var ScopeComponent = 21;\r\n        var Block = 22;\r\n        var OffscreenComponent = 23;\r\n        var LegacyHiddenComponent = 24;\r\n        // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\r\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\r\n        var enableFundamentalAPI = false; // Experimental Scope support.\r\n        var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)\r\n        var warnAboutStringRefs = false;\r\n        var allNativeEvents = new Set();\r\n        /**\r\n         * Mapping from registration name to event name\r\n         */\r\n        var registrationNameDependencies = {};\r\n        /**\r\n         * Mapping from lowercase registration names to the properly cased version,\r\n         * used to warn in the case of missing event handlers. Available\r\n         * only in true.\r\n         * @type {Object}\r\n         */\r\n        var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true\r\n        function registerTwoPhaseEvent(registrationName, dependencies) {\r\n            registerDirectEvent(registrationName, dependencies);\r\n            registerDirectEvent(registrationName + 'Capture', dependencies);\r\n        }\r\n        function registerDirectEvent(registrationName, dependencies) {\r\n            {\r\n                if (registrationNameDependencies[registrationName]) {\r\n                    error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);\r\n                }\r\n            }\r\n            registrationNameDependencies[registrationName] = dependencies;\r\n            {\r\n                var lowerCasedName = registrationName.toLowerCase();\r\n                possibleRegistrationNames[lowerCasedName] = registrationName;\r\n                if (registrationName === 'onDoubleClick') {\r\n                    possibleRegistrationNames.ondblclick = registrationName;\r\n                }\r\n            }\r\n            for (var i = 0; i < dependencies.length; i++) {\r\n                allNativeEvents.add(dependencies[i]);\r\n            }\r\n        }\r\n        var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\r\n        // A reserved attribute.\r\n        // It is handled by React separately and shouldn't be written to the DOM.\r\n        var RESERVED = 0; // A simple string attribute.\r\n        // Attributes that aren't in the filter are presumed to have this type.\r\n        var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called\r\n        // \"enumerated\" attributes with \"true\" and \"false\" as possible values.\r\n        // When true, it should be set to a \"true\" string.\r\n        // When false, it should be set to a \"false\" string.\r\n        var BOOLEANISH_STRING = 2; // A real boolean attribute.\r\n        // When true, it should be present (set either to an empty string or its name).\r\n        // When false, it should be omitted.\r\n        var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.\r\n        // When true, it should be present (set either to an empty string or its name).\r\n        // When false, it should be omitted.\r\n        // For any other value, should be present with that value.\r\n        var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.\r\n        // When falsy, it should be removed.\r\n        var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.\r\n        // When falsy, it should be removed.\r\n        var POSITIVE_NUMERIC = 6;\r\n        /* eslint-disable max-len */\r\n        var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\r\n        /* eslint-enable max-len */\r\n        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\r\n        var ROOT_ATTRIBUTE_NAME = 'data-reactroot';\r\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\r\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n        var illegalAttributeNameCache = {};\r\n        var validatedAttributeNameCache = {};\r\n        function isAttributeNameSafe(attributeName) {\r\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\r\n                return true;\r\n            }\r\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\r\n                return false;\r\n            }\r\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\r\n                validatedAttributeNameCache[attributeName] = true;\r\n                return true;\r\n            }\r\n            illegalAttributeNameCache[attributeName] = true;\r\n            {\r\n                error('Invalid attribute name: `%s`', attributeName);\r\n            }\r\n            return false;\r\n        }\r\n        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\r\n            if (propertyInfo !== null) {\r\n                return propertyInfo.type === RESERVED;\r\n            }\r\n            if (isCustomComponentTag) {\r\n                return false;\r\n            }\r\n            if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\r\n            if (propertyInfo !== null && propertyInfo.type === RESERVED) {\r\n                return false;\r\n            }\r\n            switch (typeof value) {\r\n                case 'function': // $FlowIssue symbol is perfectly valid here\r\n                case 'symbol':\r\n                    // eslint-disable-line\r\n                    return true;\r\n                case 'boolean':\r\n                    {\r\n                        if (isCustomComponentTag) {\r\n                            return false;\r\n                        }\r\n                        if (propertyInfo !== null) {\r\n                            return !propertyInfo.acceptsBooleans;\r\n                        }\r\n                        else {\r\n                            var prefix = name.toLowerCase().slice(0, 5);\r\n                            return prefix !== 'data-' && prefix !== 'aria-';\r\n                        }\r\n                    }\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\r\n            if (value === null || typeof value === 'undefined') {\r\n                return true;\r\n            }\r\n            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\r\n                return true;\r\n            }\r\n            if (isCustomComponentTag) {\r\n                return false;\r\n            }\r\n            if (propertyInfo !== null) {\r\n                switch (propertyInfo.type) {\r\n                    case BOOLEAN:\r\n                        return !value;\r\n                    case OVERLOADED_BOOLEAN:\r\n                        return value === false;\r\n                    case NUMERIC:\r\n                        return isNaN(value);\r\n                    case POSITIVE_NUMERIC:\r\n                        return isNaN(value) || value < 1;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function getPropertyInfo(name) {\r\n            return properties.hasOwnProperty(name) ? properties[name] : null;\r\n        }\r\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {\r\n            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\r\n            this.attributeName = attributeName;\r\n            this.attributeNamespace = attributeNamespace;\r\n            this.mustUseProperty = mustUseProperty;\r\n            this.propertyName = name;\r\n            this.type = type;\r\n            this.sanitizeURL = sanitizeURL;\r\n            this.removeEmptyString = removeEmptyString;\r\n        } // When adding attributes to this list, be sure to also add them to\r\n        // the `possibleStandardNames` module to ensure casing and incorrect\r\n        // name warnings.\r\n        var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.\r\n        var reservedProps = ['children', 'dangerouslySetInnerHTML',\r\n            // elements (not just inputs). Now that ReactDOMInput assigns to the\r\n            // defaultValue property -- do we need this?\r\n            'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];\r\n        reservedProps.forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\r\n            name, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // A few React string attributes have a different name.\r\n        // This is a mapping from React prop names to the attribute names.\r\n        [['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\r\n            var name = _ref[0], attributeName = _ref[1];\r\n            properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\r\n            attributeName, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\r\n        // In React, we let users pass `true` and `false` even though technically\r\n        // these aren't boolean attributes (they are coerced to strings).\r\n        ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\r\n            name.toLowerCase(), // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\r\n        // In React, we let users pass `true` and `false` even though technically\r\n        // these aren't boolean attributes (they are coerced to strings).\r\n        // Since these are SVG attributes, their attribute names are case-sensitive.\r\n        ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\r\n            name, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are HTML boolean attributes.\r\n        ['allowFullScreen', 'async',\r\n            // on the client side because the browsers are inconsistent. Instead we call focus().\r\n            'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\r\n            'itemScope'].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\r\n            name.toLowerCase(), // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are the few React props that we set as DOM properties\r\n        // rather than attributes. These are all booleans.\r\n        ['checked',\r\n            // disabled with `removeAttribute`. We have special logic for handling this.\r\n            'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\r\n            name, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are HTML attributes that are \"overloaded booleans\": they behave like\r\n        // booleans, but can also accept a string value.\r\n        ['capture', 'download' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\r\n            name, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are HTML attributes that must be positive numbers.\r\n        ['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\r\n            name, // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These are HTML attributes that must be numbers.\r\n        ['rowSpan', 'start'].forEach(function (name) {\r\n            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\r\n            name.toLowerCase(), // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        });\r\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\r\n        var capitalize = function (token) {\r\n            return token[1].toUpperCase();\r\n        }; // This is a list of all SVG attributes that need special casing, namespacing,\r\n        // or boolean value assignment. Regular attributes that just accept strings\r\n        // and have the same names are omitted, just like in the HTML attribute filter.\r\n        // Some of these attributes can be hard to find. This list was created by\r\n        // scraping the MDN documentation.\r\n        ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (attributeName) {\r\n            var name = attributeName.replace(CAMELIZE, capitalize);\r\n            properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\r\n            attributeName, null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // String SVG attributes with the xlink namespace.\r\n        ['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (attributeName) {\r\n            var name = attributeName.replace(CAMELIZE, capitalize);\r\n            properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\r\n            attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL\r\n            false);\r\n        }); // String SVG attributes with the xml namespace.\r\n        ['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,\r\n            // you'll need to set attributeName to name.toLowerCase()\r\n            // instead in the assignment below.\r\n        ].forEach(function (attributeName) {\r\n            var name = attributeName.replace(CAMELIZE, capitalize);\r\n            properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\r\n            attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL\r\n            false);\r\n        }); // These attribute exists both in HTML and SVG.\r\n        // The attribute name is case-sensitive in SVG so we can't just use\r\n        // the React name like we do for attributes that exist only in HTML.\r\n        ['tabIndex', 'crossOrigin'].forEach(function (attributeName) {\r\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty\r\n            attributeName.toLowerCase(), // attributeName\r\n            null, // attributeNamespace\r\n            false, // sanitizeURL\r\n            false);\r\n        }); // These attributes accept URLs. These must not allow javascript: URLS.\r\n        // These will also need to accept Trusted Types object in the future.\r\n        var xlinkHref = 'xlinkHref';\r\n        properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty\r\n        'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL\r\n        false);\r\n        ['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {\r\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty\r\n            attributeName.toLowerCase(), // attributeName\r\n            null, // attributeNamespace\r\n            true, // sanitizeURL\r\n            true);\r\n        });\r\n        // and any newline or tab are filtered out as if they're not part of the URL.\r\n        // https://url.spec.whatwg.org/#url-parsing\r\n        // Tab or newline are defined as \\r\\n\\t:\r\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\r\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\r\n        // INFORMATION SEPARATOR ONE, inclusive:\r\n        // https://infra.spec.whatwg.org/#c0-control-or-space\r\n        /* eslint-disable max-len */\r\n        var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\r\n        var didWarn = false;\r\n        function sanitizeURL(url) {\r\n            {\r\n                if (!didWarn && isJavaScriptProtocol.test(url)) {\r\n                    didWarn = true;\r\n                    error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Get the value for a property on a node. Only used in DEV for SSR validation.\r\n         * The \"expected\" argument is used as a hint of what the expected value is.\r\n         * Some properties have multiple equivalent values.\r\n         */\r\n        function getValueForProperty(node, name, expected, propertyInfo) {\r\n            {\r\n                if (propertyInfo.mustUseProperty) {\r\n                    var propertyName = propertyInfo.propertyName;\r\n                    return node[propertyName];\r\n                }\r\n                else {\r\n                    if (propertyInfo.sanitizeURL) {\r\n                        // If we haven't fully disabled javascript: URLs, and if\r\n                        // the hydration is successful of a javascript: URL, we\r\n                        // still want to warn on the client.\r\n                        sanitizeURL('' + expected);\r\n                    }\r\n                    var attributeName = propertyInfo.attributeName;\r\n                    var stringValue = null;\r\n                    if (propertyInfo.type === OVERLOADED_BOOLEAN) {\r\n                        if (node.hasAttribute(attributeName)) {\r\n                            var value = node.getAttribute(attributeName);\r\n                            if (value === '') {\r\n                                return true;\r\n                            }\r\n                            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                                return value;\r\n                            }\r\n                            if (value === '' + expected) {\r\n                                return expected;\r\n                            }\r\n                            return value;\r\n                        }\r\n                    }\r\n                    else if (node.hasAttribute(attributeName)) {\r\n                        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                            // We had an attribute but shouldn't have had one, so read it\r\n                            // for the error message.\r\n                            return node.getAttribute(attributeName);\r\n                        }\r\n                        if (propertyInfo.type === BOOLEAN) {\r\n                            // If this was a boolean, it doesn't matter what the value is\r\n                            // the fact that we have it is the same as the expected.\r\n                            return expected;\r\n                        } // Even if this property uses a namespace we use getAttribute\r\n                        // because we assume its namespaced name is the same as our config.\r\n                        // To use getAttributeNS we need the local name which we don't have\r\n                        // in our config atm.\r\n                        stringValue = node.getAttribute(attributeName);\r\n                    }\r\n                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                        return stringValue === null ? expected : stringValue;\r\n                    }\r\n                    else if (stringValue === '' + expected) {\r\n                        return expected;\r\n                    }\r\n                    else {\r\n                        return stringValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Get the value for a attribute on a node. Only used in DEV for SSR validation.\r\n         * The third argument is used as a hint of what the expected value is. Some\r\n         * attributes have multiple equivalent values.\r\n         */\r\n        function getValueForAttribute(node, name, expected) {\r\n            {\r\n                if (!isAttributeNameSafe(name)) {\r\n                    return;\r\n                } // If the object is an opaque reference ID, it's expected that\r\n                // the next prop is different than the server value, so just return\r\n                // expected\r\n                if (isOpaqueHydratingObject(expected)) {\r\n                    return expected;\r\n                }\r\n                if (!node.hasAttribute(name)) {\r\n                    return expected === undefined ? undefined : null;\r\n                }\r\n                var value = node.getAttribute(name);\r\n                if (value === '' + expected) {\r\n                    return expected;\r\n                }\r\n                return value;\r\n            }\r\n        }\r\n        /**\r\n         * Sets the value for a property on a node.\r\n         *\r\n         * @param {DOMElement} node\r\n         * @param {string} name\r\n         * @param {*} value\r\n         */\r\n        function setValueForProperty(node, name, value, isCustomComponentTag) {\r\n            var propertyInfo = getPropertyInfo(name);\r\n            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\r\n                return;\r\n            }\r\n            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\r\n                value = null;\r\n            } // If the prop isn't in the special list, treat it as a simple attribute.\r\n            if (isCustomComponentTag || propertyInfo === null) {\r\n                if (isAttributeNameSafe(name)) {\r\n                    var _attributeName = name;\r\n                    if (value === null) {\r\n                        node.removeAttribute(_attributeName);\r\n                    }\r\n                    else {\r\n                        node.setAttribute(_attributeName, '' + value);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            var mustUseProperty = propertyInfo.mustUseProperty;\r\n            if (mustUseProperty) {\r\n                var propertyName = propertyInfo.propertyName;\r\n                if (value === null) {\r\n                    var type = propertyInfo.type;\r\n                    node[propertyName] = type === BOOLEAN ? false : '';\r\n                }\r\n                else {\r\n                    // Contrary to `setAttribute`, object properties are properly\r\n                    // `toString`ed by IE8/9.\r\n                    node[propertyName] = value;\r\n                }\r\n                return;\r\n            } // The rest are treated as attributes with special cases.\r\n            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;\r\n            if (value === null) {\r\n                node.removeAttribute(attributeName);\r\n            }\r\n            else {\r\n                var _type = propertyInfo.type;\r\n                var attributeValue;\r\n                if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\r\n                    // If attribute type is boolean, we know for sure it won't be an execution sink\r\n                    // and we won't require Trusted Type here.\r\n                    attributeValue = '';\r\n                }\r\n                else {\r\n                    // `setAttribute` with objects becomes only `[object]` in IE8/9,\r\n                    // ('' + value) makes it output the correct toString()-value.\r\n                    {\r\n                        attributeValue = '' + value;\r\n                    }\r\n                    if (propertyInfo.sanitizeURL) {\r\n                        sanitizeURL(attributeValue.toString());\r\n                    }\r\n                }\r\n                if (attributeNamespace) {\r\n                    node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\r\n                }\r\n                else {\r\n                    node.setAttribute(attributeName, attributeValue);\r\n                }\r\n            }\r\n        }\r\n        // ATTENTION\r\n        // When adding new symbols to this file,\r\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\r\n        // nor polyfill, then a plain number is used for performance.\r\n        var REACT_ELEMENT_TYPE = 0xeac7;\r\n        var REACT_PORTAL_TYPE = 0xeaca;\r\n        var REACT_FRAGMENT_TYPE = 0xeacb;\r\n        var REACT_STRICT_MODE_TYPE = 0xeacc;\r\n        var REACT_PROFILER_TYPE = 0xead2;\r\n        var REACT_PROVIDER_TYPE = 0xeacd;\r\n        var REACT_CONTEXT_TYPE = 0xeace;\r\n        var REACT_FORWARD_REF_TYPE = 0xead0;\r\n        var REACT_SUSPENSE_TYPE = 0xead1;\r\n        var REACT_SUSPENSE_LIST_TYPE = 0xead8;\r\n        var REACT_MEMO_TYPE = 0xead3;\r\n        var REACT_LAZY_TYPE = 0xead4;\r\n        var REACT_BLOCK_TYPE = 0xead9;\r\n        var REACT_SERVER_BLOCK_TYPE = 0xeada;\r\n        var REACT_FUNDAMENTAL_TYPE = 0xead5;\r\n        var REACT_SCOPE_TYPE = 0xead7;\r\n        var REACT_OPAQUE_ID_TYPE = 0xeae0;\r\n        var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\r\n        var REACT_OFFSCREEN_TYPE = 0xeae2;\r\n        var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\r\n        if (typeof Symbol === 'function' && Symbol.for) {\r\n            var symbolFor = Symbol.for;\r\n            REACT_ELEMENT_TYPE = symbolFor('react.element');\r\n            REACT_PORTAL_TYPE = symbolFor('react.portal');\r\n            REACT_FRAGMENT_TYPE = symbolFor('react.fragment');\r\n            REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\r\n            REACT_PROFILER_TYPE = symbolFor('react.profiler');\r\n            REACT_PROVIDER_TYPE = symbolFor('react.provider');\r\n            REACT_CONTEXT_TYPE = symbolFor('react.context');\r\n            REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\r\n            REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\r\n            REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\r\n            REACT_MEMO_TYPE = symbolFor('react.memo');\r\n            REACT_LAZY_TYPE = symbolFor('react.lazy');\r\n            REACT_BLOCK_TYPE = symbolFor('react.block');\r\n            REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\r\n            REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\r\n            REACT_SCOPE_TYPE = symbolFor('react.scope');\r\n            REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\r\n            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\r\n            REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\r\n            REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\r\n        }\r\n        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\r\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\r\n        function getIteratorFn(maybeIterable) {\r\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n                return null;\r\n            }\r\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n            if (typeof maybeIterator === 'function') {\r\n                return maybeIterator;\r\n            }\r\n            return null;\r\n        }\r\n        // Helpers to patch console.logs to avoid logging during side-effect free\r\n        // replaying on render function. This currently only patches the object\r\n        // lazily which won't cover if the log function was extracted eagerly.\r\n        // We could also eagerly patch the method.\r\n        var disabledDepth = 0;\r\n        var prevLog;\r\n        var prevInfo;\r\n        var prevWarn;\r\n        var prevError;\r\n        var prevGroup;\r\n        var prevGroupCollapsed;\r\n        var prevGroupEnd;\r\n        function disabledLog() { }\r\n        disabledLog.__reactDisabledLog = true;\r\n        function disableLogs() {\r\n            {\r\n                if (disabledDepth === 0) {\r\n                    /* eslint-disable react-internal/no-production-logging */\r\n                    prevLog = console.log;\r\n                    prevInfo = console.info;\r\n                    prevWarn = console.warn;\r\n                    prevError = console.error;\r\n                    prevGroup = console.group;\r\n                    prevGroupCollapsed = console.groupCollapsed;\r\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n                    var props = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        value: disabledLog,\r\n                        writable: true\r\n                    }; // $FlowFixMe Flow thinks console is immutable.\r\n                    Object.defineProperties(console, {\r\n                        info: props,\r\n                        log: props,\r\n                        warn: props,\r\n                        error: props,\r\n                        group: props,\r\n                        groupCollapsed: props,\r\n                        groupEnd: props\r\n                    });\r\n                    /* eslint-enable react-internal/no-production-logging */\r\n                }\r\n                disabledDepth++;\r\n            }\r\n        }\r\n        function reenableLogs() {\r\n            {\r\n                disabledDepth--;\r\n                if (disabledDepth === 0) {\r\n                    /* eslint-disable react-internal/no-production-logging */\r\n                    var props = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        writable: true\r\n                    }; // $FlowFixMe Flow thinks console is immutable.\r\n                    Object.defineProperties(console, {\r\n                        log: _assign({}, props, {\r\n                            value: prevLog\r\n                        }),\r\n                        info: _assign({}, props, {\r\n                            value: prevInfo\r\n                        }),\r\n                        warn: _assign({}, props, {\r\n                            value: prevWarn\r\n                        }),\r\n                        error: _assign({}, props, {\r\n                            value: prevError\r\n                        }),\r\n                        group: _assign({}, props, {\r\n                            value: prevGroup\r\n                        }),\r\n                        groupCollapsed: _assign({}, props, {\r\n                            value: prevGroupCollapsed\r\n                        }),\r\n                        groupEnd: _assign({}, props, {\r\n                            value: prevGroupEnd\r\n                        })\r\n                    });\r\n                    /* eslint-enable react-internal/no-production-logging */\r\n                }\r\n                if (disabledDepth < 0) {\r\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n                }\r\n            }\r\n        }\r\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\n        var prefix;\r\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\r\n            {\r\n                if (prefix === undefined) {\r\n                    // Extract the VM specific prefix used by each line.\r\n                    try {\r\n                        throw Error();\r\n                    }\r\n                    catch (x) {\r\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n                        prefix = match && match[1] || '';\r\n                    }\r\n                } // We use the prefix to ensure our stacks line up with native stack frames.\r\n                return '\\n' + prefix + name;\r\n            }\r\n        }\r\n        var reentry = false;\r\n        var componentFrameCache;\r\n        {\r\n            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n            componentFrameCache = new PossiblyWeakMap();\r\n        }\r\n        function describeNativeComponentFrame(fn, construct) {\r\n            // If something asked for a stack inside a fake render, it should get ignored.\r\n            if (!fn || reentry) {\r\n                return '';\r\n            }\r\n            {\r\n                var frame = componentFrameCache.get(fn);\r\n                if (frame !== undefined) {\r\n                    return frame;\r\n                }\r\n            }\r\n            var control;\r\n            reentry = true;\r\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n            Error.prepareStackTrace = undefined;\r\n            var previousDispatcher;\r\n            {\r\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\r\n                // for warnings.\r\n                ReactCurrentDispatcher.current = null;\r\n                disableLogs();\r\n            }\r\n            try {\r\n                // This should throw.\r\n                if (construct) {\r\n                    // Something should be setting the props in the constructor.\r\n                    var Fake = function () {\r\n                        throw Error();\r\n                    }; // $FlowFixMe\r\n                    Object.defineProperty(Fake.prototype, 'props', {\r\n                        set: function () {\r\n                            // We use a throwing setter instead of frozen or non-writable props\r\n                            // because that won't throw in a non-strict mode function.\r\n                            throw Error();\r\n                        }\r\n                    });\r\n                    if (typeof Reflect === 'object' && Reflect.construct) {\r\n                        // We construct a different control for this case to include any extra\r\n                        // frames added by the construct call.\r\n                        try {\r\n                            Reflect.construct(Fake, []);\r\n                        }\r\n                        catch (x) {\r\n                            control = x;\r\n                        }\r\n                        Reflect.construct(fn, [], Fake);\r\n                    }\r\n                    else {\r\n                        try {\r\n                            Fake.call();\r\n                        }\r\n                        catch (x) {\r\n                            control = x;\r\n                        }\r\n                        fn.call(Fake.prototype);\r\n                    }\r\n                }\r\n                else {\r\n                    try {\r\n                        throw Error();\r\n                    }\r\n                    catch (x) {\r\n                        control = x;\r\n                    }\r\n                    fn();\r\n                }\r\n            }\r\n            catch (sample) {\r\n                // This is inlined manually because closure doesn't do it for us.\r\n                if (sample && control && typeof sample.stack === 'string') {\r\n                    // This extracts the first frame from the sample that isn't also in the control.\r\n                    // Skipping one frame that we assume is the frame that calls the two.\r\n                    var sampleLines = sample.stack.split('\\n');\r\n                    var controlLines = control.stack.split('\\n');\r\n                    var s = sampleLines.length - 1;\r\n                    var c = controlLines.length - 1;\r\n                    while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n                        // We expect at least one stack frame to be shared.\r\n                        // Typically this will be the root most one. However, stack frames may be\r\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n                        // earlier than the other. We assume that the sample is longer or the same\r\n                        // and there for cut off earlier. So we should find the root most frame in\r\n                        // the sample somewhere in the control.\r\n                        c--;\r\n                    }\r\n                    for (; s >= 1 && c >= 0; s--, c--) {\r\n                        // Next we find the first one that isn't the same which should be the\r\n                        // frame that called our sample function and the control.\r\n                        if (sampleLines[s] !== controlLines[c]) {\r\n                            // In V8, the first line is describing the message but other VMs don't.\r\n                            // If we're about to return the first line, and the control is also on the same\r\n                            // line, that's a pretty good indicator that our sample threw at same line as\r\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n                            // This can happen if you passed a class to function component, or non-function.\r\n                            if (s !== 1 || c !== 1) {\r\n                                do {\r\n                                    s--;\r\n                                    c--; // We may still have similar intermediate frames from the construct call.\r\n                                    // The next one that isn't the same should be our match though.\r\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\r\n                                        {\r\n                                            if (typeof fn === 'function') {\r\n                                                componentFrameCache.set(fn, _frame);\r\n                                            }\r\n                                        } // Return the line we found.\r\n                                        return _frame;\r\n                                    }\r\n                                } while (s >= 1 && c >= 0);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            finally {\r\n                reentry = false;\r\n                {\r\n                    ReactCurrentDispatcher.current = previousDispatcher;\r\n                    reenableLogs();\r\n                }\r\n                Error.prepareStackTrace = previousPrepareStackTrace;\r\n            } // Fallback to just using the name if we couldn't make it throw.\r\n            var name = fn ? fn.displayName || fn.name : '';\r\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n            {\r\n                if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, syntheticFrame);\r\n                }\r\n            }\r\n            return syntheticFrame;\r\n        }\r\n        function describeClassComponentFrame(ctor, source, ownerFn) {\r\n            {\r\n                return describeNativeComponentFrame(ctor, true);\r\n            }\r\n        }\r\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\r\n            {\r\n                return describeNativeComponentFrame(fn, false);\r\n            }\r\n        }\r\n        function shouldConstruct(Component) {\r\n            var prototype = Component.prototype;\r\n            return !!(prototype && prototype.isReactComponent);\r\n        }\r\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n            if (type == null) {\r\n                return '';\r\n            }\r\n            if (typeof type === 'function') {\r\n                {\r\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\r\n                }\r\n            }\r\n            if (typeof type === 'string') {\r\n                return describeBuiltInComponentFrame(type);\r\n            }\r\n            switch (type) {\r\n                case REACT_SUSPENSE_TYPE:\r\n                    return describeBuiltInComponentFrame('Suspense');\r\n                case REACT_SUSPENSE_LIST_TYPE:\r\n                    return describeBuiltInComponentFrame('SuspenseList');\r\n            }\r\n            if (typeof type === 'object') {\r\n                switch (type.$$typeof) {\r\n                    case REACT_FORWARD_REF_TYPE:\r\n                        return describeFunctionComponentFrame(type.render);\r\n                    case REACT_MEMO_TYPE:\r\n                        // Memo may contain any component type so we recursively resolve it.\r\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n                    case REACT_BLOCK_TYPE:\r\n                        return describeFunctionComponentFrame(type._render);\r\n                    case REACT_LAZY_TYPE:\r\n                        {\r\n                            var lazyComponent = type;\r\n                            var payload = lazyComponent._payload;\r\n                            var init = lazyComponent._init;\r\n                            try {\r\n                                // Lazy may contain any component type so we recursively resolve it.\r\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n                            }\r\n                            catch (x) { }\r\n                        }\r\n                }\r\n            }\r\n            return '';\r\n        }\r\n        function describeFiber(fiber) {\r\n            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\r\n            var source = fiber._debugSource;\r\n            switch (fiber.tag) {\r\n                case HostComponent:\r\n                    return describeBuiltInComponentFrame(fiber.type);\r\n                case LazyComponent:\r\n                    return describeBuiltInComponentFrame('Lazy');\r\n                case SuspenseComponent:\r\n                    return describeBuiltInComponentFrame('Suspense');\r\n                case SuspenseListComponent:\r\n                    return describeBuiltInComponentFrame('SuspenseList');\r\n                case FunctionComponent:\r\n                case IndeterminateComponent:\r\n                case SimpleMemoComponent:\r\n                    return describeFunctionComponentFrame(fiber.type);\r\n                case ForwardRef:\r\n                    return describeFunctionComponentFrame(fiber.type.render);\r\n                case Block:\r\n                    return describeFunctionComponentFrame(fiber.type._render);\r\n                case ClassComponent:\r\n                    return describeClassComponentFrame(fiber.type);\r\n                default:\r\n                    return '';\r\n            }\r\n        }\r\n        function getStackByFiberInDevAndProd(workInProgress) {\r\n            try {\r\n                var info = '';\r\n                var node = workInProgress;\r\n                do {\r\n                    info += describeFiber(node);\r\n                    node = node.return;\r\n                } while (node);\r\n                return info;\r\n            }\r\n            catch (x) {\r\n                return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\r\n            }\r\n        }\r\n        function getWrappedName(outerType, innerType, wrapperName) {\r\n            var functionName = innerType.displayName || innerType.name || '';\r\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\r\n        }\r\n        function getContextName(type) {\r\n            return type.displayName || 'Context';\r\n        }\r\n        function getComponentName(type) {\r\n            if (type == null) {\r\n                // Host root, text node or just invalid type.\r\n                return null;\r\n            }\r\n            {\r\n                if (typeof type.tag === 'number') {\r\n                    error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\r\n                }\r\n            }\r\n            if (typeof type === 'function') {\r\n                return type.displayName || type.name || null;\r\n            }\r\n            if (typeof type === 'string') {\r\n                return type;\r\n            }\r\n            switch (type) {\r\n                case REACT_FRAGMENT_TYPE:\r\n                    return 'Fragment';\r\n                case REACT_PORTAL_TYPE:\r\n                    return 'Portal';\r\n                case REACT_PROFILER_TYPE:\r\n                    return 'Profiler';\r\n                case REACT_STRICT_MODE_TYPE:\r\n                    return 'StrictMode';\r\n                case REACT_SUSPENSE_TYPE:\r\n                    return 'Suspense';\r\n                case REACT_SUSPENSE_LIST_TYPE:\r\n                    return 'SuspenseList';\r\n            }\r\n            if (typeof type === 'object') {\r\n                switch (type.$$typeof) {\r\n                    case REACT_CONTEXT_TYPE:\r\n                        var context = type;\r\n                        return getContextName(context) + '.Consumer';\r\n                    case REACT_PROVIDER_TYPE:\r\n                        var provider = type;\r\n                        return getContextName(provider._context) + '.Provider';\r\n                    case REACT_FORWARD_REF_TYPE:\r\n                        return getWrappedName(type, type.render, 'ForwardRef');\r\n                    case REACT_MEMO_TYPE:\r\n                        return getComponentName(type.type);\r\n                    case REACT_BLOCK_TYPE:\r\n                        return getComponentName(type._render);\r\n                    case REACT_LAZY_TYPE:\r\n                        {\r\n                            var lazyComponent = type;\r\n                            var payload = lazyComponent._payload;\r\n                            var init = lazyComponent._init;\r\n                            try {\r\n                                return getComponentName(init(payload));\r\n                            }\r\n                            catch (x) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n        var current = null;\r\n        var isRendering = false;\r\n        function getCurrentFiberOwnerNameInDevOrNull() {\r\n            {\r\n                if (current === null) {\r\n                    return null;\r\n                }\r\n                var owner = current._debugOwner;\r\n                if (owner !== null && typeof owner !== 'undefined') {\r\n                    return getComponentName(owner.type);\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function getCurrentFiberStackInDev() {\r\n            {\r\n                if (current === null) {\r\n                    return '';\r\n                } // Safe because if current fiber exists, we are reconciling,\r\n                // and it is guaranteed to be the work-in-progress version.\r\n                return getStackByFiberInDevAndProd(current);\r\n            }\r\n        }\r\n        function resetCurrentFiber() {\r\n            {\r\n                ReactDebugCurrentFrame.getCurrentStack = null;\r\n                current = null;\r\n                isRendering = false;\r\n            }\r\n        }\r\n        function setCurrentFiber(fiber) {\r\n            {\r\n                ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\r\n                current = fiber;\r\n                isRendering = false;\r\n            }\r\n        }\r\n        function setIsRendering(rendering) {\r\n            {\r\n                isRendering = rendering;\r\n            }\r\n        }\r\n        function getIsRendering() {\r\n            {\r\n                return isRendering;\r\n            }\r\n        }\r\n        // Flow does not allow string concatenation of most non-string types. To work\r\n        // around this limitation, we use an opaque type that can only be obtained by\r\n        // passing the value through getToStringValue first.\r\n        function toString(value) {\r\n            return '' + value;\r\n        }\r\n        function getToStringValue(value) {\r\n            switch (typeof value) {\r\n                case 'boolean':\r\n                case 'number':\r\n                case 'object':\r\n                case 'string':\r\n                case 'undefined':\r\n                    return value;\r\n                default:\r\n                    // function, symbol are assigned as empty strings\r\n                    return '';\r\n            }\r\n        }\r\n        var hasReadOnlyValue = {\r\n            button: true,\r\n            checkbox: true,\r\n            image: true,\r\n            hidden: true,\r\n            radio: true,\r\n            reset: true,\r\n            submit: true\r\n        };\r\n        function checkControlledValueProps(tagName, props) {\r\n            {\r\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\r\n                    error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\r\n                }\r\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\r\n                    error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\r\n                }\r\n            }\r\n        }\r\n        function isCheckable(elem) {\r\n            var type = elem.type;\r\n            var nodeName = elem.nodeName;\r\n            return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\r\n        }\r\n        function getTracker(node) {\r\n            return node._valueTracker;\r\n        }\r\n        function detachTracker(node) {\r\n            node._valueTracker = null;\r\n        }\r\n        function getValueFromNode(node) {\r\n            var value = '';\r\n            if (!node) {\r\n                return value;\r\n            }\r\n            if (isCheckable(node)) {\r\n                value = node.checked ? 'true' : 'false';\r\n            }\r\n            else {\r\n                value = node.value;\r\n            }\r\n            return value;\r\n        }\r\n        function trackValueOnNode(node) {\r\n            var valueField = isCheckable(node) ? 'checked' : 'value';\r\n            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\r\n            var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail\r\n            // and don't track value will cause over reporting of changes,\r\n            // but it's better then a hard failure\r\n            // (needed for certain tests that spyOn input values and Safari)\r\n            if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\r\n                return;\r\n            }\r\n            var get = descriptor.get, set = descriptor.set;\r\n            Object.defineProperty(node, valueField, {\r\n                configurable: true,\r\n                get: function () {\r\n                    return get.call(this);\r\n                },\r\n                set: function (value) {\r\n                    currentValue = '' + value;\r\n                    set.call(this, value);\r\n                }\r\n            }); // We could've passed this the first time\r\n            // but it triggers a bug in IE11 and Edge 14/15.\r\n            // Calling defineProperty() again should be equivalent.\r\n            // https://github.com/facebook/react/issues/11768\r\n            Object.defineProperty(node, valueField, {\r\n                enumerable: descriptor.enumerable\r\n            });\r\n            var tracker = {\r\n                getValue: function () {\r\n                    return currentValue;\r\n                },\r\n                setValue: function (value) {\r\n                    currentValue = '' + value;\r\n                },\r\n                stopTracking: function () {\r\n                    detachTracker(node);\r\n                    delete node[valueField];\r\n                }\r\n            };\r\n            return tracker;\r\n        }\r\n        function track(node) {\r\n            if (getTracker(node)) {\r\n                return;\r\n            } // TODO: Once it's just Fiber we can move this to node._wrapperState\r\n            node._valueTracker = trackValueOnNode(node);\r\n        }\r\n        function updateValueIfChanged(node) {\r\n            if (!node) {\r\n                return false;\r\n            }\r\n            var tracker = getTracker(node); // if there is no tracker at this point it's unlikely\r\n            // that trying again will succeed\r\n            if (!tracker) {\r\n                return true;\r\n            }\r\n            var lastValue = tracker.getValue();\r\n            var nextValue = getValueFromNode(node);\r\n            if (nextValue !== lastValue) {\r\n                tracker.setValue(nextValue);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        function getActiveElement(doc) {\r\n            doc = doc || (typeof document !== 'undefined' ? document : undefined);\r\n            if (typeof doc === 'undefined') {\r\n                return null;\r\n            }\r\n            try {\r\n                return doc.activeElement || doc.body;\r\n            }\r\n            catch (e) {\r\n                return doc.body;\r\n            }\r\n        }\r\n        var didWarnValueDefaultValue = false;\r\n        var didWarnCheckedDefaultChecked = false;\r\n        var didWarnControlledToUncontrolled = false;\r\n        var didWarnUncontrolledToControlled = false;\r\n        function isControlled(props) {\r\n            var usesChecked = props.type === 'checkbox' || props.type === 'radio';\r\n            return usesChecked ? props.checked != null : props.value != null;\r\n        }\r\n        /**\r\n         * Implements an <input> host component that allows setting these optional\r\n         * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\r\n         *\r\n         * If `checked` or `value` are not supplied (or null/undefined), user actions\r\n         * that affect the checked state or value will trigger updates to the element.\r\n         *\r\n         * If they are supplied (and not null/undefined), the rendered element will not\r\n         * trigger updates to the element. Instead, the props must change in order for\r\n         * the rendered element to be updated.\r\n         *\r\n         * The rendered element will be initialized as unchecked (or `defaultChecked`)\r\n         * with an empty value (or `defaultValue`).\r\n         *\r\n         * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\r\n         */\r\n        function getHostProps(element, props) {\r\n            var node = element;\r\n            var checked = props.checked;\r\n            var hostProps = _assign({}, props, {\r\n                defaultChecked: undefined,\r\n                defaultValue: undefined,\r\n                value: undefined,\r\n                checked: checked != null ? checked : node._wrapperState.initialChecked\r\n            });\r\n            return hostProps;\r\n        }\r\n        function initWrapperState(element, props) {\r\n            {\r\n                checkControlledValueProps('input', props);\r\n                if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\r\n                    error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\r\n                    didWarnCheckedDefaultChecked = true;\r\n                }\r\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\r\n                    error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\r\n                    didWarnValueDefaultValue = true;\r\n                }\r\n            }\r\n            var node = element;\r\n            var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\r\n            node._wrapperState = {\r\n                initialChecked: props.checked != null ? props.checked : props.defaultChecked,\r\n                initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\r\n                controlled: isControlled(props)\r\n            };\r\n        }\r\n        function updateChecked(element, props) {\r\n            var node = element;\r\n            var checked = props.checked;\r\n            if (checked != null) {\r\n                setValueForProperty(node, 'checked', checked, false);\r\n            }\r\n        }\r\n        function updateWrapper(element, props) {\r\n            var node = element;\r\n            {\r\n                var controlled = isControlled(props);\r\n                if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\r\n                    error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');\r\n                    didWarnUncontrolledToControlled = true;\r\n                }\r\n                if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\r\n                    error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');\r\n                    didWarnControlledToUncontrolled = true;\r\n                }\r\n            }\r\n            updateChecked(element, props);\r\n            var value = getToStringValue(props.value);\r\n            var type = props.type;\r\n            if (value != null) {\r\n                if (type === 'number') {\r\n                    if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.\r\n                        // eslint-disable-next-line\r\n                        node.value != value) {\r\n                        node.value = toString(value);\r\n                    }\r\n                }\r\n                else if (node.value !== toString(value)) {\r\n                    node.value = toString(value);\r\n                }\r\n            }\r\n            else if (type === 'submit' || type === 'reset') {\r\n                // Submit/reset inputs need the attribute removed completely to avoid\r\n                // blank-text buttons.\r\n                node.removeAttribute('value');\r\n                return;\r\n            }\r\n            {\r\n                // When syncing the value attribute, the value comes from a cascade of\r\n                // properties:\r\n                //  1. The value React property\r\n                //  2. The defaultValue React property\r\n                //  3. Otherwise there should be no change\r\n                if (props.hasOwnProperty('value')) {\r\n                    setDefaultValue(node, props.type, value);\r\n                }\r\n                else if (props.hasOwnProperty('defaultValue')) {\r\n                    setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\r\n                }\r\n            }\r\n            {\r\n                // When syncing the checked attribute, it only changes when it needs\r\n                // to be removed, such as transitioning from a checkbox into a text input\r\n                if (props.checked == null && props.defaultChecked != null) {\r\n                    node.defaultChecked = !!props.defaultChecked;\r\n                }\r\n            }\r\n        }\r\n        function postMountWrapper(element, props, isHydrating) {\r\n            var node = element; // Do not assign value if it is already set. This prevents user text input\r\n            // from being lost during SSR hydration.\r\n            if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\r\n                var type = props.type;\r\n                var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the\r\n                // default value provided by the browser. See: #12872\r\n                if (isButton && (props.value === undefined || props.value === null)) {\r\n                    return;\r\n                }\r\n                var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input\r\n                // from being lost during SSR hydration.\r\n                if (!isHydrating) {\r\n                    {\r\n                        // When syncing the value attribute, the value property should use\r\n                        // the wrapperState._initialValue property. This uses:\r\n                        //\r\n                        //   1. The value React property when present\r\n                        //   2. The defaultValue React property when present\r\n                        //   3. An empty string\r\n                        if (initialValue !== node.value) {\r\n                            node.value = initialValue;\r\n                        }\r\n                    }\r\n                }\r\n                {\r\n                    // Otherwise, the value attribute is synchronized to the property,\r\n                    // so we assign defaultValue to the same thing as the value property\r\n                    // assignment step above.\r\n                    node.defaultValue = initialValue;\r\n                }\r\n            } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\r\n            // this is needed to work around a chrome bug where setting defaultChecked\r\n            // will sometimes influence the value of checked (even after detachment).\r\n            // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\r\n            // We need to temporarily unset name to avoid disrupting radio button groups.\r\n            var name = node.name;\r\n            if (name !== '') {\r\n                node.name = '';\r\n            }\r\n            {\r\n                // When syncing the checked attribute, both the checked property and\r\n                // attribute are assigned at the same time using defaultChecked. This uses:\r\n                //\r\n                //   1. The checked React property when present\r\n                //   2. The defaultChecked React property when present\r\n                //   3. Otherwise, false\r\n                node.defaultChecked = !node.defaultChecked;\r\n                node.defaultChecked = !!node._wrapperState.initialChecked;\r\n            }\r\n            if (name !== '') {\r\n                node.name = name;\r\n            }\r\n        }\r\n        function restoreControlledState(element, props) {\r\n            var node = element;\r\n            updateWrapper(node, props);\r\n            updateNamedCousins(node, props);\r\n        }\r\n        function updateNamedCousins(rootNode, props) {\r\n            var name = props.name;\r\n            if (props.type === 'radio' && name != null) {\r\n                var queryRoot = rootNode;\r\n                while (queryRoot.parentNode) {\r\n                    queryRoot = queryRoot.parentNode;\r\n                } // If `rootNode.form` was non-null, then we could try `form.elements`,\r\n                // but that sometimes behaves strangely in IE8. We could also try using\r\n                // `form.getElementsByName`, but that will only return direct children\r\n                // and won't include inputs that use the HTML5 `form=` attribute. Since\r\n                // the input might not even be in a form. It might not even be in the\r\n                // document. Let's just use the local `querySelectorAll` to ensure we don't\r\n                // miss anything.\r\n                var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\r\n                for (var i = 0; i < group.length; i++) {\r\n                    var otherNode = group[i];\r\n                    if (otherNode === rootNode || otherNode.form !== rootNode.form) {\r\n                        continue;\r\n                    } // This will throw if radio buttons rendered by different copies of React\r\n                    // and the same name are rendered into the same form (same as #1939).\r\n                    // That's probably okay; we don't support it just as we don't support\r\n                    // mixing React radio buttons with non-React ones.\r\n                    var otherProps = getFiberCurrentPropsFromNode(otherNode);\r\n                    if (!otherProps) {\r\n                        {\r\n                            throw Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\");\r\n                        }\r\n                    } // We need update the tracked value on the named cousin since the value\r\n                    // was changed but the input saw no event or value set\r\n                    updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that\r\n                    // was previously checked to update will cause it to be come re-checked\r\n                    // as appropriate.\r\n                    updateWrapper(otherNode, otherProps);\r\n                }\r\n            }\r\n        } // In Chrome, assigning defaultValue to certain input types triggers input validation.\r\n        // For number inputs, the display value loses trailing decimal points. For email inputs,\r\n        // Chrome raises \"The specified value <x> is not a valid email address\".\r\n        //\r\n        // Here we check to see if the defaultValue has actually changed, avoiding these problems\r\n        // when the user is inputting text\r\n        //\r\n        // https://github.com/facebook/react/issues/7253\r\n        function setDefaultValue(node, type, value) {\r\n            if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\r\n            type !== 'number' || getActiveElement(node.ownerDocument) !== node) {\r\n                if (value == null) {\r\n                    node.defaultValue = toString(node._wrapperState.initialValue);\r\n                }\r\n                else if (node.defaultValue !== toString(value)) {\r\n                    node.defaultValue = toString(value);\r\n                }\r\n            }\r\n        }\r\n        var didWarnSelectedSetOnOption = false;\r\n        var didWarnInvalidChild = false;\r\n        function flattenChildren(children) {\r\n            var content = ''; // Flatten children. We'll warn if they are invalid\r\n            // during validateProps() which runs for hydration too.\r\n            // Note that this would throw on non-element objects.\r\n            // Elements are stringified (which is normally irrelevant\r\n            // but matters for <fbt>).\r\n            React.Children.forEach(children, function (child) {\r\n                if (child == null) {\r\n                    return;\r\n                }\r\n                content += child; // Note: we don't warn about invalid children here.\r\n                // Instead, this is done separately below so that\r\n                // it happens during the hydration code path too.\r\n            });\r\n            return content;\r\n        }\r\n        /**\r\n         * Implements an <option> host component that warns when `selected` is set.\r\n         */\r\n        function validateProps(element, props) {\r\n            {\r\n                // This mirrors the code path above, but runs for hydration too.\r\n                // Warn about invalid children here so that client and hydration are consistent.\r\n                // TODO: this seems like it could cause a DEV-only throw for hydration\r\n                // if children contains a non-element object. We should try to avoid that.\r\n                if (typeof props.children === 'object' && props.children !== null) {\r\n                    React.Children.forEach(props.children, function (child) {\r\n                        if (child == null) {\r\n                            return;\r\n                        }\r\n                        if (typeof child === 'string' || typeof child === 'number') {\r\n                            return;\r\n                        }\r\n                        if (typeof child.type !== 'string') {\r\n                            return;\r\n                        }\r\n                        if (!didWarnInvalidChild) {\r\n                            didWarnInvalidChild = true;\r\n                            error('Only strings and numbers are supported as <option> children.');\r\n                        }\r\n                    });\r\n                } // TODO: Remove support for `selected` in <option>.\r\n                if (props.selected != null && !didWarnSelectedSetOnOption) {\r\n                    error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\r\n                    didWarnSelectedSetOnOption = true;\r\n                }\r\n            }\r\n        }\r\n        function postMountWrapper$1(element, props) {\r\n            // value=\"\" should make a value attribute (#6219)\r\n            if (props.value != null) {\r\n                element.setAttribute('value', toString(getToStringValue(props.value)));\r\n            }\r\n        }\r\n        function getHostProps$1(element, props) {\r\n            var hostProps = _assign({\r\n                children: undefined\r\n            }, props);\r\n            var content = flattenChildren(props.children);\r\n            if (content) {\r\n                hostProps.children = content;\r\n            }\r\n            return hostProps;\r\n        }\r\n        var didWarnValueDefaultValue$1;\r\n        {\r\n            didWarnValueDefaultValue$1 = false;\r\n        }\r\n        function getDeclarationErrorAddendum() {\r\n            var ownerName = getCurrentFiberOwnerNameInDevOrNull();\r\n            if (ownerName) {\r\n                return '\\n\\nCheck the render method of `' + ownerName + '`.';\r\n            }\r\n            return '';\r\n        }\r\n        var valuePropNames = ['value', 'defaultValue'];\r\n        /**\r\n         * Validation function for `value` and `defaultValue`.\r\n         */\r\n        function checkSelectPropTypes(props) {\r\n            {\r\n                checkControlledValueProps('select', props);\r\n                for (var i = 0; i < valuePropNames.length; i++) {\r\n                    var propName = valuePropNames[i];\r\n                    if (props[propName] == null) {\r\n                        continue;\r\n                    }\r\n                    var isArray = Array.isArray(props[propName]);\r\n                    if (props.multiple && !isArray) {\r\n                        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\r\n                    }\r\n                    else if (!props.multiple && isArray) {\r\n                        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function updateOptions(node, multiple, propValue, setDefaultSelected) {\r\n            var options = node.options;\r\n            if (multiple) {\r\n                var selectedValues = propValue;\r\n                var selectedValue = {};\r\n                for (var i = 0; i < selectedValues.length; i++) {\r\n                    // Prefix to avoid chaos with special keys.\r\n                    selectedValue['$' + selectedValues[i]] = true;\r\n                }\r\n                for (var _i = 0; _i < options.length; _i++) {\r\n                    var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\r\n                    if (options[_i].selected !== selected) {\r\n                        options[_i].selected = selected;\r\n                    }\r\n                    if (selected && setDefaultSelected) {\r\n                        options[_i].defaultSelected = true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Do not set `select.value` as exact behavior isn't consistent across all\r\n                // browsers for all cases.\r\n                var _selectedValue = toString(getToStringValue(propValue));\r\n                var defaultSelected = null;\r\n                for (var _i2 = 0; _i2 < options.length; _i2++) {\r\n                    if (options[_i2].value === _selectedValue) {\r\n                        options[_i2].selected = true;\r\n                        if (setDefaultSelected) {\r\n                            options[_i2].defaultSelected = true;\r\n                        }\r\n                        return;\r\n                    }\r\n                    if (defaultSelected === null && !options[_i2].disabled) {\r\n                        defaultSelected = options[_i2];\r\n                    }\r\n                }\r\n                if (defaultSelected !== null) {\r\n                    defaultSelected.selected = true;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Implements a <select> host component that allows optionally setting the\r\n         * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\r\n         * stringable. If `multiple` is true, the prop must be an array of stringables.\r\n         *\r\n         * If `value` is not supplied (or null/undefined), user actions that change the\r\n         * selected option will trigger updates to the rendered options.\r\n         *\r\n         * If it is supplied (and not null/undefined), the rendered options will not\r\n         * update in response to user actions. Instead, the `value` prop must change in\r\n         * order for the rendered options to update.\r\n         *\r\n         * If `defaultValue` is provided, any options with the supplied values will be\r\n         * selected.\r\n         */\r\n        function getHostProps$2(element, props) {\r\n            return _assign({}, props, {\r\n                value: undefined\r\n            });\r\n        }\r\n        function initWrapperState$1(element, props) {\r\n            var node = element;\r\n            {\r\n                checkSelectPropTypes(props);\r\n            }\r\n            node._wrapperState = {\r\n                wasMultiple: !!props.multiple\r\n            };\r\n            {\r\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\r\n                    error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');\r\n                    didWarnValueDefaultValue$1 = true;\r\n                }\r\n            }\r\n        }\r\n        function postMountWrapper$2(element, props) {\r\n            var node = element;\r\n            node.multiple = !!props.multiple;\r\n            var value = props.value;\r\n            if (value != null) {\r\n                updateOptions(node, !!props.multiple, value, false);\r\n            }\r\n            else if (props.defaultValue != null) {\r\n                updateOptions(node, !!props.multiple, props.defaultValue, true);\r\n            }\r\n        }\r\n        function postUpdateWrapper(element, props) {\r\n            var node = element;\r\n            var wasMultiple = node._wrapperState.wasMultiple;\r\n            node._wrapperState.wasMultiple = !!props.multiple;\r\n            var value = props.value;\r\n            if (value != null) {\r\n                updateOptions(node, !!props.multiple, value, false);\r\n            }\r\n            else if (wasMultiple !== !!props.multiple) {\r\n                // For simplicity, reapply `defaultValue` if `multiple` is toggled.\r\n                if (props.defaultValue != null) {\r\n                    updateOptions(node, !!props.multiple, props.defaultValue, true);\r\n                }\r\n                else {\r\n                    // Revert the select back to its default unselected state.\r\n                    updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\r\n                }\r\n            }\r\n        }\r\n        function restoreControlledState$1(element, props) {\r\n            var node = element;\r\n            var value = props.value;\r\n            if (value != null) {\r\n                updateOptions(node, !!props.multiple, value, false);\r\n            }\r\n        }\r\n        var didWarnValDefaultVal = false;\r\n        /**\r\n         * Implements a <textarea> host component that allows setting `value`, and\r\n         * `defaultValue`. This differs from the traditional DOM API because value is\r\n         * usually set as PCDATA children.\r\n         *\r\n         * If `value` is not supplied (or null/undefined), user actions that affect the\r\n         * value will trigger updates to the element.\r\n         *\r\n         * If `value` is supplied (and not null/undefined), the rendered element will\r\n         * not trigger updates to the element. Instead, the `value` prop must change in\r\n         * order for the rendered element to be updated.\r\n         *\r\n         * The rendered element will be initialized with an empty value, the prop\r\n         * `defaultValue` if specified, or the children content (deprecated).\r\n         */\r\n        function getHostProps$3(element, props) {\r\n            var node = element;\r\n            if (!(props.dangerouslySetInnerHTML == null)) {\r\n                {\r\n                    throw Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\r\n                }\r\n            } // Always set children to the same thing. In IE9, the selection range will\r\n            // get reset if `textContent` is mutated.  We could add a check in setTextContent\r\n            // to only set the value if/when the value differs from the node value (which would\r\n            // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\r\n            // solution. The value can be a boolean or object so that's why it's forced\r\n            // to be a string.\r\n            var hostProps = _assign({}, props, {\r\n                value: undefined,\r\n                defaultValue: undefined,\r\n                children: toString(node._wrapperState.initialValue)\r\n            });\r\n            return hostProps;\r\n        }\r\n        function initWrapperState$2(element, props) {\r\n            var node = element;\r\n            {\r\n                checkControlledValueProps('textarea', props);\r\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\r\n                    error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\r\n                    didWarnValDefaultVal = true;\r\n                }\r\n            }\r\n            var initialValue = props.value; // Only bother fetching default value if we're going to use it\r\n            if (initialValue == null) {\r\n                var children = props.children, defaultValue = props.defaultValue;\r\n                if (children != null) {\r\n                    {\r\n                        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\r\n                    }\r\n                    {\r\n                        if (!(defaultValue == null)) {\r\n                            {\r\n                                throw Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\r\n                            }\r\n                        }\r\n                        if (Array.isArray(children)) {\r\n                            if (!(children.length <= 1)) {\r\n                                {\r\n                                    throw Error(\"<textarea> can only have at most one child.\");\r\n                                }\r\n                            }\r\n                            children = children[0];\r\n                        }\r\n                        defaultValue = children;\r\n                    }\r\n                }\r\n                if (defaultValue == null) {\r\n                    defaultValue = '';\r\n                }\r\n                initialValue = defaultValue;\r\n            }\r\n            node._wrapperState = {\r\n                initialValue: getToStringValue(initialValue)\r\n            };\r\n        }\r\n        function updateWrapper$1(element, props) {\r\n            var node = element;\r\n            var value = getToStringValue(props.value);\r\n            var defaultValue = getToStringValue(props.defaultValue);\r\n            if (value != null) {\r\n                // Cast `value` to a string to ensure the value is set correctly. While\r\n                // browsers typically do this as necessary, jsdom doesn't.\r\n                var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed\r\n                if (newValue !== node.value) {\r\n                    node.value = newValue;\r\n                }\r\n                if (props.defaultValue == null && node.defaultValue !== newValue) {\r\n                    node.defaultValue = newValue;\r\n                }\r\n            }\r\n            if (defaultValue != null) {\r\n                node.defaultValue = toString(defaultValue);\r\n            }\r\n        }\r\n        function postMountWrapper$3(element, props) {\r\n            var node = element; // This is in postMount because we need access to the DOM node, which is not\r\n            // available until after the component has mounted.\r\n            var textContent = node.textContent; // Only set node.value if textContent is equal to the expected\r\n            // initial value. In IE10/IE11 there is a bug where the placeholder attribute\r\n            // will populate textContent as well.\r\n            // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\r\n            if (textContent === node._wrapperState.initialValue) {\r\n                if (textContent !== '' && textContent !== null) {\r\n                    node.value = textContent;\r\n                }\r\n            }\r\n        }\r\n        function restoreControlledState$2(element, props) {\r\n            // DOM component is still mounted; update\r\n            updateWrapper$1(element, props);\r\n        }\r\n        var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\r\n        var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\r\n        var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\r\n        var Namespaces = {\r\n            html: HTML_NAMESPACE,\r\n            mathml: MATH_NAMESPACE,\r\n            svg: SVG_NAMESPACE\r\n        }; // Assumes there is no parent namespace.\r\n        function getIntrinsicNamespace(type) {\r\n            switch (type) {\r\n                case 'svg':\r\n                    return SVG_NAMESPACE;\r\n                case 'math':\r\n                    return MATH_NAMESPACE;\r\n                default:\r\n                    return HTML_NAMESPACE;\r\n            }\r\n        }\r\n        function getChildNamespace(parentNamespace, type) {\r\n            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\r\n                // No (or default) parent namespace: potential entry point.\r\n                return getIntrinsicNamespace(type);\r\n            }\r\n            if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\r\n                // We're leaving SVG.\r\n                return HTML_NAMESPACE;\r\n            } // By default, pass namespace below.\r\n            return parentNamespace;\r\n        }\r\n        /* globals MSApp */\r\n        /**\r\n         * Create a function which has 'unsafe' privileges (required by windows8 apps)\r\n         */\r\n        var createMicrosoftUnsafeLocalFunction = function (func) {\r\n            if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\r\n                return function (arg0, arg1, arg2, arg3) {\r\n                    MSApp.execUnsafeLocalFunction(function () {\r\n                        return func(arg0, arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            }\r\n            else {\r\n                return func;\r\n            }\r\n        };\r\n        var reusableSVGContainer;\r\n        /**\r\n         * Set the innerHTML property of a node\r\n         *\r\n         * @param {DOMElement} node\r\n         * @param {string} html\r\n         * @internal\r\n         */\r\n        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\r\n            if (node.namespaceURI === Namespaces.svg) {\r\n                if (!('innerHTML' in node)) {\r\n                    // IE does not have innerHTML for SVG nodes, so instead we inject the\r\n                    // new markup in a temp node and then move the child nodes across into\r\n                    // the target node\r\n                    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\r\n                    reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';\r\n                    var svgNode = reusableSVGContainer.firstChild;\r\n                    while (node.firstChild) {\r\n                        node.removeChild(node.firstChild);\r\n                    }\r\n                    while (svgNode.firstChild) {\r\n                        node.appendChild(svgNode.firstChild);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            node.innerHTML = html;\r\n        });\r\n        /**\r\n         * HTML nodeType values that represent the type of the node\r\n         */\r\n        var ELEMENT_NODE = 1;\r\n        var TEXT_NODE = 3;\r\n        var COMMENT_NODE = 8;\r\n        var DOCUMENT_NODE = 9;\r\n        var DOCUMENT_FRAGMENT_NODE = 11;\r\n        /**\r\n         * Set the textContent property of a node. For text updates, it's faster\r\n         * to set the `nodeValue` of the Text node directly instead of using\r\n         * `.textContent` which will remove the existing node and create a new one.\r\n         *\r\n         * @param {DOMElement} node\r\n         * @param {string} text\r\n         * @internal\r\n         */\r\n        var setTextContent = function (node, text) {\r\n            if (text) {\r\n                var firstChild = node.firstChild;\r\n                if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\r\n                    firstChild.nodeValue = text;\r\n                    return;\r\n                }\r\n            }\r\n            node.textContent = text;\r\n        };\r\n        // List derived from Gecko source code:\r\n        // https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\r\n        var shorthandToLonghand = {\r\n            animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],\r\n            background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],\r\n            backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],\r\n            border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],\r\n            borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],\r\n            borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],\r\n            borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],\r\n            borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],\r\n            borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],\r\n            borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],\r\n            borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],\r\n            borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],\r\n            borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],\r\n            borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],\r\n            borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],\r\n            borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],\r\n            borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],\r\n            columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],\r\n            columns: ['columnCount', 'columnWidth'],\r\n            flex: ['flexBasis', 'flexGrow', 'flexShrink'],\r\n            flexFlow: ['flexDirection', 'flexWrap'],\r\n            font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],\r\n            fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],\r\n            gap: ['columnGap', 'rowGap'],\r\n            grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],\r\n            gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],\r\n            gridColumn: ['gridColumnEnd', 'gridColumnStart'],\r\n            gridColumnGap: ['columnGap'],\r\n            gridGap: ['columnGap', 'rowGap'],\r\n            gridRow: ['gridRowEnd', 'gridRowStart'],\r\n            gridRowGap: ['rowGap'],\r\n            gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],\r\n            listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],\r\n            margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],\r\n            marker: ['markerEnd', 'markerMid', 'markerStart'],\r\n            mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],\r\n            maskPosition: ['maskPositionX', 'maskPositionY'],\r\n            outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],\r\n            overflow: ['overflowX', 'overflowY'],\r\n            padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],\r\n            placeContent: ['alignContent', 'justifyContent'],\r\n            placeItems: ['alignItems', 'justifyItems'],\r\n            placeSelf: ['alignSelf', 'justifySelf'],\r\n            textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],\r\n            textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],\r\n            transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],\r\n            wordWrap: ['overflowWrap']\r\n        };\r\n        /**\r\n         * CSS properties which accept numbers but are not in units of \"px\".\r\n         */\r\n        var isUnitlessNumber = {\r\n            animationIterationCount: true,\r\n            borderImageOutset: true,\r\n            borderImageSlice: true,\r\n            borderImageWidth: true,\r\n            boxFlex: true,\r\n            boxFlexGroup: true,\r\n            boxOrdinalGroup: true,\r\n            columnCount: true,\r\n            columns: true,\r\n            flex: true,\r\n            flexGrow: true,\r\n            flexPositive: true,\r\n            flexShrink: true,\r\n            flexNegative: true,\r\n            flexOrder: true,\r\n            gridArea: true,\r\n            gridRow: true,\r\n            gridRowEnd: true,\r\n            gridRowSpan: true,\r\n            gridRowStart: true,\r\n            gridColumn: true,\r\n            gridColumnEnd: true,\r\n            gridColumnSpan: true,\r\n            gridColumnStart: true,\r\n            fontWeight: true,\r\n            lineClamp: true,\r\n            lineHeight: true,\r\n            opacity: true,\r\n            order: true,\r\n            orphans: true,\r\n            tabSize: true,\r\n            widows: true,\r\n            zIndex: true,\r\n            zoom: true,\r\n            // SVG-related properties\r\n            fillOpacity: true,\r\n            floodOpacity: true,\r\n            stopOpacity: true,\r\n            strokeDasharray: true,\r\n            strokeDashoffset: true,\r\n            strokeMiterlimit: true,\r\n            strokeOpacity: true,\r\n            strokeWidth: true\r\n        };\r\n        /**\r\n         * @param {string} prefix vendor-specific prefix, eg: Webkit\r\n         * @param {string} key style name, eg: transitionDuration\r\n         * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\r\n         * WebkitTransitionDuration\r\n         */\r\n        function prefixKey(prefix, key) {\r\n            return prefix + key.charAt(0).toUpperCase() + key.substring(1);\r\n        }\r\n        /**\r\n         * Support style names that may come passed in prefixed by adding permutations\r\n         * of vendor prefixes.\r\n         */\r\n        var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\r\n        // infinite loop, because it iterates over the newly added props too.\r\n        Object.keys(isUnitlessNumber).forEach(function (prop) {\r\n            prefixes.forEach(function (prefix) {\r\n                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\r\n            });\r\n        });\r\n        /**\r\n         * Convert a value into the proper css writable value. The style name `name`\r\n         * should be logical (no hyphens), as specified\r\n         * in `CSSProperty.isUnitlessNumber`.\r\n         *\r\n         * @param {string} name CSS property name such as `topMargin`.\r\n         * @param {*} value CSS property value such as `10px`.\r\n         * @return {string} Normalized style value with dimensions applied.\r\n         */\r\n        function dangerousStyleValue(name, value, isCustomProperty) {\r\n            // Note that we've removed escapeTextForBrowser() calls here since the\r\n            // whole string will be escaped when the attribute is injected into\r\n            // the markup. If you provide unsafe user data here they can inject\r\n            // arbitrary CSS which may be problematic (I couldn't repro this):\r\n            // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\r\n            // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\r\n            // This is not an XSS hole but instead a potential CSS injection issue\r\n            // which has lead to a greater discussion about how we're going to\r\n            // trust URLs moving forward. See #2115901\r\n            var isEmpty = value == null || typeof value === 'boolean' || value === '';\r\n            if (isEmpty) {\r\n                return '';\r\n            }\r\n            if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\r\n                return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\r\n            }\r\n            return ('' + value).trim();\r\n        }\r\n        var uppercasePattern = /([A-Z])/g;\r\n        var msPattern = /^ms-/;\r\n        /**\r\n         * Hyphenates a camelcased CSS property name, for example:\r\n         *\r\n         *   > hyphenateStyleName('backgroundColor')\r\n         *   < \"background-color\"\r\n         *   > hyphenateStyleName('MozTransition')\r\n         *   < \"-moz-transition\"\r\n         *   > hyphenateStyleName('msTransition')\r\n         *   < \"-ms-transition\"\r\n         *\r\n         * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\r\n         * is converted to `-ms-`.\r\n         */\r\n        function hyphenateStyleName(name) {\r\n            return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');\r\n        }\r\n        var warnValidStyle = function () { };\r\n        {\r\n            // 'msTransform' is correct, but the other prefixes should be capitalized\r\n            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\r\n            var msPattern$1 = /^-ms-/;\r\n            var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\r\n            var badStyleValueWithSemicolonPattern = /;\\s*$/;\r\n            var warnedStyleNames = {};\r\n            var warnedStyleValues = {};\r\n            var warnedForNaNValue = false;\r\n            var warnedForInfinityValue = false;\r\n            var camelize = function (string) {\r\n                return string.replace(hyphenPattern, function (_, character) {\r\n                    return character.toUpperCase();\r\n                });\r\n            };\r\n            var warnHyphenatedStyleName = function (name) {\r\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\r\n                    return;\r\n                }\r\n                warnedStyleNames[name] = true;\r\n                error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests\r\n                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\r\n                // is converted to lowercase `ms`.\r\n                camelize(name.replace(msPattern$1, 'ms-')));\r\n            };\r\n            var warnBadVendoredStyleName = function (name) {\r\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\r\n                    return;\r\n                }\r\n                warnedStyleNames[name] = true;\r\n                error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));\r\n            };\r\n            var warnStyleValueWithSemicolon = function (name, value) {\r\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\r\n                    return;\r\n                }\r\n                warnedStyleValues[value] = true;\r\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));\r\n            };\r\n            var warnStyleValueIsNaN = function (name, value) {\r\n                if (warnedForNaNValue) {\r\n                    return;\r\n                }\r\n                warnedForNaNValue = true;\r\n                error('`NaN` is an invalid value for the `%s` css style property.', name);\r\n            };\r\n            var warnStyleValueIsInfinity = function (name, value) {\r\n                if (warnedForInfinityValue) {\r\n                    return;\r\n                }\r\n                warnedForInfinityValue = true;\r\n                error('`Infinity` is an invalid value for the `%s` css style property.', name);\r\n            };\r\n            warnValidStyle = function (name, value) {\r\n                if (name.indexOf('-') > -1) {\r\n                    warnHyphenatedStyleName(name);\r\n                }\r\n                else if (badVendoredStyleNamePattern.test(name)) {\r\n                    warnBadVendoredStyleName(name);\r\n                }\r\n                else if (badStyleValueWithSemicolonPattern.test(value)) {\r\n                    warnStyleValueWithSemicolon(name, value);\r\n                }\r\n                if (typeof value === 'number') {\r\n                    if (isNaN(value)) {\r\n                        warnStyleValueIsNaN(name, value);\r\n                    }\r\n                    else if (!isFinite(value)) {\r\n                        warnStyleValueIsInfinity(name, value);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        var warnValidStyle$1 = warnValidStyle;\r\n        /**\r\n         * Operations for dealing with CSS properties.\r\n         */\r\n        /**\r\n         * This creates a string that is expected to be equivalent to the style\r\n         * attribute generated by server-side rendering. It by-passes warnings and\r\n         * security checks so it's not safe to use this value for anything other than\r\n         * comparison. It is only used in DEV for SSR validation.\r\n         */\r\n        function createDangerousStringForStyles(styles) {\r\n            {\r\n                var serialized = '';\r\n                var delimiter = '';\r\n                for (var styleName in styles) {\r\n                    if (!styles.hasOwnProperty(styleName)) {\r\n                        continue;\r\n                    }\r\n                    var styleValue = styles[styleName];\r\n                    if (styleValue != null) {\r\n                        var isCustomProperty = styleName.indexOf('--') === 0;\r\n                        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';\r\n                        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\r\n                        delimiter = ';';\r\n                    }\r\n                }\r\n                return serialized || null;\r\n            }\r\n        }\r\n        /**\r\n         * Sets the value for multiple styles on a node.  If a value is specified as\r\n         * '' (empty string), the corresponding style property will be unset.\r\n         *\r\n         * @param {DOMElement} node\r\n         * @param {object} styles\r\n         */\r\n        function setValueForStyles(node, styles) {\r\n            var style = node.style;\r\n            for (var styleName in styles) {\r\n                if (!styles.hasOwnProperty(styleName)) {\r\n                    continue;\r\n                }\r\n                var isCustomProperty = styleName.indexOf('--') === 0;\r\n                {\r\n                    if (!isCustomProperty) {\r\n                        warnValidStyle$1(styleName, styles[styleName]);\r\n                    }\r\n                }\r\n                var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\r\n                if (styleName === 'float') {\r\n                    styleName = 'cssFloat';\r\n                }\r\n                if (isCustomProperty) {\r\n                    style.setProperty(styleName, styleValue);\r\n                }\r\n                else {\r\n                    style[styleName] = styleValue;\r\n                }\r\n            }\r\n        }\r\n        function isValueEmpty(value) {\r\n            return value == null || typeof value === 'boolean' || value === '';\r\n        }\r\n        /**\r\n         * Given {color: 'red', overflow: 'hidden'} returns {\r\n         *   color: 'color',\r\n         *   overflowX: 'overflow',\r\n         *   overflowY: 'overflow',\r\n         * }. This can be read as \"the overflowY property was set by the overflow\r\n         * shorthand\". That is, the values are the property that each was derived from.\r\n         */\r\n        function expandShorthandMap(styles) {\r\n            var expanded = {};\r\n            for (var key in styles) {\r\n                var longhands = shorthandToLonghand[key] || [key];\r\n                for (var i = 0; i < longhands.length; i++) {\r\n                    expanded[longhands[i]] = key;\r\n                }\r\n            }\r\n            return expanded;\r\n        }\r\n        /**\r\n         * When mixing shorthand and longhand property names, we warn during updates if\r\n         * we expect an incorrect result to occur. In particular, we warn for:\r\n         *\r\n         * Updating a shorthand property (longhand gets overwritten):\r\n         *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\r\n         *   becomes .style.font = 'baz'\r\n         * Removing a shorthand property (longhand gets lost too):\r\n         *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\r\n         *   becomes .style.font = ''\r\n         * Removing a longhand property (should revert to shorthand; doesn't):\r\n         *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\r\n         *   becomes .style.fontVariant = ''\r\n         */\r\n        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\r\n            {\r\n                if (!nextStyles) {\r\n                    return;\r\n                }\r\n                var expandedUpdates = expandShorthandMap(styleUpdates);\r\n                var expandedStyles = expandShorthandMap(nextStyles);\r\n                var warnedAbout = {};\r\n                for (var key in expandedUpdates) {\r\n                    var originalKey = expandedUpdates[key];\r\n                    var correctOriginalKey = expandedStyles[key];\r\n                    if (correctOriginalKey && originalKey !== correctOriginalKey) {\r\n                        var warningKey = originalKey + ',' + correctOriginalKey;\r\n                        if (warnedAbout[warningKey]) {\r\n                            continue;\r\n                        }\r\n                        warnedAbout[warningKey] = true;\r\n                        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + \"avoid this, don't mix shorthand and non-shorthand properties \" + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // For HTML, certain tags should omit their close tag. We keep a list for\r\n        // those special-case tags.\r\n        var omittedCloseTags = {\r\n            area: true,\r\n            base: true,\r\n            br: true,\r\n            col: true,\r\n            embed: true,\r\n            hr: true,\r\n            img: true,\r\n            input: true,\r\n            keygen: true,\r\n            link: true,\r\n            meta: true,\r\n            param: true,\r\n            source: true,\r\n            track: true,\r\n            wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.\r\n        };\r\n        // `omittedCloseTags` except that `menuitem` should still have its closing tag.\r\n        var voidElementTags = _assign({\r\n            menuitem: true\r\n        }, omittedCloseTags);\r\n        var HTML = '__html';\r\n        function assertValidProps(tag, props) {\r\n            if (!props) {\r\n                return;\r\n            } // Note the use of `==` which checks for null or undefined.\r\n            if (voidElementTags[tag]) {\r\n                if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {\r\n                    {\r\n                        throw Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\r\n                    }\r\n                }\r\n            }\r\n            if (props.dangerouslySetInnerHTML != null) {\r\n                if (!(props.children == null)) {\r\n                    {\r\n                        throw Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\r\n                    }\r\n                }\r\n                if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {\r\n                    {\r\n                        throw Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.\");\r\n                    }\r\n                }\r\n            }\r\n            {\r\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\r\n                    error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');\r\n                }\r\n            }\r\n            if (!(props.style == null || typeof props.style === 'object')) {\r\n                {\r\n                    throw Error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\r\n                }\r\n            }\r\n        }\r\n        function isCustomComponent(tagName, props) {\r\n            if (tagName.indexOf('-') === -1) {\r\n                return typeof props.is === 'string';\r\n            }\r\n            switch (tagName) {\r\n                // These are reserved SVG and MathML elements.\r\n                // We don't mind this list too much because we expect it to never grow.\r\n                // The alternative is to track the namespace in a few places which is convoluted.\r\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\r\n                case 'annotation-xml':\r\n                case 'color-profile':\r\n                case 'font-face':\r\n                case 'font-face-src':\r\n                case 'font-face-uri':\r\n                case 'font-face-format':\r\n                case 'font-face-name':\r\n                case 'missing-glyph':\r\n                    return false;\r\n                default:\r\n                    return true;\r\n            }\r\n        }\r\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\r\n        // also add them to this module to ensure casing and incorrect name\r\n        // warnings.\r\n        var possibleStandardNames = {\r\n            // HTML\r\n            accept: 'accept',\r\n            acceptcharset: 'acceptCharset',\r\n            'accept-charset': 'acceptCharset',\r\n            accesskey: 'accessKey',\r\n            action: 'action',\r\n            allowfullscreen: 'allowFullScreen',\r\n            alt: 'alt',\r\n            as: 'as',\r\n            async: 'async',\r\n            autocapitalize: 'autoCapitalize',\r\n            autocomplete: 'autoComplete',\r\n            autocorrect: 'autoCorrect',\r\n            autofocus: 'autoFocus',\r\n            autoplay: 'autoPlay',\r\n            autosave: 'autoSave',\r\n            capture: 'capture',\r\n            cellpadding: 'cellPadding',\r\n            cellspacing: 'cellSpacing',\r\n            challenge: 'challenge',\r\n            charset: 'charSet',\r\n            checked: 'checked',\r\n            children: 'children',\r\n            cite: 'cite',\r\n            class: 'className',\r\n            classid: 'classID',\r\n            classname: 'className',\r\n            cols: 'cols',\r\n            colspan: 'colSpan',\r\n            content: 'content',\r\n            contenteditable: 'contentEditable',\r\n            contextmenu: 'contextMenu',\r\n            controls: 'controls',\r\n            controlslist: 'controlsList',\r\n            coords: 'coords',\r\n            crossorigin: 'crossOrigin',\r\n            dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\r\n            data: 'data',\r\n            datetime: 'dateTime',\r\n            default: 'default',\r\n            defaultchecked: 'defaultChecked',\r\n            defaultvalue: 'defaultValue',\r\n            defer: 'defer',\r\n            dir: 'dir',\r\n            disabled: 'disabled',\r\n            disablepictureinpicture: 'disablePictureInPicture',\r\n            disableremoteplayback: 'disableRemotePlayback',\r\n            download: 'download',\r\n            draggable: 'draggable',\r\n            enctype: 'encType',\r\n            enterkeyhint: 'enterKeyHint',\r\n            for: 'htmlFor',\r\n            form: 'form',\r\n            formmethod: 'formMethod',\r\n            formaction: 'formAction',\r\n            formenctype: 'formEncType',\r\n            formnovalidate: 'formNoValidate',\r\n            formtarget: 'formTarget',\r\n            frameborder: 'frameBorder',\r\n            headers: 'headers',\r\n            height: 'height',\r\n            hidden: 'hidden',\r\n            high: 'high',\r\n            href: 'href',\r\n            hreflang: 'hrefLang',\r\n            htmlfor: 'htmlFor',\r\n            httpequiv: 'httpEquiv',\r\n            'http-equiv': 'httpEquiv',\r\n            icon: 'icon',\r\n            id: 'id',\r\n            innerhtml: 'innerHTML',\r\n            inputmode: 'inputMode',\r\n            integrity: 'integrity',\r\n            is: 'is',\r\n            itemid: 'itemID',\r\n            itemprop: 'itemProp',\r\n            itemref: 'itemRef',\r\n            itemscope: 'itemScope',\r\n            itemtype: 'itemType',\r\n            keyparams: 'keyParams',\r\n            keytype: 'keyType',\r\n            kind: 'kind',\r\n            label: 'label',\r\n            lang: 'lang',\r\n            list: 'list',\r\n            loop: 'loop',\r\n            low: 'low',\r\n            manifest: 'manifest',\r\n            marginwidth: 'marginWidth',\r\n            marginheight: 'marginHeight',\r\n            max: 'max',\r\n            maxlength: 'maxLength',\r\n            media: 'media',\r\n            mediagroup: 'mediaGroup',\r\n            method: 'method',\r\n            min: 'min',\r\n            minlength: 'minLength',\r\n            multiple: 'multiple',\r\n            muted: 'muted',\r\n            name: 'name',\r\n            nomodule: 'noModule',\r\n            nonce: 'nonce',\r\n            novalidate: 'noValidate',\r\n            open: 'open',\r\n            optimum: 'optimum',\r\n            pattern: 'pattern',\r\n            placeholder: 'placeholder',\r\n            playsinline: 'playsInline',\r\n            poster: 'poster',\r\n            preload: 'preload',\r\n            profile: 'profile',\r\n            radiogroup: 'radioGroup',\r\n            readonly: 'readOnly',\r\n            referrerpolicy: 'referrerPolicy',\r\n            rel: 'rel',\r\n            required: 'required',\r\n            reversed: 'reversed',\r\n            role: 'role',\r\n            rows: 'rows',\r\n            rowspan: 'rowSpan',\r\n            sandbox: 'sandbox',\r\n            scope: 'scope',\r\n            scoped: 'scoped',\r\n            scrolling: 'scrolling',\r\n            seamless: 'seamless',\r\n            selected: 'selected',\r\n            shape: 'shape',\r\n            size: 'size',\r\n            sizes: 'sizes',\r\n            span: 'span',\r\n            spellcheck: 'spellCheck',\r\n            src: 'src',\r\n            srcdoc: 'srcDoc',\r\n            srclang: 'srcLang',\r\n            srcset: 'srcSet',\r\n            start: 'start',\r\n            step: 'step',\r\n            style: 'style',\r\n            summary: 'summary',\r\n            tabindex: 'tabIndex',\r\n            target: 'target',\r\n            title: 'title',\r\n            type: 'type',\r\n            usemap: 'useMap',\r\n            value: 'value',\r\n            width: 'width',\r\n            wmode: 'wmode',\r\n            wrap: 'wrap',\r\n            // SVG\r\n            about: 'about',\r\n            accentheight: 'accentHeight',\r\n            'accent-height': 'accentHeight',\r\n            accumulate: 'accumulate',\r\n            additive: 'additive',\r\n            alignmentbaseline: 'alignmentBaseline',\r\n            'alignment-baseline': 'alignmentBaseline',\r\n            allowreorder: 'allowReorder',\r\n            alphabetic: 'alphabetic',\r\n            amplitude: 'amplitude',\r\n            arabicform: 'arabicForm',\r\n            'arabic-form': 'arabicForm',\r\n            ascent: 'ascent',\r\n            attributename: 'attributeName',\r\n            attributetype: 'attributeType',\r\n            autoreverse: 'autoReverse',\r\n            azimuth: 'azimuth',\r\n            basefrequency: 'baseFrequency',\r\n            baselineshift: 'baselineShift',\r\n            'baseline-shift': 'baselineShift',\r\n            baseprofile: 'baseProfile',\r\n            bbox: 'bbox',\r\n            begin: 'begin',\r\n            bias: 'bias',\r\n            by: 'by',\r\n            calcmode: 'calcMode',\r\n            capheight: 'capHeight',\r\n            'cap-height': 'capHeight',\r\n            clip: 'clip',\r\n            clippath: 'clipPath',\r\n            'clip-path': 'clipPath',\r\n            clippathunits: 'clipPathUnits',\r\n            cliprule: 'clipRule',\r\n            'clip-rule': 'clipRule',\r\n            color: 'color',\r\n            colorinterpolation: 'colorInterpolation',\r\n            'color-interpolation': 'colorInterpolation',\r\n            colorinterpolationfilters: 'colorInterpolationFilters',\r\n            'color-interpolation-filters': 'colorInterpolationFilters',\r\n            colorprofile: 'colorProfile',\r\n            'color-profile': 'colorProfile',\r\n            colorrendering: 'colorRendering',\r\n            'color-rendering': 'colorRendering',\r\n            contentscripttype: 'contentScriptType',\r\n            contentstyletype: 'contentStyleType',\r\n            cursor: 'cursor',\r\n            cx: 'cx',\r\n            cy: 'cy',\r\n            d: 'd',\r\n            datatype: 'datatype',\r\n            decelerate: 'decelerate',\r\n            descent: 'descent',\r\n            diffuseconstant: 'diffuseConstant',\r\n            direction: 'direction',\r\n            display: 'display',\r\n            divisor: 'divisor',\r\n            dominantbaseline: 'dominantBaseline',\r\n            'dominant-baseline': 'dominantBaseline',\r\n            dur: 'dur',\r\n            dx: 'dx',\r\n            dy: 'dy',\r\n            edgemode: 'edgeMode',\r\n            elevation: 'elevation',\r\n            enablebackground: 'enableBackground',\r\n            'enable-background': 'enableBackground',\r\n            end: 'end',\r\n            exponent: 'exponent',\r\n            externalresourcesrequired: 'externalResourcesRequired',\r\n            fill: 'fill',\r\n            fillopacity: 'fillOpacity',\r\n            'fill-opacity': 'fillOpacity',\r\n            fillrule: 'fillRule',\r\n            'fill-rule': 'fillRule',\r\n            filter: 'filter',\r\n            filterres: 'filterRes',\r\n            filterunits: 'filterUnits',\r\n            floodopacity: 'floodOpacity',\r\n            'flood-opacity': 'floodOpacity',\r\n            floodcolor: 'floodColor',\r\n            'flood-color': 'floodColor',\r\n            focusable: 'focusable',\r\n            fontfamily: 'fontFamily',\r\n            'font-family': 'fontFamily',\r\n            fontsize: 'fontSize',\r\n            'font-size': 'fontSize',\r\n            fontsizeadjust: 'fontSizeAdjust',\r\n            'font-size-adjust': 'fontSizeAdjust',\r\n            fontstretch: 'fontStretch',\r\n            'font-stretch': 'fontStretch',\r\n            fontstyle: 'fontStyle',\r\n            'font-style': 'fontStyle',\r\n            fontvariant: 'fontVariant',\r\n            'font-variant': 'fontVariant',\r\n            fontweight: 'fontWeight',\r\n            'font-weight': 'fontWeight',\r\n            format: 'format',\r\n            from: 'from',\r\n            fx: 'fx',\r\n            fy: 'fy',\r\n            g1: 'g1',\r\n            g2: 'g2',\r\n            glyphname: 'glyphName',\r\n            'glyph-name': 'glyphName',\r\n            glyphorientationhorizontal: 'glyphOrientationHorizontal',\r\n            'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\r\n            glyphorientationvertical: 'glyphOrientationVertical',\r\n            'glyph-orientation-vertical': 'glyphOrientationVertical',\r\n            glyphref: 'glyphRef',\r\n            gradienttransform: 'gradientTransform',\r\n            gradientunits: 'gradientUnits',\r\n            hanging: 'hanging',\r\n            horizadvx: 'horizAdvX',\r\n            'horiz-adv-x': 'horizAdvX',\r\n            horizoriginx: 'horizOriginX',\r\n            'horiz-origin-x': 'horizOriginX',\r\n            ideographic: 'ideographic',\r\n            imagerendering: 'imageRendering',\r\n            'image-rendering': 'imageRendering',\r\n            in2: 'in2',\r\n            in: 'in',\r\n            inlist: 'inlist',\r\n            intercept: 'intercept',\r\n            k1: 'k1',\r\n            k2: 'k2',\r\n            k3: 'k3',\r\n            k4: 'k4',\r\n            k: 'k',\r\n            kernelmatrix: 'kernelMatrix',\r\n            kernelunitlength: 'kernelUnitLength',\r\n            kerning: 'kerning',\r\n            keypoints: 'keyPoints',\r\n            keysplines: 'keySplines',\r\n            keytimes: 'keyTimes',\r\n            lengthadjust: 'lengthAdjust',\r\n            letterspacing: 'letterSpacing',\r\n            'letter-spacing': 'letterSpacing',\r\n            lightingcolor: 'lightingColor',\r\n            'lighting-color': 'lightingColor',\r\n            limitingconeangle: 'limitingConeAngle',\r\n            local: 'local',\r\n            markerend: 'markerEnd',\r\n            'marker-end': 'markerEnd',\r\n            markerheight: 'markerHeight',\r\n            markermid: 'markerMid',\r\n            'marker-mid': 'markerMid',\r\n            markerstart: 'markerStart',\r\n            'marker-start': 'markerStart',\r\n            markerunits: 'markerUnits',\r\n            markerwidth: 'markerWidth',\r\n            mask: 'mask',\r\n            maskcontentunits: 'maskContentUnits',\r\n            maskunits: 'maskUnits',\r\n            mathematical: 'mathematical',\r\n            mode: 'mode',\r\n            numoctaves: 'numOctaves',\r\n            offset: 'offset',\r\n            opacity: 'opacity',\r\n            operator: 'operator',\r\n            order: 'order',\r\n            orient: 'orient',\r\n            orientation: 'orientation',\r\n            origin: 'origin',\r\n            overflow: 'overflow',\r\n            overlineposition: 'overlinePosition',\r\n            'overline-position': 'overlinePosition',\r\n            overlinethickness: 'overlineThickness',\r\n            'overline-thickness': 'overlineThickness',\r\n            paintorder: 'paintOrder',\r\n            'paint-order': 'paintOrder',\r\n            panose1: 'panose1',\r\n            'panose-1': 'panose1',\r\n            pathlength: 'pathLength',\r\n            patterncontentunits: 'patternContentUnits',\r\n            patterntransform: 'patternTransform',\r\n            patternunits: 'patternUnits',\r\n            pointerevents: 'pointerEvents',\r\n            'pointer-events': 'pointerEvents',\r\n            points: 'points',\r\n            pointsatx: 'pointsAtX',\r\n            pointsaty: 'pointsAtY',\r\n            pointsatz: 'pointsAtZ',\r\n            prefix: 'prefix',\r\n            preservealpha: 'preserveAlpha',\r\n            preserveaspectratio: 'preserveAspectRatio',\r\n            primitiveunits: 'primitiveUnits',\r\n            property: 'property',\r\n            r: 'r',\r\n            radius: 'radius',\r\n            refx: 'refX',\r\n            refy: 'refY',\r\n            renderingintent: 'renderingIntent',\r\n            'rendering-intent': 'renderingIntent',\r\n            repeatcount: 'repeatCount',\r\n            repeatdur: 'repeatDur',\r\n            requiredextensions: 'requiredExtensions',\r\n            requiredfeatures: 'requiredFeatures',\r\n            resource: 'resource',\r\n            restart: 'restart',\r\n            result: 'result',\r\n            results: 'results',\r\n            rotate: 'rotate',\r\n            rx: 'rx',\r\n            ry: 'ry',\r\n            scale: 'scale',\r\n            security: 'security',\r\n            seed: 'seed',\r\n            shaperendering: 'shapeRendering',\r\n            'shape-rendering': 'shapeRendering',\r\n            slope: 'slope',\r\n            spacing: 'spacing',\r\n            specularconstant: 'specularConstant',\r\n            specularexponent: 'specularExponent',\r\n            speed: 'speed',\r\n            spreadmethod: 'spreadMethod',\r\n            startoffset: 'startOffset',\r\n            stddeviation: 'stdDeviation',\r\n            stemh: 'stemh',\r\n            stemv: 'stemv',\r\n            stitchtiles: 'stitchTiles',\r\n            stopcolor: 'stopColor',\r\n            'stop-color': 'stopColor',\r\n            stopopacity: 'stopOpacity',\r\n            'stop-opacity': 'stopOpacity',\r\n            strikethroughposition: 'strikethroughPosition',\r\n            'strikethrough-position': 'strikethroughPosition',\r\n            strikethroughthickness: 'strikethroughThickness',\r\n            'strikethrough-thickness': 'strikethroughThickness',\r\n            string: 'string',\r\n            stroke: 'stroke',\r\n            strokedasharray: 'strokeDasharray',\r\n            'stroke-dasharray': 'strokeDasharray',\r\n            strokedashoffset: 'strokeDashoffset',\r\n            'stroke-dashoffset': 'strokeDashoffset',\r\n            strokelinecap: 'strokeLinecap',\r\n            'stroke-linecap': 'strokeLinecap',\r\n            strokelinejoin: 'strokeLinejoin',\r\n            'stroke-linejoin': 'strokeLinejoin',\r\n            strokemiterlimit: 'strokeMiterlimit',\r\n            'stroke-miterlimit': 'strokeMiterlimit',\r\n            strokewidth: 'strokeWidth',\r\n            'stroke-width': 'strokeWidth',\r\n            strokeopacity: 'strokeOpacity',\r\n            'stroke-opacity': 'strokeOpacity',\r\n            suppresscontenteditablewarning: 'suppressContentEditableWarning',\r\n            suppresshydrationwarning: 'suppressHydrationWarning',\r\n            surfacescale: 'surfaceScale',\r\n            systemlanguage: 'systemLanguage',\r\n            tablevalues: 'tableValues',\r\n            targetx: 'targetX',\r\n            targety: 'targetY',\r\n            textanchor: 'textAnchor',\r\n            'text-anchor': 'textAnchor',\r\n            textdecoration: 'textDecoration',\r\n            'text-decoration': 'textDecoration',\r\n            textlength: 'textLength',\r\n            textrendering: 'textRendering',\r\n            'text-rendering': 'textRendering',\r\n            to: 'to',\r\n            transform: 'transform',\r\n            typeof: 'typeof',\r\n            u1: 'u1',\r\n            u2: 'u2',\r\n            underlineposition: 'underlinePosition',\r\n            'underline-position': 'underlinePosition',\r\n            underlinethickness: 'underlineThickness',\r\n            'underline-thickness': 'underlineThickness',\r\n            unicode: 'unicode',\r\n            unicodebidi: 'unicodeBidi',\r\n            'unicode-bidi': 'unicodeBidi',\r\n            unicoderange: 'unicodeRange',\r\n            'unicode-range': 'unicodeRange',\r\n            unitsperem: 'unitsPerEm',\r\n            'units-per-em': 'unitsPerEm',\r\n            unselectable: 'unselectable',\r\n            valphabetic: 'vAlphabetic',\r\n            'v-alphabetic': 'vAlphabetic',\r\n            values: 'values',\r\n            vectoreffect: 'vectorEffect',\r\n            'vector-effect': 'vectorEffect',\r\n            version: 'version',\r\n            vertadvy: 'vertAdvY',\r\n            'vert-adv-y': 'vertAdvY',\r\n            vertoriginx: 'vertOriginX',\r\n            'vert-origin-x': 'vertOriginX',\r\n            vertoriginy: 'vertOriginY',\r\n            'vert-origin-y': 'vertOriginY',\r\n            vhanging: 'vHanging',\r\n            'v-hanging': 'vHanging',\r\n            videographic: 'vIdeographic',\r\n            'v-ideographic': 'vIdeographic',\r\n            viewbox: 'viewBox',\r\n            viewtarget: 'viewTarget',\r\n            visibility: 'visibility',\r\n            vmathematical: 'vMathematical',\r\n            'v-mathematical': 'vMathematical',\r\n            vocab: 'vocab',\r\n            widths: 'widths',\r\n            wordspacing: 'wordSpacing',\r\n            'word-spacing': 'wordSpacing',\r\n            writingmode: 'writingMode',\r\n            'writing-mode': 'writingMode',\r\n            x1: 'x1',\r\n            x2: 'x2',\r\n            x: 'x',\r\n            xchannelselector: 'xChannelSelector',\r\n            xheight: 'xHeight',\r\n            'x-height': 'xHeight',\r\n            xlinkactuate: 'xlinkActuate',\r\n            'xlink:actuate': 'xlinkActuate',\r\n            xlinkarcrole: 'xlinkArcrole',\r\n            'xlink:arcrole': 'xlinkArcrole',\r\n            xlinkhref: 'xlinkHref',\r\n            'xlink:href': 'xlinkHref',\r\n            xlinkrole: 'xlinkRole',\r\n            'xlink:role': 'xlinkRole',\r\n            xlinkshow: 'xlinkShow',\r\n            'xlink:show': 'xlinkShow',\r\n            xlinktitle: 'xlinkTitle',\r\n            'xlink:title': 'xlinkTitle',\r\n            xlinktype: 'xlinkType',\r\n            'xlink:type': 'xlinkType',\r\n            xmlbase: 'xmlBase',\r\n            'xml:base': 'xmlBase',\r\n            xmllang: 'xmlLang',\r\n            'xml:lang': 'xmlLang',\r\n            xmlns: 'xmlns',\r\n            'xml:space': 'xmlSpace',\r\n            xmlnsxlink: 'xmlnsXlink',\r\n            'xmlns:xlink': 'xmlnsXlink',\r\n            xmlspace: 'xmlSpace',\r\n            y1: 'y1',\r\n            y2: 'y2',\r\n            y: 'y',\r\n            ychannelselector: 'yChannelSelector',\r\n            z: 'z',\r\n            zoomandpan: 'zoomAndPan'\r\n        };\r\n        var ariaProperties = {\r\n            'aria-current': 0,\r\n            // state\r\n            'aria-details': 0,\r\n            'aria-disabled': 0,\r\n            // state\r\n            'aria-hidden': 0,\r\n            // state\r\n            'aria-invalid': 0,\r\n            // state\r\n            'aria-keyshortcuts': 0,\r\n            'aria-label': 0,\r\n            'aria-roledescription': 0,\r\n            // Widget Attributes\r\n            'aria-autocomplete': 0,\r\n            'aria-checked': 0,\r\n            'aria-expanded': 0,\r\n            'aria-haspopup': 0,\r\n            'aria-level': 0,\r\n            'aria-modal': 0,\r\n            'aria-multiline': 0,\r\n            'aria-multiselectable': 0,\r\n            'aria-orientation': 0,\r\n            'aria-placeholder': 0,\r\n            'aria-pressed': 0,\r\n            'aria-readonly': 0,\r\n            'aria-required': 0,\r\n            'aria-selected': 0,\r\n            'aria-sort': 0,\r\n            'aria-valuemax': 0,\r\n            'aria-valuemin': 0,\r\n            'aria-valuenow': 0,\r\n            'aria-valuetext': 0,\r\n            // Live Region Attributes\r\n            'aria-atomic': 0,\r\n            'aria-busy': 0,\r\n            'aria-live': 0,\r\n            'aria-relevant': 0,\r\n            // Drag-and-Drop Attributes\r\n            'aria-dropeffect': 0,\r\n            'aria-grabbed': 0,\r\n            // Relationship Attributes\r\n            'aria-activedescendant': 0,\r\n            'aria-colcount': 0,\r\n            'aria-colindex': 0,\r\n            'aria-colspan': 0,\r\n            'aria-controls': 0,\r\n            'aria-describedby': 0,\r\n            'aria-errormessage': 0,\r\n            'aria-flowto': 0,\r\n            'aria-labelledby': 0,\r\n            'aria-owns': 0,\r\n            'aria-posinset': 0,\r\n            'aria-rowcount': 0,\r\n            'aria-rowindex': 0,\r\n            'aria-rowspan': 0,\r\n            'aria-setsize': 0\r\n        };\r\n        var warnedProperties = {};\r\n        var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\r\n        var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\r\n        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\r\n        function validateProperty(tagName, name) {\r\n            {\r\n                if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {\r\n                    return true;\r\n                }\r\n                if (rARIACamel.test(name)) {\r\n                    var ariaName = 'aria-' + name.slice(4).toLowerCase();\r\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\r\n                    // DOM properties, then it is an invalid aria-* attribute.\r\n                    if (correctName == null) {\r\n                        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);\r\n                        warnedProperties[name] = true;\r\n                        return true;\r\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\r\n                    if (name !== correctName) {\r\n                        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);\r\n                        warnedProperties[name] = true;\r\n                        return true;\r\n                    }\r\n                }\r\n                if (rARIA.test(name)) {\r\n                    var lowerCasedName = name.toLowerCase();\r\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\r\n                    // DOM properties, then it is an invalid aria-* attribute.\r\n                    if (standardName == null) {\r\n                        warnedProperties[name] = true;\r\n                        return false;\r\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\r\n                    if (name !== standardName) {\r\n                        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);\r\n                        warnedProperties[name] = true;\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        function warnInvalidARIAProps(type, props) {\r\n            {\r\n                var invalidProps = [];\r\n                for (var key in props) {\r\n                    var isValid = validateProperty(type, key);\r\n                    if (!isValid) {\r\n                        invalidProps.push(key);\r\n                    }\r\n                }\r\n                var unknownPropString = invalidProps.map(function (prop) {\r\n                    return '`' + prop + '`';\r\n                }).join(', ');\r\n                if (invalidProps.length === 1) {\r\n                    error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);\r\n                }\r\n                else if (invalidProps.length > 1) {\r\n                    error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);\r\n                }\r\n            }\r\n        }\r\n        function validateProperties(type, props) {\r\n            if (isCustomComponent(type, props)) {\r\n                return;\r\n            }\r\n            warnInvalidARIAProps(type, props);\r\n        }\r\n        var didWarnValueNull = false;\r\n        function validateProperties$1(type, props) {\r\n            {\r\n                if (type !== 'input' && type !== 'textarea' && type !== 'select') {\r\n                    return;\r\n                }\r\n                if (props != null && props.value === null && !didWarnValueNull) {\r\n                    didWarnValueNull = true;\r\n                    if (type === 'select' && props.multiple) {\r\n                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);\r\n                    }\r\n                    else {\r\n                        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var validateProperty$1 = function () { };\r\n        {\r\n            var warnedProperties$1 = {};\r\n            var _hasOwnProperty = Object.prototype.hasOwnProperty;\r\n            var EVENT_NAME_REGEX = /^on./;\r\n            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\r\n            var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\r\n            var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\r\n            validateProperty$1 = function (tagName, name, value, eventRegistry) {\r\n                if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\r\n                    return true;\r\n                }\r\n                var lowerCasedName = name.toLowerCase();\r\n                if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\r\n                    error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                } // We can't rely on the event system being injected on the server.\r\n                if (eventRegistry != null) {\r\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\r\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\r\n                        return true;\r\n                    }\r\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\r\n                    if (registrationName != null) {\r\n                        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);\r\n                        warnedProperties$1[name] = true;\r\n                        return true;\r\n                    }\r\n                    if (EVENT_NAME_REGEX.test(name)) {\r\n                        error('Unknown event handler property `%s`. It will be ignored.', name);\r\n                        warnedProperties$1[name] = true;\r\n                        return true;\r\n                    }\r\n                }\r\n                else if (EVENT_NAME_REGEX.test(name)) {\r\n                    // If no event plugins have been injected, we are in a server environment.\r\n                    // So we can't tell if the event name is correct for sure, but we can filter\r\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\r\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\r\n                        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);\r\n                    }\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                } // Let the ARIA attribute hook validate ARIA attributes\r\n                if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\r\n                    return true;\r\n                }\r\n                if (lowerCasedName === 'innerhtml') {\r\n                    error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                if (lowerCasedName === 'aria') {\r\n                    error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\r\n                    error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                if (typeof value === 'number' && isNaN(value)) {\r\n                    error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                var propertyInfo = getPropertyInfo(name);\r\n                var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.\r\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\r\n                    var standardName = possibleStandardNames[lowerCasedName];\r\n                    if (standardName !== name) {\r\n                        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);\r\n                        warnedProperties$1[name] = true;\r\n                        return true;\r\n                    }\r\n                }\r\n                else if (!isReserved && name !== lowerCasedName) {\r\n                    // Unknown attributes should have lowercase casing since that's how they\r\n                    // will be cased anyway with server rendering.\r\n                    error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\r\n                    if (value) {\r\n                        error('Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\r\n                    }\r\n                    else {\r\n                        error('Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\r\n                    }\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                } // Now that we've validated casing, do not validate\r\n                // data types for reserved props\r\n                if (isReserved) {\r\n                    return true;\r\n                } // Warn when a known attribute is a bad type\r\n                if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\r\n                    warnedProperties$1[name] = true;\r\n                    return false;\r\n                } // Warn when passing the strings 'false' or 'true' into a boolean prop\r\n                if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\r\n                    error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\r\n                    warnedProperties$1[name] = true;\r\n                    return true;\r\n                }\r\n                return true;\r\n            };\r\n        }\r\n        var warnUnknownProperties = function (type, props, eventRegistry) {\r\n            {\r\n                var unknownProps = [];\r\n                for (var key in props) {\r\n                    var isValid = validateProperty$1(type, key, props[key], eventRegistry);\r\n                    if (!isValid) {\r\n                        unknownProps.push(key);\r\n                    }\r\n                }\r\n                var unknownPropString = unknownProps.map(function (prop) {\r\n                    return '`' + prop + '`';\r\n                }).join(', ');\r\n                if (unknownProps.length === 1) {\r\n                    error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);\r\n                }\r\n                else if (unknownProps.length > 1) {\r\n                    error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);\r\n                }\r\n            }\r\n        };\r\n        function validateProperties$2(type, props, eventRegistry) {\r\n            if (isCustomComponent(type, props)) {\r\n                return;\r\n            }\r\n            warnUnknownProperties(type, props, eventRegistry);\r\n        }\r\n        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;\r\n        var IS_NON_DELEGATED = 1 << 1;\r\n        var IS_CAPTURE_PHASE = 1 << 2;\r\n        var IS_REPLAYED = 1 << 4;\r\n        // set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\r\n        // we call willDeferLaterForLegacyFBSupport, thus not bailing out\r\n        // will result in endless cycles like an infinite loop.\r\n        // We also don't want to defer during event replaying.\r\n        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;\r\n        /**\r\n         * Gets the target node from a native browser event by accounting for\r\n         * inconsistencies in browser DOM APIs.\r\n         *\r\n         * @param {object} nativeEvent Native browser event.\r\n         * @return {DOMEventTarget} Target node.\r\n         */\r\n        function getEventTarget(nativeEvent) {\r\n            // Fallback to nativeEvent.srcElement for IE9\r\n            // https://github.com/facebook/react/issues/12506\r\n            var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963\r\n            if (target.correspondingUseElement) {\r\n                target = target.correspondingUseElement;\r\n            } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\r\n            // @see http://www.quirksmode.org/js/events_properties.html\r\n            return target.nodeType === TEXT_NODE ? target.parentNode : target;\r\n        }\r\n        var restoreImpl = null;\r\n        var restoreTarget = null;\r\n        var restoreQueue = null;\r\n        function restoreStateOfTarget(target) {\r\n            // We perform this translation at the end of the event loop so that we\r\n            // always receive the correct fiber here\r\n            var internalInstance = getInstanceFromNode(target);\r\n            if (!internalInstance) {\r\n                // Unmounted\r\n                return;\r\n            }\r\n            if (!(typeof restoreImpl === 'function')) {\r\n                {\r\n                    throw Error(\"setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.\r\n            if (stateNode) {\r\n                var _props = getFiberCurrentPropsFromNode(stateNode);\r\n                restoreImpl(internalInstance.stateNode, internalInstance.type, _props);\r\n            }\r\n        }\r\n        function setRestoreImplementation(impl) {\r\n            restoreImpl = impl;\r\n        }\r\n        function enqueueStateRestore(target) {\r\n            if (restoreTarget) {\r\n                if (restoreQueue) {\r\n                    restoreQueue.push(target);\r\n                }\r\n                else {\r\n                    restoreQueue = [target];\r\n                }\r\n            }\r\n            else {\r\n                restoreTarget = target;\r\n            }\r\n        }\r\n        function needsStateRestore() {\r\n            return restoreTarget !== null || restoreQueue !== null;\r\n        }\r\n        function restoreStateIfNeeded() {\r\n            if (!restoreTarget) {\r\n                return;\r\n            }\r\n            var target = restoreTarget;\r\n            var queuedTargets = restoreQueue;\r\n            restoreTarget = null;\r\n            restoreQueue = null;\r\n            restoreStateOfTarget(target);\r\n            if (queuedTargets) {\r\n                for (var i = 0; i < queuedTargets.length; i++) {\r\n                    restoreStateOfTarget(queuedTargets[i]);\r\n                }\r\n            }\r\n        }\r\n        // the renderer. Such as when we're dispatching events or if third party\r\n        // libraries need to call batchedUpdates. Eventually, this API will go away when\r\n        // everything is batched by default. We'll then have a similar API to opt-out of\r\n        // scheduled work and instead do synchronous work.\r\n        // Defaults\r\n        var batchedUpdatesImpl = function (fn, bookkeeping) {\r\n            return fn(bookkeeping);\r\n        };\r\n        var discreteUpdatesImpl = function (fn, a, b, c, d) {\r\n            return fn(a, b, c, d);\r\n        };\r\n        var flushDiscreteUpdatesImpl = function () { };\r\n        var batchedEventUpdatesImpl = batchedUpdatesImpl;\r\n        var isInsideEventHandler = false;\r\n        var isBatchingEventUpdates = false;\r\n        function finishEventHandler() {\r\n            // Here we wait until all updates have propagated, which is important\r\n            // when using controlled components within layers:\r\n            // https://github.com/facebook/react/issues/1698\r\n            // Then we restore state of any controlled component.\r\n            var controlledComponentsHavePendingUpdates = needsStateRestore();\r\n            if (controlledComponentsHavePendingUpdates) {\r\n                // If a controlled event was fired, we may need to restore the state of\r\n                // the DOM node back to the controlled value. This is necessary when React\r\n                // bails out of the update without touching the DOM.\r\n                flushDiscreteUpdatesImpl();\r\n                restoreStateIfNeeded();\r\n            }\r\n        }\r\n        function batchedUpdates(fn, bookkeeping) {\r\n            if (isInsideEventHandler) {\r\n                // If we are currently inside another batch, we need to wait until it\r\n                // fully completes before restoring state.\r\n                return fn(bookkeeping);\r\n            }\r\n            isInsideEventHandler = true;\r\n            try {\r\n                return batchedUpdatesImpl(fn, bookkeeping);\r\n            }\r\n            finally {\r\n                isInsideEventHandler = false;\r\n                finishEventHandler();\r\n            }\r\n        }\r\n        function batchedEventUpdates(fn, a, b) {\r\n            if (isBatchingEventUpdates) {\r\n                // If we are currently inside another batch, we need to wait until it\r\n                // fully completes before restoring state.\r\n                return fn(a, b);\r\n            }\r\n            isBatchingEventUpdates = true;\r\n            try {\r\n                return batchedEventUpdatesImpl(fn, a, b);\r\n            }\r\n            finally {\r\n                isBatchingEventUpdates = false;\r\n                finishEventHandler();\r\n            }\r\n        }\r\n        function discreteUpdates(fn, a, b, c, d) {\r\n            var prevIsInsideEventHandler = isInsideEventHandler;\r\n            isInsideEventHandler = true;\r\n            try {\r\n                return discreteUpdatesImpl(fn, a, b, c, d);\r\n            }\r\n            finally {\r\n                isInsideEventHandler = prevIsInsideEventHandler;\r\n                if (!isInsideEventHandler) {\r\n                    finishEventHandler();\r\n                }\r\n            }\r\n        }\r\n        function flushDiscreteUpdatesIfNeeded(timeStamp) {\r\n            {\r\n                if (!isInsideEventHandler) {\r\n                    flushDiscreteUpdatesImpl();\r\n                }\r\n            }\r\n        }\r\n        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {\r\n            batchedUpdatesImpl = _batchedUpdatesImpl;\r\n            discreteUpdatesImpl = _discreteUpdatesImpl;\r\n            flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;\r\n            batchedEventUpdatesImpl = _batchedEventUpdatesImpl;\r\n        }\r\n        function isInteractive(tag) {\r\n            return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\r\n        }\r\n        function shouldPreventMouseEvent(name, type, props) {\r\n            switch (name) {\r\n                case 'onClick':\r\n                case 'onClickCapture':\r\n                case 'onDoubleClick':\r\n                case 'onDoubleClickCapture':\r\n                case 'onMouseDown':\r\n                case 'onMouseDownCapture':\r\n                case 'onMouseMove':\r\n                case 'onMouseMoveCapture':\r\n                case 'onMouseUp':\r\n                case 'onMouseUpCapture':\r\n                case 'onMouseEnter':\r\n                    return !!(props.disabled && isInteractive(type));\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n        /**\r\n         * @param {object} inst The instance, which is the source of events.\r\n         * @param {string} registrationName Name of listener (e.g. `onClick`).\r\n         * @return {?function} The stored callback.\r\n         */\r\n        function getListener(inst, registrationName) {\r\n            var stateNode = inst.stateNode;\r\n            if (stateNode === null) {\r\n                // Work in progress (ex: onload events in incremental mode).\r\n                return null;\r\n            }\r\n            var props = getFiberCurrentPropsFromNode(stateNode);\r\n            if (props === null) {\r\n                // Work in progress.\r\n                return null;\r\n            }\r\n            var listener = props[registrationName];\r\n            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\r\n                return null;\r\n            }\r\n            if (!(!listener || typeof listener === 'function')) {\r\n                {\r\n                    throw Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\r\n                }\r\n            }\r\n            return listener;\r\n        }\r\n        var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\r\n        if (canUseDOM) {\r\n            try {\r\n                var options = {}; // $FlowFixMe: Ignore Flow complaining about needing a value\r\n                Object.defineProperty(options, 'passive', {\r\n                    get: function () {\r\n                        passiveBrowserEventsSupported = true;\r\n                    }\r\n                });\r\n                window.addEventListener('test', options, options);\r\n                window.removeEventListener('test', options, options);\r\n            }\r\n            catch (e) {\r\n                passiveBrowserEventsSupported = false;\r\n            }\r\n        }\r\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\r\n            var funcArgs = Array.prototype.slice.call(arguments, 3);\r\n            try {\r\n                func.apply(context, funcArgs);\r\n            }\r\n            catch (error) {\r\n                this.onError(error);\r\n            }\r\n        }\r\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\r\n        {\r\n            // In DEV mode, we swap out invokeGuardedCallback for a special version\r\n            // that plays more nicely with the browser's DevTools. The idea is to preserve\r\n            // \"Pause on exceptions\" behavior. Because React wraps all user-provided\r\n            // functions in invokeGuardedCallback, and the production version of\r\n            // invokeGuardedCallback uses a try-catch, all user exceptions are treated\r\n            // like caught exceptions, and the DevTools won't pause unless the developer\r\n            // takes the extra step of enabling pause on caught exceptions. This is\r\n            // unintuitive, though, because even though React has caught the error, from\r\n            // the developer's perspective, the error is uncaught.\r\n            //\r\n            // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\r\n            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\r\n            // DOM node, and call the user-provided callback from inside an event handler\r\n            // for that fake event. If the callback throws, the error is \"captured\" using\r\n            // a global event handler. But because the error happens in a different\r\n            // event loop context, it does not interrupt the normal program flow.\r\n            // Effectively, this gives us try-catch behavior without actually using\r\n            // try-catch. Neat!\r\n            // Check that the browser supports the APIs we need to implement our special\r\n            // DEV version of invokeGuardedCallback\r\n            if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\r\n                var fakeNode = document.createElement('react');\r\n                invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\r\n                    // If document doesn't exist we know for sure we will crash in this method\r\n                    // when we call document.createEvent(). However this can cause confusing\r\n                    // errors: https://github.com/facebookincubator/create-react-app/issues/3482\r\n                    // So we preemptively throw with a better message instead.\r\n                    if (!(typeof document !== 'undefined')) {\r\n                        {\r\n                            throw Error(\"The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.\");\r\n                        }\r\n                    }\r\n                    var evt = document.createEvent('Event');\r\n                    var didCall = false; // Keeps track of whether the user-provided callback threw an error. We\r\n                    // set this to true at the beginning, then set it to false right after\r\n                    // calling the function. If the function errors, `didError` will never be\r\n                    // set to false. This strategy works even if the browser is flaky and\r\n                    // fails to call our global error handler, because it doesn't rely on\r\n                    // the error event at all.\r\n                    var didError = true; // Keeps track of the value of window.event so that we can reset it\r\n                    // during the callback to let user code access window.event in the\r\n                    // browsers that support it.\r\n                    var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\r\n                    // dispatching: https://github.com/facebook/react/issues/13688\r\n                    var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\r\n                    function restoreAfterDispatch() {\r\n                        // We immediately remove the callback from event listeners so that\r\n                        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\r\n                        // nested call would trigger the fake event handlers of any call higher\r\n                        // in the stack.\r\n                        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\r\n                        // window.event assignment in both IE <= 10 as they throw an error\r\n                        // \"Member not found\" in strict mode, and in Firefox which does not\r\n                        // support window.event.\r\n                        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\r\n                            window.event = windowEvent;\r\n                        }\r\n                    } // Create an event handler for our fake event. We will synchronously\r\n                    // dispatch our fake event using `dispatchEvent`. Inside the handler, we\r\n                    // call the user-provided callback.\r\n                    var funcArgs = Array.prototype.slice.call(arguments, 3);\r\n                    function callCallback() {\r\n                        didCall = true;\r\n                        restoreAfterDispatch();\r\n                        func.apply(context, funcArgs);\r\n                        didError = false;\r\n                    } // Create a global error event handler. We use this to capture the value\r\n                    // that was thrown. It's possible that this error handler will fire more\r\n                    // than once; for example, if non-React code also calls `dispatchEvent`\r\n                    // and a handler for that event throws. We should be resilient to most of\r\n                    // those cases. Even if our error event handler fires more than once, the\r\n                    // last error event is always used. If the callback actually does error,\r\n                    // we know that the last error event is the correct one, because it's not\r\n                    // possible for anything else to have happened in between our callback\r\n                    // erroring and the code that follows the `dispatchEvent` call below. If\r\n                    // the callback doesn't error, but the error event was fired, we know to\r\n                    // ignore it because `didError` will be false, as described above.\r\n                    var error; // Use this to track whether the error event is ever called.\r\n                    var didSetError = false;\r\n                    var isCrossOriginError = false;\r\n                    function handleWindowError(event) {\r\n                        error = event.error;\r\n                        didSetError = true;\r\n                        if (error === null && event.colno === 0 && event.lineno === 0) {\r\n                            isCrossOriginError = true;\r\n                        }\r\n                        if (event.defaultPrevented) {\r\n                            // Some other error handler has prevented default.\r\n                            // Browsers silence the error report if this happens.\r\n                            // We'll remember this to later decide whether to log it or not.\r\n                            if (error != null && typeof error === 'object') {\r\n                                try {\r\n                                    error._suppressLogging = true;\r\n                                }\r\n                                catch (inner) { // Ignore.\r\n                                }\r\n                            }\r\n                        }\r\n                    } // Create a fake event type.\r\n                    var evtType = \"react-\" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\r\n                    window.addEventListener('error', handleWindowError);\r\n                    fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\r\n                    // errors, it will trigger our global error handler.\r\n                    evt.initEvent(evtType, false, false);\r\n                    fakeNode.dispatchEvent(evt);\r\n                    if (windowEventDescriptor) {\r\n                        Object.defineProperty(window, 'event', windowEventDescriptor);\r\n                    }\r\n                    if (didCall && didError) {\r\n                        if (!didSetError) {\r\n                            // The callback errored, but the error event never fired.\r\n                            error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\r\n                        }\r\n                        else if (isCrossOriginError) {\r\n                            error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\r\n                        }\r\n                        this.onError(error);\r\n                    } // Remove our event listeners\r\n                    window.removeEventListener('error', handleWindowError);\r\n                    if (!didCall) {\r\n                        // Something went really wrong, and our event was not dispatched.\r\n                        // https://github.com/facebook/react/issues/16734\r\n                        // https://github.com/facebook/react/issues/16585\r\n                        // Fall back to the production implementation.\r\n                        restoreAfterDispatch();\r\n                        return invokeGuardedCallbackProd.apply(this, arguments);\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\r\n        var hasError = false;\r\n        var caughtError = null; // Used by event system to capture/rethrow the first error.\r\n        var hasRethrowError = false;\r\n        var rethrowError = null;\r\n        var reporter = {\r\n            onError: function (error) {\r\n                hasError = true;\r\n                caughtError = error;\r\n            }\r\n        };\r\n        /**\r\n         * Call a function while guarding against errors that happens within it.\r\n         * Returns an error if it throws, otherwise null.\r\n         *\r\n         * In production, this is implemented using a try-catch. The reason we don't\r\n         * use a try-catch directly is so that we can swap out a different\r\n         * implementation in DEV mode.\r\n         *\r\n         * @param {String} name of the guard to use for logging or debugging\r\n         * @param {Function} func The function to invoke\r\n         * @param {*} context The context to use when calling the function\r\n         * @param {...*} args Arguments for function\r\n         */\r\n        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\r\n            hasError = false;\r\n            caughtError = null;\r\n            invokeGuardedCallbackImpl$1.apply(reporter, arguments);\r\n        }\r\n        /**\r\n         * Same as invokeGuardedCallback, but instead of returning an error, it stores\r\n         * it in a global so it can be rethrown by `rethrowCaughtError` later.\r\n         * TODO: See if caughtError and rethrowError can be unified.\r\n         *\r\n         * @param {String} name of the guard to use for logging or debugging\r\n         * @param {Function} func The function to invoke\r\n         * @param {*} context The context to use when calling the function\r\n         * @param {...*} args Arguments for function\r\n         */\r\n        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\r\n            invokeGuardedCallback.apply(this, arguments);\r\n            if (hasError) {\r\n                var error = clearCaughtError();\r\n                if (!hasRethrowError) {\r\n                    hasRethrowError = true;\r\n                    rethrowError = error;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * During execution of guarded functions we will capture the first error which\r\n         * we will rethrow to be handled by the top level error handler.\r\n         */\r\n        function rethrowCaughtError() {\r\n            if (hasRethrowError) {\r\n                var error = rethrowError;\r\n                hasRethrowError = false;\r\n                rethrowError = null;\r\n                throw error;\r\n            }\r\n        }\r\n        function hasCaughtError() {\r\n            return hasError;\r\n        }\r\n        function clearCaughtError() {\r\n            if (hasError) {\r\n                var error = caughtError;\r\n                hasError = false;\r\n                caughtError = null;\r\n                return error;\r\n            }\r\n            else {\r\n                {\r\n                    {\r\n                        throw Error(\"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * `ReactInstanceMap` maintains a mapping from a public facing stateful\r\n         * instance (key) and the internal representation (value). This allows public\r\n         * methods to accept the user facing instance as an argument and map them back\r\n         * to internal methods.\r\n         *\r\n         * Note that this module is currently shared and assumed to be stateless.\r\n         * If this becomes an actual Map, that will break.\r\n         */\r\n        function get(key) {\r\n            return key._reactInternals;\r\n        }\r\n        function has(key) {\r\n            return key._reactInternals !== undefined;\r\n        }\r\n        function set(key, value) {\r\n            key._reactInternals = value;\r\n        }\r\n        // Don't change these two values. They're used by React Dev Tools.\r\n        var NoFlags = \r\n        /*                      */\r\n        0;\r\n        var PerformedWork = \r\n        /*                */\r\n        1; // You can change the rest (and add more).\r\n        var Placement = \r\n        /*                    */\r\n        2;\r\n        var Update = \r\n        /*                       */\r\n        4;\r\n        var PlacementAndUpdate = \r\n        /*           */\r\n        6;\r\n        var Deletion = \r\n        /*                     */\r\n        8;\r\n        var ContentReset = \r\n        /*                 */\r\n        16;\r\n        var Callback = \r\n        /*                     */\r\n        32;\r\n        var DidCapture = \r\n        /*                   */\r\n        64;\r\n        var Ref = \r\n        /*                          */\r\n        128;\r\n        var Snapshot = \r\n        /*                     */\r\n        256;\r\n        var Passive = \r\n        /*                      */\r\n        512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.\r\n        var PassiveUnmountPendingDev = \r\n        /*     */\r\n        8192;\r\n        var Hydrating = \r\n        /*                    */\r\n        1024;\r\n        var HydratingAndUpdate = \r\n        /*           */\r\n        1028; // Passive & Update & Callback & Ref & Snapshot\r\n        var LifecycleEffectMask = \r\n        /*          */\r\n        932; // Union of all host effects\r\n        var HostEffectMask = \r\n        /*               */\r\n        2047; // These are not really side effects, but we still reuse this field.\r\n        var Incomplete = \r\n        /*                   */\r\n        2048;\r\n        var ShouldCapture = \r\n        /*                */\r\n        4096;\r\n        var ForceUpdateForLegacySuspense = \r\n        /* */\r\n        16384; // Static tags describe aspects of a fiber that are not specific to a render,\r\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\n        function getNearestMountedFiber(fiber) {\r\n            var node = fiber;\r\n            var nearestMounted = fiber;\r\n            if (!fiber.alternate) {\r\n                // If there is no alternate, this might be a new tree that isn't inserted\r\n                // yet. If it is, then it will have a pending insertion effect on it.\r\n                var nextNode = node;\r\n                do {\r\n                    node = nextNode;\r\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\r\n                        // This is an insertion or in-progress hydration. The nearest possible\r\n                        // mounted fiber is the parent but we need to continue to figure out\r\n                        // if that one is still mounted.\r\n                        nearestMounted = node.return;\r\n                    }\r\n                    nextNode = node.return;\r\n                } while (nextNode);\r\n            }\r\n            else {\r\n                while (node.return) {\r\n                    node = node.return;\r\n                }\r\n            }\r\n            if (node.tag === HostRoot) {\r\n                // TODO: Check if this was a nested HostRoot when used with\r\n                // renderContainerIntoSubtree.\r\n                return nearestMounted;\r\n            } // If we didn't hit the root, that means that we're in an disconnected tree\r\n            // that has been unmounted.\r\n            return null;\r\n        }\r\n        function getSuspenseInstanceFromFiber(fiber) {\r\n            if (fiber.tag === SuspenseComponent) {\r\n                var suspenseState = fiber.memoizedState;\r\n                if (suspenseState === null) {\r\n                    var current = fiber.alternate;\r\n                    if (current !== null) {\r\n                        suspenseState = current.memoizedState;\r\n                    }\r\n                }\r\n                if (suspenseState !== null) {\r\n                    return suspenseState.dehydrated;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        function getContainerFromFiber(fiber) {\r\n            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\r\n        }\r\n        function isFiberMounted(fiber) {\r\n            return getNearestMountedFiber(fiber) === fiber;\r\n        }\r\n        function isMounted(component) {\r\n            {\r\n                var owner = ReactCurrentOwner.current;\r\n                if (owner !== null && owner.tag === ClassComponent) {\r\n                    var ownerFiber = owner;\r\n                    var instance = ownerFiber.stateNode;\r\n                    if (!instance._warnedAboutRefsInRender) {\r\n                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');\r\n                    }\r\n                    instance._warnedAboutRefsInRender = true;\r\n                }\r\n            }\r\n            var fiber = get(component);\r\n            if (!fiber) {\r\n                return false;\r\n            }\r\n            return getNearestMountedFiber(fiber) === fiber;\r\n        }\r\n        function assertIsMounted(fiber) {\r\n            if (!(getNearestMountedFiber(fiber) === fiber)) {\r\n                {\r\n                    throw Error(\"Unable to find node on an unmounted component.\");\r\n                }\r\n            }\r\n        }\r\n        function findCurrentFiberUsingSlowPath(fiber) {\r\n            var alternate = fiber.alternate;\r\n            if (!alternate) {\r\n                // If there is no alternate, then we only need to check if it is mounted.\r\n                var nearestMounted = getNearestMountedFiber(fiber);\r\n                if (!(nearestMounted !== null)) {\r\n                    {\r\n                        throw Error(\"Unable to find node on an unmounted component.\");\r\n                    }\r\n                }\r\n                if (nearestMounted !== fiber) {\r\n                    return null;\r\n                }\r\n                return fiber;\r\n            } // If we have two possible branches, we'll walk backwards up to the root\r\n            // to see what path the root points to. On the way we may hit one of the\r\n            // special cases and we'll deal with them.\r\n            var a = fiber;\r\n            var b = alternate;\r\n            while (true) {\r\n                var parentA = a.return;\r\n                if (parentA === null) {\r\n                    // We're at the root.\r\n                    break;\r\n                }\r\n                var parentB = parentA.alternate;\r\n                if (parentB === null) {\r\n                    // There is no alternate. This is an unusual case. Currently, it only\r\n                    // happens when a Suspense component is hidden. An extra fragment fiber\r\n                    // is inserted in between the Suspense fiber and its children. Skip\r\n                    // over this extra fragment fiber and proceed to the next parent.\r\n                    var nextParent = parentA.return;\r\n                    if (nextParent !== null) {\r\n                        a = b = nextParent;\r\n                        continue;\r\n                    } // If there's no parent, we're at the root.\r\n                    break;\r\n                } // If both copies of the parent fiber point to the same child, we can\r\n                // assume that the child is current. This happens when we bailout on low\r\n                // priority: the bailed out fiber's child reuses the current child.\r\n                if (parentA.child === parentB.child) {\r\n                    var child = parentA.child;\r\n                    while (child) {\r\n                        if (child === a) {\r\n                            // We've determined that A is the current branch.\r\n                            assertIsMounted(parentA);\r\n                            return fiber;\r\n                        }\r\n                        if (child === b) {\r\n                            // We've determined that B is the current branch.\r\n                            assertIsMounted(parentA);\r\n                            return alternate;\r\n                        }\r\n                        child = child.sibling;\r\n                    } // We should never have an alternate for any mounting node. So the only\r\n                    // way this could possibly happen is if this was unmounted, if at all.\r\n                    {\r\n                        {\r\n                            throw Error(\"Unable to find node on an unmounted component.\");\r\n                        }\r\n                    }\r\n                }\r\n                if (a.return !== b.return) {\r\n                    // The return pointer of A and the return pointer of B point to different\r\n                    // fibers. We assume that return pointers never criss-cross, so A must\r\n                    // belong to the child set of A.return, and B must belong to the child\r\n                    // set of B.return.\r\n                    a = parentA;\r\n                    b = parentB;\r\n                }\r\n                else {\r\n                    // The return pointers point to the same fiber. We'll have to use the\r\n                    // default, slow path: scan the child sets of each parent alternate to see\r\n                    // which child belongs to which set.\r\n                    //\r\n                    // Search parent A's child set\r\n                    var didFindChild = false;\r\n                    var _child = parentA.child;\r\n                    while (_child) {\r\n                        if (_child === a) {\r\n                            didFindChild = true;\r\n                            a = parentA;\r\n                            b = parentB;\r\n                            break;\r\n                        }\r\n                        if (_child === b) {\r\n                            didFindChild = true;\r\n                            b = parentA;\r\n                            a = parentB;\r\n                            break;\r\n                        }\r\n                        _child = _child.sibling;\r\n                    }\r\n                    if (!didFindChild) {\r\n                        // Search parent B's child set\r\n                        _child = parentB.child;\r\n                        while (_child) {\r\n                            if (_child === a) {\r\n                                didFindChild = true;\r\n                                a = parentB;\r\n                                b = parentA;\r\n                                break;\r\n                            }\r\n                            if (_child === b) {\r\n                                didFindChild = true;\r\n                                b = parentB;\r\n                                a = parentA;\r\n                                break;\r\n                            }\r\n                            _child = _child.sibling;\r\n                        }\r\n                        if (!didFindChild) {\r\n                            {\r\n                                throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!(a.alternate === b)) {\r\n                    {\r\n                        throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\r\n            // unmounted.\r\n            if (!(a.tag === HostRoot)) {\r\n                {\r\n                    throw Error(\"Unable to find node on an unmounted component.\");\r\n                }\r\n            }\r\n            if (a.stateNode.current === a) {\r\n                // We've determined that A is the current branch.\r\n                return fiber;\r\n            } // Otherwise B has to be current branch.\r\n            return alternate;\r\n        }\r\n        function findCurrentHostFiber(parent) {\r\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\r\n            if (!currentParent) {\r\n                return null;\r\n            } // Next we'll drill down this component to find the first HostComponent/Text.\r\n            var node = currentParent;\r\n            while (true) {\r\n                if (node.tag === HostComponent || node.tag === HostText) {\r\n                    return node;\r\n                }\r\n                else if (node.child) {\r\n                    node.child.return = node;\r\n                    node = node.child;\r\n                    continue;\r\n                }\r\n                if (node === currentParent) {\r\n                    return null;\r\n                }\r\n                while (!node.sibling) {\r\n                    if (!node.return || node.return === currentParent) {\r\n                        return null;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            } // Flow needs the return null here, but ESLint complains about it.\r\n            // eslint-disable-next-line no-unreachable\r\n            return null;\r\n        }\r\n        function findCurrentHostFiberWithNoPortals(parent) {\r\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\r\n            if (!currentParent) {\r\n                return null;\r\n            } // Next we'll drill down this component to find the first HostComponent/Text.\r\n            var node = currentParent;\r\n            while (true) {\r\n                if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {\r\n                    return node;\r\n                }\r\n                else if (node.child && node.tag !== HostPortal) {\r\n                    node.child.return = node;\r\n                    node = node.child;\r\n                    continue;\r\n                }\r\n                if (node === currentParent) {\r\n                    return null;\r\n                }\r\n                while (!node.sibling) {\r\n                    if (!node.return || node.return === currentParent) {\r\n                        return null;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            } // Flow needs the return null here, but ESLint complains about it.\r\n            // eslint-disable-next-line no-unreachable\r\n            return null;\r\n        }\r\n        function doesFiberContain(parentFiber, childFiber) {\r\n            var node = childFiber;\r\n            var parentFiberAlternate = parentFiber.alternate;\r\n            while (node !== null) {\r\n                if (node === parentFiber || node === parentFiberAlternate) {\r\n                    return true;\r\n                }\r\n                node = node.return;\r\n            }\r\n            return false;\r\n        }\r\n        var attemptUserBlockingHydration;\r\n        function setAttemptUserBlockingHydration(fn) {\r\n            attemptUserBlockingHydration = fn;\r\n        }\r\n        var attemptContinuousHydration;\r\n        function setAttemptContinuousHydration(fn) {\r\n            attemptContinuousHydration = fn;\r\n        }\r\n        var attemptHydrationAtCurrentPriority;\r\n        function setAttemptHydrationAtCurrentPriority(fn) {\r\n            attemptHydrationAtCurrentPriority = fn;\r\n        }\r\n        var attemptHydrationAtPriority;\r\n        function setAttemptHydrationAtPriority(fn) {\r\n            attemptHydrationAtPriority = fn;\r\n        } // TODO: Upgrade this definition once we're on a newer version of Flow that\r\n        var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\r\n        var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\r\n        // if the last target was dehydrated.\r\n        var queuedFocus = null;\r\n        var queuedDrag = null;\r\n        var queuedMouse = null; // For pointer events there can be one latest event per pointerId.\r\n        var queuedPointers = new Map();\r\n        var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\r\n        var queuedExplicitHydrationTargets = [];\r\n        function hasQueuedDiscreteEvents() {\r\n            return queuedDiscreteEvents.length > 0;\r\n        }\r\n        var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput',\r\n            'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];\r\n        function isReplayableDiscreteEvent(eventType) {\r\n            return discreteReplayableEvents.indexOf(eventType) > -1;\r\n        }\r\n        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            return {\r\n                blockedOn: blockedOn,\r\n                domEventName: domEventName,\r\n                eventSystemFlags: eventSystemFlags | IS_REPLAYED,\r\n                nativeEvent: nativeEvent,\r\n                targetContainers: [targetContainer]\r\n            };\r\n        }\r\n        function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n            queuedDiscreteEvents.push(queuedEvent);\r\n        } // Resets the replaying for this type of continuous event to no event.\r\n        function clearIfContinuousEvent(domEventName, nativeEvent) {\r\n            switch (domEventName) {\r\n                case 'focusin':\r\n                case 'focusout':\r\n                    queuedFocus = null;\r\n                    break;\r\n                case 'dragenter':\r\n                case 'dragleave':\r\n                    queuedDrag = null;\r\n                    break;\r\n                case 'mouseover':\r\n                case 'mouseout':\r\n                    queuedMouse = null;\r\n                    break;\r\n                case 'pointerover':\r\n                case 'pointerout':\r\n                    {\r\n                        var pointerId = nativeEvent.pointerId;\r\n                        queuedPointers.delete(pointerId);\r\n                        break;\r\n                    }\r\n                case 'gotpointercapture':\r\n                case 'lostpointercapture':\r\n                    {\r\n                        var _pointerId = nativeEvent.pointerId;\r\n                        queuedPointerCaptures.delete(_pointerId);\r\n                        break;\r\n                    }\r\n            }\r\n        }\r\n        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\r\n                var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                if (blockedOn !== null) {\r\n                    var _fiber2 = getInstanceFromNode(blockedOn);\r\n                    if (_fiber2 !== null) {\r\n                        // Attempt to increase the priority of this target.\r\n                        attemptContinuousHydration(_fiber2);\r\n                    }\r\n                }\r\n                return queuedEvent;\r\n            } // If we have already queued this exact event, then it's because\r\n            // the different event systems have different DOM event listeners.\r\n            // We can accumulate the flags, and the targetContainers, and\r\n            // store a single event to be replayed.\r\n            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\r\n            var targetContainers = existingQueuedEvent.targetContainers;\r\n            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\r\n                targetContainers.push(targetContainer);\r\n            }\r\n            return existingQueuedEvent;\r\n        }\r\n        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            // These set relatedTarget to null because the replayed event will be treated as if we\r\n            // moved from outside the window (no target) onto the target once it hydrates.\r\n            // Instead of mutating we could clone the event.\r\n            switch (domEventName) {\r\n                case 'focusin':\r\n                    {\r\n                        var focusEvent = nativeEvent;\r\n                        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\r\n                        return true;\r\n                    }\r\n                case 'dragenter':\r\n                    {\r\n                        var dragEvent = nativeEvent;\r\n                        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\r\n                        return true;\r\n                    }\r\n                case 'mouseover':\r\n                    {\r\n                        var mouseEvent = nativeEvent;\r\n                        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\r\n                        return true;\r\n                    }\r\n                case 'pointerover':\r\n                    {\r\n                        var pointerEvent = nativeEvent;\r\n                        var pointerId = pointerEvent.pointerId;\r\n                        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\r\n                        return true;\r\n                    }\r\n                case 'gotpointercapture':\r\n                    {\r\n                        var _pointerEvent = nativeEvent;\r\n                        var _pointerId2 = _pointerEvent.pointerId;\r\n                        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));\r\n                        return true;\r\n                    }\r\n            }\r\n            return false;\r\n        } // Check if this target is unblocked. Returns true if it's unblocked.\r\n        function attemptExplicitHydrationTarget(queuedTarget) {\r\n            // TODO: This function shares a lot of logic with attemptToDispatchEvent.\r\n            // Try to unify them. It's a bit tricky since it would require two return\r\n            // values.\r\n            var targetInst = getClosestInstanceFromNode(queuedTarget.target);\r\n            if (targetInst !== null) {\r\n                var nearestMounted = getNearestMountedFiber(targetInst);\r\n                if (nearestMounted !== null) {\r\n                    var tag = nearestMounted.tag;\r\n                    if (tag === SuspenseComponent) {\r\n                        var instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n                        if (instance !== null) {\r\n                            // We're blocked on hydrating this boundary.\r\n                            // Increase its priority.\r\n                            queuedTarget.blockedOn = instance;\r\n                            attemptHydrationAtPriority(queuedTarget.lanePriority, function () {\r\n                                Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {\r\n                                    attemptHydrationAtCurrentPriority(nearestMounted);\r\n                                });\r\n                            });\r\n                            return;\r\n                        }\r\n                    }\r\n                    else if (tag === HostRoot) {\r\n                        var root = nearestMounted.stateNode;\r\n                        if (root.hydrate) {\r\n                            queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\r\n                            // a root other than sync.\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            queuedTarget.blockedOn = null;\r\n        }\r\n        function attemptReplayContinuousQueuedEvent(queuedEvent) {\r\n            if (queuedEvent.blockedOn !== null) {\r\n                return false;\r\n            }\r\n            var targetContainers = queuedEvent.targetContainers;\r\n            while (targetContainers.length > 0) {\r\n                var targetContainer = targetContainers[0];\r\n                var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\r\n                if (nextBlockedOn !== null) {\r\n                    // We're still blocked. Try again later.\r\n                    var _fiber3 = getInstanceFromNode(nextBlockedOn);\r\n                    if (_fiber3 !== null) {\r\n                        attemptContinuousHydration(_fiber3);\r\n                    }\r\n                    queuedEvent.blockedOn = nextBlockedOn;\r\n                    return false;\r\n                } // This target container was successfully dispatched. Try the next.\r\n                targetContainers.shift();\r\n            }\r\n            return true;\r\n        }\r\n        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\r\n            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\r\n                map.delete(key);\r\n            }\r\n        }\r\n        function replayUnblockedEvents() {\r\n            hasScheduledReplayAttempt = false; // First replay discrete events.\r\n            while (queuedDiscreteEvents.length > 0) {\r\n                var nextDiscreteEvent = queuedDiscreteEvents[0];\r\n                if (nextDiscreteEvent.blockedOn !== null) {\r\n                    // We're still blocked.\r\n                    // Increase the priority of this boundary to unblock\r\n                    // the next discrete event.\r\n                    var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);\r\n                    if (_fiber4 !== null) {\r\n                        attemptUserBlockingHydration(_fiber4);\r\n                    }\r\n                    break;\r\n                }\r\n                var targetContainers = nextDiscreteEvent.targetContainers;\r\n                while (targetContainers.length > 0) {\r\n                    var targetContainer = targetContainers[0];\r\n                    var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);\r\n                    if (nextBlockedOn !== null) {\r\n                        // We're still blocked. Try again later.\r\n                        nextDiscreteEvent.blockedOn = nextBlockedOn;\r\n                        break;\r\n                    } // This target container was successfully dispatched. Try the next.\r\n                    targetContainers.shift();\r\n                }\r\n                if (nextDiscreteEvent.blockedOn === null) {\r\n                    // We've successfully replayed the first event. Let's try the next one.\r\n                    queuedDiscreteEvents.shift();\r\n                }\r\n            } // Next replay any continuous events.\r\n            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\r\n                queuedFocus = null;\r\n            }\r\n            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\r\n                queuedDrag = null;\r\n            }\r\n            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\r\n                queuedMouse = null;\r\n            }\r\n            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\r\n            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\r\n        }\r\n        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\r\n            if (queuedEvent.blockedOn === unblocked) {\r\n                queuedEvent.blockedOn = null;\r\n                if (!hasScheduledReplayAttempt) {\r\n                    hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\r\n                    // now unblocked. This first might not actually be unblocked yet.\r\n                    // We could check it early to avoid scheduling an unnecessary callback.\r\n                    Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);\r\n                }\r\n            }\r\n        }\r\n        function retryIfBlockedOn(unblocked) {\r\n            // Mark anything that was blocked on this as no longer blocked\r\n            // and eligible for a replay.\r\n            if (queuedDiscreteEvents.length > 0) {\r\n                scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\r\n                // worth it because we expect very few discrete events to queue up and once\r\n                // we are actually fully unblocked it will be fast to replay them.\r\n                for (var i = 1; i < queuedDiscreteEvents.length; i++) {\r\n                    var queuedEvent = queuedDiscreteEvents[i];\r\n                    if (queuedEvent.blockedOn === unblocked) {\r\n                        queuedEvent.blockedOn = null;\r\n                    }\r\n                }\r\n            }\r\n            if (queuedFocus !== null) {\r\n                scheduleCallbackIfUnblocked(queuedFocus, unblocked);\r\n            }\r\n            if (queuedDrag !== null) {\r\n                scheduleCallbackIfUnblocked(queuedDrag, unblocked);\r\n            }\r\n            if (queuedMouse !== null) {\r\n                scheduleCallbackIfUnblocked(queuedMouse, unblocked);\r\n            }\r\n            var unblock = function (queuedEvent) {\r\n                return scheduleCallbackIfUnblocked(queuedEvent, unblocked);\r\n            };\r\n            queuedPointers.forEach(unblock);\r\n            queuedPointerCaptures.forEach(unblock);\r\n            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {\r\n                var queuedTarget = queuedExplicitHydrationTargets[_i];\r\n                if (queuedTarget.blockedOn === unblocked) {\r\n                    queuedTarget.blockedOn = null;\r\n                }\r\n            }\r\n            while (queuedExplicitHydrationTargets.length > 0) {\r\n                var nextExplicitTarget = queuedExplicitHydrationTargets[0];\r\n                if (nextExplicitTarget.blockedOn !== null) {\r\n                    // We're still blocked.\r\n                    break;\r\n                }\r\n                else {\r\n                    attemptExplicitHydrationTarget(nextExplicitTarget);\r\n                    if (nextExplicitTarget.blockedOn === null) {\r\n                        // We're unblocked.\r\n                        queuedExplicitHydrationTargets.shift();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var DiscreteEvent = 0;\r\n        var UserBlockingEvent = 1;\r\n        var ContinuousEvent = 2;\r\n        /**\r\n         * Generate a mapping of standard vendor prefixes using the defined style property and event name.\r\n         *\r\n         * @param {string} styleProp\r\n         * @param {string} eventName\r\n         * @returns {object}\r\n         */\r\n        function makePrefixMap(styleProp, eventName) {\r\n            var prefixes = {};\r\n            prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\r\n            prefixes['Webkit' + styleProp] = 'webkit' + eventName;\r\n            prefixes['Moz' + styleProp] = 'moz' + eventName;\r\n            return prefixes;\r\n        }\r\n        /**\r\n         * A list of event names to a configurable list of vendor prefixes.\r\n         */\r\n        var vendorPrefixes = {\r\n            animationend: makePrefixMap('Animation', 'AnimationEnd'),\r\n            animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\r\n            animationstart: makePrefixMap('Animation', 'AnimationStart'),\r\n            transitionend: makePrefixMap('Transition', 'TransitionEnd')\r\n        };\r\n        /**\r\n         * Event names that have already been detected and prefixed (if applicable).\r\n         */\r\n        var prefixedEventNames = {};\r\n        /**\r\n         * Element to check for prefixes on.\r\n         */\r\n        var style = {};\r\n        /**\r\n         * Bootstrap if a DOM exists.\r\n         */\r\n        if (canUseDOM) {\r\n            style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,\r\n            // the un-prefixed \"animation\" and \"transition\" properties are defined on the\r\n            // style object but the events that fire will still be prefixed, so we need\r\n            // to check if the un-prefixed events are usable, and if not remove them from the map.\r\n            if (!('AnimationEvent' in window)) {\r\n                delete vendorPrefixes.animationend.animation;\r\n                delete vendorPrefixes.animationiteration.animation;\r\n                delete vendorPrefixes.animationstart.animation;\r\n            } // Same as above\r\n            if (!('TransitionEvent' in window)) {\r\n                delete vendorPrefixes.transitionend.transition;\r\n            }\r\n        }\r\n        /**\r\n         * Attempts to determine the correct vendor prefixed event name.\r\n         *\r\n         * @param {string} eventName\r\n         * @returns {string}\r\n         */\r\n        function getVendorPrefixedEventName(eventName) {\r\n            if (prefixedEventNames[eventName]) {\r\n                return prefixedEventNames[eventName];\r\n            }\r\n            else if (!vendorPrefixes[eventName]) {\r\n                return eventName;\r\n            }\r\n            var prefixMap = vendorPrefixes[eventName];\r\n            for (var styleProp in prefixMap) {\r\n                if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\r\n                    return prefixedEventNames[eventName] = prefixMap[styleProp];\r\n                }\r\n            }\r\n            return eventName;\r\n        }\r\n        var ANIMATION_END = getVendorPrefixedEventName('animationend');\r\n        var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');\r\n        var ANIMATION_START = getVendorPrefixedEventName('animationstart');\r\n        var TRANSITION_END = getVendorPrefixedEventName('transitionend');\r\n        var topLevelEventsToReactNames = new Map();\r\n        var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use\r\n        // the code required to apply the same logic for event prioritization and that of the\r\n        // SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code\r\n        // duplication (for which there would be quite a bit). For the events that are not needed\r\n        // for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an\r\n        // array of top level events.\r\n        // Lastly, we ignore prettier so we can keep the formatting sane.\r\n        // prettier-ignore\r\n        var discreteEventPairsForSimpleEventPlugin = ['cancel', 'cancel', 'click', 'click', 'close', 'close', 'contextmenu', 'contextMenu', 'copy', 'copy', 'cut', 'cut', 'auxclick', 'auxClick', 'dblclick', 'doubleClick',\r\n            'dragend', 'dragEnd', 'dragstart', 'dragStart', 'drop', 'drop', 'focusin', 'focus',\r\n            'focusout', 'blur',\r\n            'input', 'input', 'invalid', 'invalid', 'keydown', 'keyDown', 'keypress', 'keyPress', 'keyup', 'keyUp', 'mousedown', 'mouseDown', 'mouseup', 'mouseUp', 'paste', 'paste', 'pause', 'pause', 'play', 'play', 'pointercancel', 'pointerCancel', 'pointerdown', 'pointerDown', 'pointerup', 'pointerUp', 'ratechange', 'rateChange', 'reset', 'reset', 'seeked', 'seeked', 'submit', 'submit', 'touchcancel', 'touchCancel', 'touchend', 'touchEnd', 'touchstart', 'touchStart', 'volumechange', 'volumeChange'];\r\n        var otherDiscreteEvents = ['change', 'selectionchange', 'textInput', 'compositionstart', 'compositionend', 'compositionupdate'];\r\n        var userBlockingPairsForSimpleEventPlugin = ['drag', 'drag', 'dragenter', 'dragEnter', 'dragexit', 'dragExit', 'dragleave', 'dragLeave', 'dragover', 'dragOver', 'mousemove', 'mouseMove', 'mouseout', 'mouseOut', 'mouseover', 'mouseOver', 'pointermove', 'pointerMove', 'pointerout', 'pointerOut', 'pointerover', 'pointerOver', 'scroll', 'scroll', 'toggle', 'toggle', 'touchmove', 'touchMove', 'wheel', 'wheel']; // prettier-ignore\r\n        var continuousPairsForSimpleEventPlugin = ['abort', 'abort', ANIMATION_END, 'animationEnd', ANIMATION_ITERATION, 'animationIteration', ANIMATION_START, 'animationStart', 'canplay', 'canPlay', 'canplaythrough', 'canPlayThrough', 'durationchange', 'durationChange', 'emptied', 'emptied', 'encrypted', 'encrypted', 'ended', 'ended', 'error', 'error', 'gotpointercapture', 'gotPointerCapture', 'load', 'load', 'loadeddata', 'loadedData', 'loadedmetadata', 'loadedMetadata', 'loadstart', 'loadStart', 'lostpointercapture', 'lostPointerCapture', 'playing', 'playing', 'progress', 'progress', 'seeking', 'seeking', 'stalled', 'stalled', 'suspend', 'suspend', 'timeupdate', 'timeUpdate', TRANSITION_END, 'transitionEnd', 'waiting', 'waiting'];\r\n        /**\r\n         * Turns\r\n         * ['abort', ...]\r\n         *\r\n         * into\r\n         *\r\n         * topLevelEventsToReactNames = new Map([\r\n         *   ['abort', 'onAbort'],\r\n         * ]);\r\n         *\r\n         * and registers them.\r\n         */\r\n        function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {\r\n            // As the event types are in pairs of two, we need to iterate\r\n            // through in twos. The events are in pairs of two to save code\r\n            // and improve init perf of processing this array, as it will\r\n            // result in far fewer object allocations and property accesses\r\n            // if we only use three arrays to process all the categories of\r\n            // instead of tuples.\r\n            for (var i = 0; i < eventTypes.length; i += 2) {\r\n                var topEvent = eventTypes[i];\r\n                var event = eventTypes[i + 1];\r\n                var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\r\n                var reactName = 'on' + capitalizedEvent;\r\n                eventPriorities.set(topEvent, priority);\r\n                topLevelEventsToReactNames.set(topEvent, reactName);\r\n                registerTwoPhaseEvent(reactName, [topEvent]);\r\n            }\r\n        }\r\n        function setEventPriorities(eventTypes, priority) {\r\n            for (var i = 0; i < eventTypes.length; i++) {\r\n                eventPriorities.set(eventTypes[i], priority);\r\n            }\r\n        }\r\n        function getEventPriorityForPluginSystem(domEventName) {\r\n            var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might\r\n            // want to warn if we can't detect the priority\r\n            // for the event.\r\n            return priority === undefined ? ContinuousEvent : priority;\r\n        }\r\n        function registerSimpleEvents() {\r\n            registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);\r\n            registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);\r\n            registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);\r\n            setEventPriorities(otherDiscreteEvents, DiscreteEvent);\r\n        }\r\n        var Scheduler_now = Scheduler.unstable_now;\r\n        {\r\n            // Provide explicit error message when production+profiling bundle of e.g.\r\n            // react-dom is used with production (non-profiling) bundle of\r\n            // scheduler/tracing\r\n            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {\r\n                {\r\n                    throw Error(\"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling\");\r\n                }\r\n            }\r\n        }\r\n        // ascending numbers so we can compare them like numbers. They start at 90 to\r\n        // avoid clashing with Scheduler's priorities.\r\n        var ImmediatePriority = 99;\r\n        var UserBlockingPriority = 98;\r\n        var NormalPriority = 97;\r\n        var LowPriority = 96;\r\n        var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.\r\n        var NoPriority = 90;\r\n        var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.\r\n        var SyncLanePriority = 15;\r\n        var SyncBatchedLanePriority = 14;\r\n        var InputDiscreteHydrationLanePriority = 13;\r\n        var InputDiscreteLanePriority = 12;\r\n        var InputContinuousHydrationLanePriority = 11;\r\n        var InputContinuousLanePriority = 10;\r\n        var DefaultHydrationLanePriority = 9;\r\n        var DefaultLanePriority = 8;\r\n        var TransitionHydrationPriority = 7;\r\n        var TransitionPriority = 6;\r\n        var RetryLanePriority = 5;\r\n        var SelectiveHydrationLanePriority = 4;\r\n        var IdleHydrationLanePriority = 3;\r\n        var IdleLanePriority = 2;\r\n        var OffscreenLanePriority = 1;\r\n        var NoLanePriority = 0;\r\n        var TotalLanes = 31;\r\n        var NoLanes = \r\n        /*                        */\r\n        0;\r\n        var NoLane = \r\n        /*                          */\r\n        0;\r\n        var SyncLane = \r\n        /*                        */\r\n        1;\r\n        var SyncBatchedLane = \r\n        /*                 */\r\n        2;\r\n        var InputDiscreteHydrationLane = \r\n        /*      */\r\n        4;\r\n        var InputDiscreteLanes = \r\n        /*                    */\r\n        24;\r\n        var InputContinuousHydrationLane = \r\n        /*           */\r\n        32;\r\n        var InputContinuousLanes = \r\n        /*                  */\r\n        192;\r\n        var DefaultHydrationLane = \r\n        /*            */\r\n        256;\r\n        var DefaultLanes = \r\n        /*                   */\r\n        3584;\r\n        var TransitionHydrationLane = \r\n        /*                */\r\n        4096;\r\n        var TransitionLanes = \r\n        /*                       */\r\n        4186112;\r\n        var RetryLanes = \r\n        /*                            */\r\n        62914560;\r\n        var SomeRetryLane = \r\n        /*                  */\r\n        33554432;\r\n        var SelectiveHydrationLane = \r\n        /*          */\r\n        67108864;\r\n        var NonIdleLanes = \r\n        /*                                 */\r\n        134217727;\r\n        var IdleHydrationLane = \r\n        /*               */\r\n        134217728;\r\n        var IdleLanes = \r\n        /*                             */\r\n        805306368;\r\n        var OffscreenLane = \r\n        /*                   */\r\n        1073741824;\r\n        var NoTimestamp = -1;\r\n        function setCurrentUpdateLanePriority(newLanePriority) {\r\n        } // \"Registers\" used to \"return\" multiple values\r\n        // Used by getHighestPriorityLanes and getNextLanes:\r\n        var return_highestLanePriority = DefaultLanePriority;\r\n        function getHighestPriorityLanes(lanes) {\r\n            if ((SyncLane & lanes) !== NoLanes) {\r\n                return_highestLanePriority = SyncLanePriority;\r\n                return SyncLane;\r\n            }\r\n            if ((SyncBatchedLane & lanes) !== NoLanes) {\r\n                return_highestLanePriority = SyncBatchedLanePriority;\r\n                return SyncBatchedLane;\r\n            }\r\n            if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {\r\n                return_highestLanePriority = InputDiscreteHydrationLanePriority;\r\n                return InputDiscreteHydrationLane;\r\n            }\r\n            var inputDiscreteLanes = InputDiscreteLanes & lanes;\r\n            if (inputDiscreteLanes !== NoLanes) {\r\n                return_highestLanePriority = InputDiscreteLanePriority;\r\n                return inputDiscreteLanes;\r\n            }\r\n            if ((lanes & InputContinuousHydrationLane) !== NoLanes) {\r\n                return_highestLanePriority = InputContinuousHydrationLanePriority;\r\n                return InputContinuousHydrationLane;\r\n            }\r\n            var inputContinuousLanes = InputContinuousLanes & lanes;\r\n            if (inputContinuousLanes !== NoLanes) {\r\n                return_highestLanePriority = InputContinuousLanePriority;\r\n                return inputContinuousLanes;\r\n            }\r\n            if ((lanes & DefaultHydrationLane) !== NoLanes) {\r\n                return_highestLanePriority = DefaultHydrationLanePriority;\r\n                return DefaultHydrationLane;\r\n            }\r\n            var defaultLanes = DefaultLanes & lanes;\r\n            if (defaultLanes !== NoLanes) {\r\n                return_highestLanePriority = DefaultLanePriority;\r\n                return defaultLanes;\r\n            }\r\n            if ((lanes & TransitionHydrationLane) !== NoLanes) {\r\n                return_highestLanePriority = TransitionHydrationPriority;\r\n                return TransitionHydrationLane;\r\n            }\r\n            var transitionLanes = TransitionLanes & lanes;\r\n            if (transitionLanes !== NoLanes) {\r\n                return_highestLanePriority = TransitionPriority;\r\n                return transitionLanes;\r\n            }\r\n            var retryLanes = RetryLanes & lanes;\r\n            if (retryLanes !== NoLanes) {\r\n                return_highestLanePriority = RetryLanePriority;\r\n                return retryLanes;\r\n            }\r\n            if (lanes & SelectiveHydrationLane) {\r\n                return_highestLanePriority = SelectiveHydrationLanePriority;\r\n                return SelectiveHydrationLane;\r\n            }\r\n            if ((lanes & IdleHydrationLane) !== NoLanes) {\r\n                return_highestLanePriority = IdleHydrationLanePriority;\r\n                return IdleHydrationLane;\r\n            }\r\n            var idleLanes = IdleLanes & lanes;\r\n            if (idleLanes !== NoLanes) {\r\n                return_highestLanePriority = IdleLanePriority;\r\n                return idleLanes;\r\n            }\r\n            if ((OffscreenLane & lanes) !== NoLanes) {\r\n                return_highestLanePriority = OffscreenLanePriority;\r\n                return OffscreenLane;\r\n            }\r\n            {\r\n                error('Should have found matching lanes. This is a bug in React.');\r\n            } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\r\n            return_highestLanePriority = DefaultLanePriority;\r\n            return lanes;\r\n        }\r\n        function schedulerPriorityToLanePriority(schedulerPriorityLevel) {\r\n            switch (schedulerPriorityLevel) {\r\n                case ImmediatePriority:\r\n                    return SyncLanePriority;\r\n                case UserBlockingPriority:\r\n                    return InputContinuousLanePriority;\r\n                case NormalPriority:\r\n                case LowPriority:\r\n                    // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\r\n                    return DefaultLanePriority;\r\n                case IdlePriority:\r\n                    return IdleLanePriority;\r\n                default:\r\n                    return NoLanePriority;\r\n            }\r\n        }\r\n        function lanePriorityToSchedulerPriority(lanePriority) {\r\n            switch (lanePriority) {\r\n                case SyncLanePriority:\r\n                case SyncBatchedLanePriority:\r\n                    return ImmediatePriority;\r\n                case InputDiscreteHydrationLanePriority:\r\n                case InputDiscreteLanePriority:\r\n                case InputContinuousHydrationLanePriority:\r\n                case InputContinuousLanePriority:\r\n                    return UserBlockingPriority;\r\n                case DefaultHydrationLanePriority:\r\n                case DefaultLanePriority:\r\n                case TransitionHydrationPriority:\r\n                case TransitionPriority:\r\n                case SelectiveHydrationLanePriority:\r\n                case RetryLanePriority:\r\n                    return NormalPriority;\r\n                case IdleHydrationLanePriority:\r\n                case IdleLanePriority:\r\n                case OffscreenLanePriority:\r\n                    return IdlePriority;\r\n                case NoLanePriority:\r\n                    return NoPriority;\r\n                default:\r\n                    {\r\n                        {\r\n                            throw Error(\"Invalid update priority: \" + lanePriority + \". This is a bug in React.\");\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        function getNextLanes(root, wipLanes) {\r\n            // Early bailout if there's no pending work left.\r\n            var pendingLanes = root.pendingLanes;\r\n            if (pendingLanes === NoLanes) {\r\n                return_highestLanePriority = NoLanePriority;\r\n                return NoLanes;\r\n            }\r\n            var nextLanes = NoLanes;\r\n            var nextLanePriority = NoLanePriority;\r\n            var expiredLanes = root.expiredLanes;\r\n            var suspendedLanes = root.suspendedLanes;\r\n            var pingedLanes = root.pingedLanes; // Check if any work has expired.\r\n            if (expiredLanes !== NoLanes) {\r\n                nextLanes = expiredLanes;\r\n                nextLanePriority = return_highestLanePriority = SyncLanePriority;\r\n            }\r\n            else {\r\n                // Do not work on any idle work until all the non-idle work has finished,\r\n                // even if the work is suspended.\r\n                var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\r\n                if (nonIdlePendingLanes !== NoLanes) {\r\n                    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\r\n                    if (nonIdleUnblockedLanes !== NoLanes) {\r\n                        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\r\n                        nextLanePriority = return_highestLanePriority;\r\n                    }\r\n                    else {\r\n                        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\r\n                        if (nonIdlePingedLanes !== NoLanes) {\r\n                            nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\r\n                            nextLanePriority = return_highestLanePriority;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // The only remaining work is Idle.\r\n                    var unblockedLanes = pendingLanes & ~suspendedLanes;\r\n                    if (unblockedLanes !== NoLanes) {\r\n                        nextLanes = getHighestPriorityLanes(unblockedLanes);\r\n                        nextLanePriority = return_highestLanePriority;\r\n                    }\r\n                    else {\r\n                        if (pingedLanes !== NoLanes) {\r\n                            nextLanes = getHighestPriorityLanes(pingedLanes);\r\n                            nextLanePriority = return_highestLanePriority;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (nextLanes === NoLanes) {\r\n                // This should only be reachable if we're suspended\r\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\r\n                return NoLanes;\r\n            } // If there are higher priority lanes, we'll include them even if they\r\n            // are suspended.\r\n            nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt\r\n            // it and we'll lose our progress. We should only do this if the new lanes are\r\n            // higher priority.\r\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\r\n                // bother waiting until the root is complete.\r\n                (wipLanes & suspendedLanes) === NoLanes) {\r\n                getHighestPriorityLanes(wipLanes);\r\n                var wipLanePriority = return_highestLanePriority;\r\n                if (nextLanePriority <= wipLanePriority) {\r\n                    return wipLanes;\r\n                }\r\n                else {\r\n                    return_highestLanePriority = nextLanePriority;\r\n                }\r\n            } // Check for entangled lanes and add them to the batch.\r\n            //\r\n            // A lane is said to be entangled with another when it's not allowed to render\r\n            // in a batch that does not also include the other lane. Typically we do this\r\n            // when multiple updates have the same source, and we only want to respond to\r\n            // the most recent event from that source.\r\n            //\r\n            // Note that we apply entanglements *after* checking for partial work above.\r\n            // This means that if a lane is entangled during an interleaved event while\r\n            // it's already rendering, we won't interrupt it. This is intentional, since\r\n            // entanglement is usually \"best effort\": we'll try our best to render the\r\n            // lanes in the same batch, but it's not worth throwing out partially\r\n            // completed work in order to do it.\r\n            //\r\n            // For those exceptions where entanglement is semantically important, like\r\n            // useMutableSource, we should ensure that there is no partial work at the\r\n            // time we apply the entanglement.\r\n            var entangledLanes = root.entangledLanes;\r\n            if (entangledLanes !== NoLanes) {\r\n                var entanglements = root.entanglements;\r\n                var lanes = nextLanes & entangledLanes;\r\n                while (lanes > 0) {\r\n                    var index = pickArbitraryLaneIndex(lanes);\r\n                    var lane = 1 << index;\r\n                    nextLanes |= entanglements[index];\r\n                    lanes &= ~lane;\r\n                }\r\n            }\r\n            return nextLanes;\r\n        }\r\n        function getMostRecentEventTime(root, lanes) {\r\n            var eventTimes = root.eventTimes;\r\n            var mostRecentEventTime = NoTimestamp;\r\n            while (lanes > 0) {\r\n                var index = pickArbitraryLaneIndex(lanes);\r\n                var lane = 1 << index;\r\n                var eventTime = eventTimes[index];\r\n                if (eventTime > mostRecentEventTime) {\r\n                    mostRecentEventTime = eventTime;\r\n                }\r\n                lanes &= ~lane;\r\n            }\r\n            return mostRecentEventTime;\r\n        }\r\n        function computeExpirationTime(lane, currentTime) {\r\n            // TODO: Expiration heuristic is constant per lane, so could use a map.\r\n            getHighestPriorityLanes(lane);\r\n            var priority = return_highestLanePriority;\r\n            if (priority >= InputContinuousLanePriority) {\r\n                // User interactions should expire slightly more quickly.\r\n                //\r\n                // NOTE: This is set to the corresponding constant as in Scheduler.js. When\r\n                // we made it larger, a product metric in www regressed, suggesting there's\r\n                // a user interaction that's being starved by a series of synchronous\r\n                // updates. If that theory is correct, the proper solution is to fix the\r\n                // starvation. However, this scenario supports the idea that expiration\r\n                // times are an important safeguard when starvation does happen.\r\n                //\r\n                // Also note that, in the case of user input specifically, this will soon no\r\n                // longer be an issue because we plan to make user input synchronous by\r\n                // default (until you enter `startTransition`, of course.)\r\n                //\r\n                // If weren't planning to make these updates synchronous soon anyway, I\r\n                // would probably make this number a configurable parameter.\r\n                return currentTime + 250;\r\n            }\r\n            else if (priority >= TransitionPriority) {\r\n                return currentTime + 5000;\r\n            }\r\n            else {\r\n                // Anything idle priority or lower should never expire.\r\n                return NoTimestamp;\r\n            }\r\n        }\r\n        function markStarvedLanesAsExpired(root, currentTime) {\r\n            // TODO: This gets called every time we yield. We can optimize by storing\r\n            // the earliest expiration time on the root. Then use that to quickly bail out\r\n            // of this function.\r\n            var pendingLanes = root.pendingLanes;\r\n            var suspendedLanes = root.suspendedLanes;\r\n            var pingedLanes = root.pingedLanes;\r\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\r\n            // expiration time. If so, we'll assume the update is being starved and mark\r\n            // it as expired to force it to finish.\r\n            var lanes = pendingLanes;\r\n            while (lanes > 0) {\r\n                var index = pickArbitraryLaneIndex(lanes);\r\n                var lane = 1 << index;\r\n                var expirationTime = expirationTimes[index];\r\n                if (expirationTime === NoTimestamp) {\r\n                    // Found a pending lane with no expiration time. If it's not suspended, or\r\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\r\n                    // using the current time.\r\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\r\n                        // Assumes timestamps are monotonically increasing.\r\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\r\n                    }\r\n                }\r\n                else if (expirationTime <= currentTime) {\r\n                    // This lane expired\r\n                    root.expiredLanes |= lane;\r\n                }\r\n                lanes &= ~lane;\r\n            }\r\n        } // This returns the highest priority pending lanes regardless of whether they\r\n        function getLanesToRetrySynchronouslyOnError(root) {\r\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\r\n            if (everythingButOffscreen !== NoLanes) {\r\n                return everythingButOffscreen;\r\n            }\r\n            if (everythingButOffscreen & OffscreenLane) {\r\n                return OffscreenLane;\r\n            }\r\n            return NoLanes;\r\n        }\r\n        function returnNextLanesPriority() {\r\n            return return_highestLanePriority;\r\n        }\r\n        function includesNonIdleWork(lanes) {\r\n            return (lanes & NonIdleLanes) !== NoLanes;\r\n        }\r\n        function includesOnlyRetries(lanes) {\r\n            return (lanes & RetryLanes) === lanes;\r\n        }\r\n        function includesOnlyTransitions(lanes) {\r\n            return (lanes & TransitionLanes) === lanes;\r\n        } // To ensure consistency across multiple updates in the same event, this should\r\n        // be a pure function, so that it always returns the same lane for given inputs.\r\n        function findUpdateLane(lanePriority, wipLanes) {\r\n            switch (lanePriority) {\r\n                case NoLanePriority:\r\n                    break;\r\n                case SyncLanePriority:\r\n                    return SyncLane;\r\n                case SyncBatchedLanePriority:\r\n                    return SyncBatchedLane;\r\n                case InputDiscreteLanePriority:\r\n                    {\r\n                        var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);\r\n                        if (_lane === NoLane) {\r\n                            // Shift to the next priority level\r\n                            return findUpdateLane(InputContinuousLanePriority, wipLanes);\r\n                        }\r\n                        return _lane;\r\n                    }\r\n                case InputContinuousLanePriority:\r\n                    {\r\n                        var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);\r\n                        if (_lane2 === NoLane) {\r\n                            // Shift to the next priority level\r\n                            return findUpdateLane(DefaultLanePriority, wipLanes);\r\n                        }\r\n                        return _lane2;\r\n                    }\r\n                case DefaultLanePriority:\r\n                    {\r\n                        var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);\r\n                        if (_lane3 === NoLane) {\r\n                            // If all the default lanes are already being worked on, look for a\r\n                            // lane in the transition range.\r\n                            _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);\r\n                            if (_lane3 === NoLane) {\r\n                                // All the transition lanes are taken, too. This should be very\r\n                                // rare, but as a last resort, pick a default lane. This will have\r\n                                // the effect of interrupting the current work-in-progress render.\r\n                                _lane3 = pickArbitraryLane(DefaultLanes);\r\n                            }\r\n                        }\r\n                        return _lane3;\r\n                    }\r\n                case TransitionPriority: // Should be handled by findTransitionLane instead\r\n                case RetryLanePriority:\r\n                    // Should be handled by findRetryLane instead\r\n                    break;\r\n                case IdleLanePriority:\r\n                    var lane = pickArbitraryLane(IdleLanes & ~wipLanes);\r\n                    if (lane === NoLane) {\r\n                        lane = pickArbitraryLane(IdleLanes);\r\n                    }\r\n                    return lane;\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"Invalid update priority: \" + lanePriority + \". This is a bug in React.\");\r\n                }\r\n            }\r\n        } // To ensure consistency across multiple updates in the same event, this should\r\n        // be pure function, so that it always returns the same lane for given inputs.\r\n        function findTransitionLane(wipLanes, pendingLanes) {\r\n            // First look for lanes that are completely unclaimed, i.e. have no\r\n            // pending work.\r\n            var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);\r\n            if (lane === NoLane) {\r\n                // If all lanes have pending work, look for a lane that isn't currently\r\n                // being worked on.\r\n                lane = pickArbitraryLane(TransitionLanes & ~wipLanes);\r\n                if (lane === NoLane) {\r\n                    // If everything is being worked on, pick any lane. This has the\r\n                    // effect of interrupting the current work-in-progress.\r\n                    lane = pickArbitraryLane(TransitionLanes);\r\n                }\r\n            }\r\n            return lane;\r\n        } // To ensure consistency across multiple updates in the same event, this should\r\n        // be pure function, so that it always returns the same lane for given inputs.\r\n        function findRetryLane(wipLanes) {\r\n            // This is a fork of `findUpdateLane` designed specifically for Suspense\r\n            // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n            // from its placeholder state to its primary/resolved state.\r\n            var lane = pickArbitraryLane(RetryLanes & ~wipLanes);\r\n            if (lane === NoLane) {\r\n                lane = pickArbitraryLane(RetryLanes);\r\n            }\r\n            return lane;\r\n        }\r\n        function getHighestPriorityLane(lanes) {\r\n            return lanes & -lanes;\r\n        }\r\n        function getLowestPriorityLane(lanes) {\r\n            // This finds the most significant non-zero bit.\r\n            var index = 31 - clz32(lanes);\r\n            return index < 0 ? NoLanes : 1 << index;\r\n        }\r\n        function getEqualOrHigherPriorityLanes(lanes) {\r\n            return (getLowestPriorityLane(lanes) << 1) - 1;\r\n        }\r\n        function pickArbitraryLane(lanes) {\r\n            // This wrapper function gets inlined. Only exists so to communicate that it\r\n            // doesn't matter which bit is selected; you can pick any bit without\r\n            // affecting the algorithms where its used. Here I'm using\r\n            // getHighestPriorityLane because it requires the fewest operations.\r\n            return getHighestPriorityLane(lanes);\r\n        }\r\n        function pickArbitraryLaneIndex(lanes) {\r\n            return 31 - clz32(lanes);\r\n        }\r\n        function laneToIndex(lane) {\r\n            return pickArbitraryLaneIndex(lane);\r\n        }\r\n        function includesSomeLane(a, b) {\r\n            return (a & b) !== NoLanes;\r\n        }\r\n        function isSubsetOfLanes(set, subset) {\r\n            return (set & subset) === subset;\r\n        }\r\n        function mergeLanes(a, b) {\r\n            return a | b;\r\n        }\r\n        function removeLanes(set, subset) {\r\n            return set & ~subset;\r\n        } // Seems redundant, but it changes the type from a single lane (used for\r\n        // updates) to a group of lanes (used for flushing work).\r\n        function laneToLanes(lane) {\r\n            return lane;\r\n        }\r\n        function higherPriorityLane(a, b) {\r\n            // This works because the bit ranges decrease in priority as you go left.\r\n            return a !== NoLane && a < b ? a : b;\r\n        }\r\n        function createLaneMap(initial) {\r\n            // Intentionally pushing one by one.\r\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\r\n            var laneMap = [];\r\n            for (var i = 0; i < TotalLanes; i++) {\r\n                laneMap.push(initial);\r\n            }\r\n            return laneMap;\r\n        }\r\n        function markRootUpdated(root, updateLane, eventTime) {\r\n            root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But\r\n            // it's not practical to try every single possible combination. We need a\r\n            // heuristic to decide which lanes to attempt to render, and in which batches.\r\n            // For now, we use the same heuristic as in the old ExpirationTimes model:\r\n            // retry any lane at equal or lower priority, but don't try updates at higher\r\n            // priority without also including the lower priority updates. This works well\r\n            // when considering updates across different priority levels, but isn't\r\n            // sufficient for updates within the same priority, since we want to treat\r\n            // those updates as parallel.\r\n            // Unsuspend any update at equal or lower priority.\r\n            var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111\r\n            root.suspendedLanes &= higherPriorityLanes;\r\n            root.pingedLanes &= higherPriorityLanes;\r\n            var eventTimes = root.eventTimes;\r\n            var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\r\n            // recent event, and we assume time is monotonically increasing.\r\n            eventTimes[index] = eventTime;\r\n        }\r\n        function markRootSuspended(root, suspendedLanes) {\r\n            root.suspendedLanes |= suspendedLanes;\r\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\r\n            var expirationTimes = root.expirationTimes;\r\n            var lanes = suspendedLanes;\r\n            while (lanes > 0) {\r\n                var index = pickArbitraryLaneIndex(lanes);\r\n                var lane = 1 << index;\r\n                expirationTimes[index] = NoTimestamp;\r\n                lanes &= ~lane;\r\n            }\r\n        }\r\n        function markRootPinged(root, pingedLanes, eventTime) {\r\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\r\n        }\r\n        function markDiscreteUpdatesExpired(root) {\r\n            root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;\r\n        }\r\n        function hasDiscreteLanes(lanes) {\r\n            return (lanes & InputDiscreteLanes) !== NoLanes;\r\n        }\r\n        function markRootMutableRead(root, updateLane) {\r\n            root.mutableReadLanes |= updateLane & root.pendingLanes;\r\n        }\r\n        function markRootFinished(root, remainingLanes) {\r\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\r\n            root.pendingLanes = remainingLanes; // Let's try everything again\r\n            root.suspendedLanes = 0;\r\n            root.pingedLanes = 0;\r\n            root.expiredLanes &= remainingLanes;\r\n            root.mutableReadLanes &= remainingLanes;\r\n            root.entangledLanes &= remainingLanes;\r\n            var entanglements = root.entanglements;\r\n            var eventTimes = root.eventTimes;\r\n            var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\r\n            var lanes = noLongerPendingLanes;\r\n            while (lanes > 0) {\r\n                var index = pickArbitraryLaneIndex(lanes);\r\n                var lane = 1 << index;\r\n                entanglements[index] = NoLanes;\r\n                eventTimes[index] = NoTimestamp;\r\n                expirationTimes[index] = NoTimestamp;\r\n                lanes &= ~lane;\r\n            }\r\n        }\r\n        function markRootEntangled(root, entangledLanes) {\r\n            root.entangledLanes |= entangledLanes;\r\n            var entanglements = root.entanglements;\r\n            var lanes = entangledLanes;\r\n            while (lanes > 0) {\r\n                var index = pickArbitraryLaneIndex(lanes);\r\n                var lane = 1 << index;\r\n                entanglements[index] |= entangledLanes;\r\n                lanes &= ~lane;\r\n            }\r\n        }\r\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.\r\n        // Based on:\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n        var log = Math.log;\r\n        var LN2 = Math.LN2;\r\n        function clz32Fallback(lanes) {\r\n            if (lanes === 0) {\r\n                return 32;\r\n            }\r\n            return 31 - (log(lanes) / LN2 | 0) | 0;\r\n        }\r\n        // Intentionally not named imports because Rollup would use dynamic dispatch for\r\n        var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?\r\n        var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.\r\n        // We'd like to remove this but it's not clear if this is safe.\r\n        function setEnabled(enabled) {\r\n            _enabled = !!enabled;\r\n        }\r\n        function isEnabled() {\r\n            return _enabled;\r\n        }\r\n        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\r\n            var eventPriority = getEventPriorityForPluginSystem(domEventName);\r\n            var listenerWrapper;\r\n            switch (eventPriority) {\r\n                case DiscreteEvent:\r\n                    listenerWrapper = dispatchDiscreteEvent;\r\n                    break;\r\n                case UserBlockingEvent:\r\n                    listenerWrapper = dispatchUserBlockingUpdate;\r\n                    break;\r\n                case ContinuousEvent:\r\n                default:\r\n                    listenerWrapper = dispatchEvent;\r\n                    break;\r\n            }\r\n            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\r\n        }\r\n        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\r\n            {\r\n                flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\r\n            }\r\n            discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);\r\n        }\r\n        function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {\r\n            {\r\n                runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));\r\n            }\r\n        }\r\n        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            if (!_enabled) {\r\n                return;\r\n            }\r\n            var allowReplay = true;\r\n            {\r\n                // TODO: replaying capture phase events is currently broken\r\n                // because we used to do it during top-level native bubble handlers\r\n                // but now we use different bubble and capture handlers.\r\n                // In eager mode, we attach capture listeners early, so we need\r\n                // to filter them out until we fix the logic to handle them correctly.\r\n                // This could've been outside the flag but I put it inside to reduce risk.\r\n                allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\r\n            }\r\n            if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {\r\n                // If we already have a queue of discrete events, and this is another discrete\r\n                // event, then we can't dispatch it regardless of its target, since they\r\n                // need to dispatch in order.\r\n                queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\r\n                domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                return;\r\n            }\r\n            var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n            if (blockedOn === null) {\r\n                // We successfully dispatched this event.\r\n                if (allowReplay) {\r\n                    clearIfContinuousEvent(domEventName, nativeEvent);\r\n                }\r\n                return;\r\n            }\r\n            if (allowReplay) {\r\n                if (isReplayableDiscreteEvent(domEventName)) {\r\n                    // This this to be replayed later once the target is available.\r\n                    queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                    return;\r\n                }\r\n                if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\r\n                    return;\r\n                } // We need to clear only if we didn't queue because\r\n                // queueing is accummulative.\r\n                clearIfContinuousEvent(domEventName, nativeEvent);\r\n            } // This is not replayable so we'll invoke it but without a target,\r\n            // in case the event system needs to trace it.\r\n            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\r\n        } // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\r\n        function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n            // TODO: Warn if _enabled is false.\r\n            var nativeEventTarget = getEventTarget(nativeEvent);\r\n            var targetInst = getClosestInstanceFromNode(nativeEventTarget);\r\n            if (targetInst !== null) {\r\n                var nearestMounted = getNearestMountedFiber(targetInst);\r\n                if (nearestMounted === null) {\r\n                    // This tree has been unmounted already. Dispatch without a target.\r\n                    targetInst = null;\r\n                }\r\n                else {\r\n                    var tag = nearestMounted.tag;\r\n                    if (tag === SuspenseComponent) {\r\n                        var instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n                        if (instance !== null) {\r\n                            // Queue the event to be replayed later. Abort dispatching since we\r\n                            // don't want this event dispatched twice through the event system.\r\n                            // TODO: If this is the first discrete event in the queue. Schedule an increased\r\n                            // priority for this boundary.\r\n                            return instance;\r\n                        } // This shouldn't happen, something went wrong but to avoid blocking\r\n                        // the whole system, dispatch the event without a target.\r\n                        // TODO: Warn.\r\n                        targetInst = null;\r\n                    }\r\n                    else if (tag === HostRoot) {\r\n                        var root = nearestMounted.stateNode;\r\n                        if (root.hydrate) {\r\n                            // If this happens during a replay something went wrong and it might block\r\n                            // the whole system.\r\n                            return getContainerFromFiber(nearestMounted);\r\n                        }\r\n                        targetInst = null;\r\n                    }\r\n                    else if (nearestMounted !== targetInst) {\r\n                        // If we get an event (ex: img onload) before committing that\r\n                        // component's mount, ignore it for now (that is, treat it as if it was an\r\n                        // event on a non-React tree). We might also consider queueing events and\r\n                        // dispatching them after the mount.\r\n                        targetInst = null;\r\n                    }\r\n                }\r\n            }\r\n            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.\r\n            return null;\r\n        }\r\n        function addEventBubbleListener(target, eventType, listener) {\r\n            target.addEventListener(eventType, listener, false);\r\n            return listener;\r\n        }\r\n        function addEventCaptureListener(target, eventType, listener) {\r\n            target.addEventListener(eventType, listener, true);\r\n            return listener;\r\n        }\r\n        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {\r\n            target.addEventListener(eventType, listener, {\r\n                capture: true,\r\n                passive: passive\r\n            });\r\n            return listener;\r\n        }\r\n        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {\r\n            target.addEventListener(eventType, listener, {\r\n                passive: passive\r\n            });\r\n            return listener;\r\n        }\r\n        /**\r\n         * These variables store information about text content of a target node,\r\n         * allowing comparison of content before and after a given event.\r\n         *\r\n         * Identify the node where selection currently begins, then observe\r\n         * both its text content and its current position in the DOM. Since the\r\n         * browser may natively replace the target node during composition, we can\r\n         * use its position to find its replacement.\r\n         *\r\n         *\r\n         */\r\n        var root = null;\r\n        var startText = null;\r\n        var fallbackText = null;\r\n        function initialize(nativeEventTarget) {\r\n            root = nativeEventTarget;\r\n            startText = getText();\r\n            return true;\r\n        }\r\n        function reset() {\r\n            root = null;\r\n            startText = null;\r\n            fallbackText = null;\r\n        }\r\n        function getData() {\r\n            if (fallbackText) {\r\n                return fallbackText;\r\n            }\r\n            var start;\r\n            var startValue = startText;\r\n            var startLength = startValue.length;\r\n            var end;\r\n            var endValue = getText();\r\n            var endLength = endValue.length;\r\n            for (start = 0; start < startLength; start++) {\r\n                if (startValue[start] !== endValue[start]) {\r\n                    break;\r\n                }\r\n            }\r\n            var minEnd = startLength - start;\r\n            for (end = 1; end <= minEnd; end++) {\r\n                if (startValue[startLength - end] !== endValue[endLength - end]) {\r\n                    break;\r\n                }\r\n            }\r\n            var sliceTail = end > 1 ? 1 - end : undefined;\r\n            fallbackText = endValue.slice(start, sliceTail);\r\n            return fallbackText;\r\n        }\r\n        function getText() {\r\n            if ('value' in root) {\r\n                return root.value;\r\n            }\r\n            return root.textContent;\r\n        }\r\n        /**\r\n         * `charCode` represents the actual \"character code\" and is safe to use with\r\n         * `String.fromCharCode`. As such, only keys that correspond to printable\r\n         * characters produce a valid `charCode`, the only exception to this is Enter.\r\n         * The Tab-key is considered non-printable and does not have a `charCode`,\r\n         * presumably because it does not produce a tab-character in browsers.\r\n         *\r\n         * @param {object} nativeEvent Native browser event.\r\n         * @return {number} Normalized `charCode` property.\r\n         */\r\n        function getEventCharCode(nativeEvent) {\r\n            var charCode;\r\n            var keyCode = nativeEvent.keyCode;\r\n            if ('charCode' in nativeEvent) {\r\n                charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.\r\n                if (charCode === 0 && keyCode === 13) {\r\n                    charCode = 13;\r\n                }\r\n            }\r\n            else {\r\n                // IE8 does not implement `charCode`, but `keyCode` has the correct value.\r\n                charCode = keyCode;\r\n            } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\r\n            // report Enter as charCode 10 when ctrl is pressed.\r\n            if (charCode === 10) {\r\n                charCode = 13;\r\n            } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\r\n            // Must not discard the (non-)printable Enter-key.\r\n            if (charCode >= 32 || charCode === 13) {\r\n                return charCode;\r\n            }\r\n            return 0;\r\n        }\r\n        function functionThatReturnsTrue() {\r\n            return true;\r\n        }\r\n        function functionThatReturnsFalse() {\r\n            return false;\r\n        } // This is intentionally a factory so that we have different returned constructors.\r\n        // If we had a single constructor, it would be megamorphic and engines would deopt.\r\n        function createSyntheticEvent(Interface) {\r\n            /**\r\n             * Synthetic events are dispatched by event plugins, typically in response to a\r\n             * top-level event delegation handler.\r\n             *\r\n             * These systems should generally use pooling to reduce the frequency of garbage\r\n             * collection. The system should check `isPersistent` to determine whether the\r\n             * event should be released into the pool after being dispatched. Users that\r\n             * need a persisted event should invoke `persist`.\r\n             *\r\n             * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\r\n             * normalizing browser quirks. Subclasses do not necessarily have to implement a\r\n             * DOM interface; custom application-specific events can also subclass this.\r\n             */\r\n            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\r\n                this._reactName = reactName;\r\n                this._targetInst = targetInst;\r\n                this.type = reactEventType;\r\n                this.nativeEvent = nativeEvent;\r\n                this.target = nativeEventTarget;\r\n                this.currentTarget = null;\r\n                for (var _propName in Interface) {\r\n                    if (!Interface.hasOwnProperty(_propName)) {\r\n                        continue;\r\n                    }\r\n                    var normalize = Interface[_propName];\r\n                    if (normalize) {\r\n                        this[_propName] = normalize(nativeEvent);\r\n                    }\r\n                    else {\r\n                        this[_propName] = nativeEvent[_propName];\r\n                    }\r\n                }\r\n                var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\r\n                if (defaultPrevented) {\r\n                    this.isDefaultPrevented = functionThatReturnsTrue;\r\n                }\r\n                else {\r\n                    this.isDefaultPrevented = functionThatReturnsFalse;\r\n                }\r\n                this.isPropagationStopped = functionThatReturnsFalse;\r\n                return this;\r\n            }\r\n            _assign(SyntheticBaseEvent.prototype, {\r\n                preventDefault: function () {\r\n                    this.defaultPrevented = true;\r\n                    var event = this.nativeEvent;\r\n                    if (!event) {\r\n                        return;\r\n                    }\r\n                    if (event.preventDefault) {\r\n                        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE\r\n                    }\r\n                    else if (typeof event.returnValue !== 'unknown') {\r\n                        event.returnValue = false;\r\n                    }\r\n                    this.isDefaultPrevented = functionThatReturnsTrue;\r\n                },\r\n                stopPropagation: function () {\r\n                    var event = this.nativeEvent;\r\n                    if (!event) {\r\n                        return;\r\n                    }\r\n                    if (event.stopPropagation) {\r\n                        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE\r\n                    }\r\n                    else if (typeof event.cancelBubble !== 'unknown') {\r\n                        // The ChangeEventPlugin registers a \"propertychange\" event for\r\n                        // IE. This event does not support bubbling or cancelling, and\r\n                        // any references to cancelBubble throw \"Member not found\".  A\r\n                        // typeof check of \"unknown\" circumvents this issue (and is also\r\n                        // IE specific).\r\n                        event.cancelBubble = true;\r\n                    }\r\n                    this.isPropagationStopped = functionThatReturnsTrue;\r\n                },\r\n                /**\r\n                 * We release all dispatched `SyntheticEvent`s after each event loop, adding\r\n                 * them back into the pool. This allows a way to hold onto a reference that\r\n                 * won't be added back into the pool.\r\n                 */\r\n                persist: function () {\r\n                },\r\n                /**\r\n                 * Checks if this event should be released back into the pool.\r\n                 *\r\n                 * @return {boolean} True if this should not be released, false otherwise.\r\n                 */\r\n                isPersistent: functionThatReturnsTrue\r\n            });\r\n            return SyntheticBaseEvent;\r\n        }\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var EventInterface = {\r\n            eventPhase: 0,\r\n            bubbles: 0,\r\n            cancelable: 0,\r\n            timeStamp: function (event) {\r\n                return event.timeStamp || Date.now();\r\n            },\r\n            defaultPrevented: 0,\r\n            isTrusted: 0\r\n        };\r\n        var SyntheticEvent = createSyntheticEvent(EventInterface);\r\n        var UIEventInterface = _assign({}, EventInterface, {\r\n            view: 0,\r\n            detail: 0\r\n        });\r\n        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\r\n        var lastMovementX;\r\n        var lastMovementY;\r\n        var lastMouseEvent;\r\n        function updateMouseMovementPolyfillState(event) {\r\n            if (event !== lastMouseEvent) {\r\n                if (lastMouseEvent && event.type === 'mousemove') {\r\n                    lastMovementX = event.screenX - lastMouseEvent.screenX;\r\n                    lastMovementY = event.screenY - lastMouseEvent.screenY;\r\n                }\r\n                else {\r\n                    lastMovementX = 0;\r\n                    lastMovementY = 0;\r\n                }\r\n                lastMouseEvent = event;\r\n            }\r\n        }\r\n        /**\r\n         * @interface MouseEvent\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var MouseEventInterface = _assign({}, UIEventInterface, {\r\n            screenX: 0,\r\n            screenY: 0,\r\n            clientX: 0,\r\n            clientY: 0,\r\n            pageX: 0,\r\n            pageY: 0,\r\n            ctrlKey: 0,\r\n            shiftKey: 0,\r\n            altKey: 0,\r\n            metaKey: 0,\r\n            getModifierState: getEventModifierState,\r\n            button: 0,\r\n            buttons: 0,\r\n            relatedTarget: function (event) {\r\n                if (event.relatedTarget === undefined)\r\n                    return event.fromElement === event.srcElement ? event.toElement : event.fromElement;\r\n                return event.relatedTarget;\r\n            },\r\n            movementX: function (event) {\r\n                if ('movementX' in event) {\r\n                    return event.movementX;\r\n                }\r\n                updateMouseMovementPolyfillState(event);\r\n                return lastMovementX;\r\n            },\r\n            movementY: function (event) {\r\n                if ('movementY' in event) {\r\n                    return event.movementY;\r\n                } // Don't need to call updateMouseMovementPolyfillState() here\r\n                // because it's guaranteed to have already run when movementX\r\n                // was copied.\r\n                return lastMovementY;\r\n            }\r\n        });\r\n        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\r\n        /**\r\n         * @interface DragEvent\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var DragEventInterface = _assign({}, MouseEventInterface, {\r\n            dataTransfer: 0\r\n        });\r\n        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);\r\n        /**\r\n         * @interface FocusEvent\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var FocusEventInterface = _assign({}, UIEventInterface, {\r\n            relatedTarget: 0\r\n        });\r\n        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\r\n         */\r\n        var AnimationEventInterface = _assign({}, EventInterface, {\r\n            animationName: 0,\r\n            elapsedTime: 0,\r\n            pseudoElement: 0\r\n        });\r\n        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/clipboard-apis/\r\n         */\r\n        var ClipboardEventInterface = _assign({}, EventInterface, {\r\n            clipboardData: function (event) {\r\n                return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\r\n            }\r\n        });\r\n        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\r\n         */\r\n        var CompositionEventInterface = _assign({}, EventInterface, {\r\n            data: 0\r\n        });\r\n        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\r\n         *      /#events-inputevents\r\n         */\r\n        // Happens to share the same list for now.\r\n        var SyntheticInputEvent = SyntheticCompositionEvent;\r\n        /**\r\n         * Normalization of deprecated HTML5 `key` values\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\r\n         */\r\n        var normalizeKey = {\r\n            Esc: 'Escape',\r\n            Spacebar: ' ',\r\n            Left: 'ArrowLeft',\r\n            Up: 'ArrowUp',\r\n            Right: 'ArrowRight',\r\n            Down: 'ArrowDown',\r\n            Del: 'Delete',\r\n            Win: 'OS',\r\n            Menu: 'ContextMenu',\r\n            Apps: 'ContextMenu',\r\n            Scroll: 'ScrollLock',\r\n            MozPrintableKey: 'Unidentified'\r\n        };\r\n        /**\r\n         * Translation from legacy `keyCode` to HTML5 `key`\r\n         * Only special keys supported, all others depend on keyboard layout or browser\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\r\n         */\r\n        var translateToKey = {\r\n            '8': 'Backspace',\r\n            '9': 'Tab',\r\n            '12': 'Clear',\r\n            '13': 'Enter',\r\n            '16': 'Shift',\r\n            '17': 'Control',\r\n            '18': 'Alt',\r\n            '19': 'Pause',\r\n            '20': 'CapsLock',\r\n            '27': 'Escape',\r\n            '32': ' ',\r\n            '33': 'PageUp',\r\n            '34': 'PageDown',\r\n            '35': 'End',\r\n            '36': 'Home',\r\n            '37': 'ArrowLeft',\r\n            '38': 'ArrowUp',\r\n            '39': 'ArrowRight',\r\n            '40': 'ArrowDown',\r\n            '45': 'Insert',\r\n            '46': 'Delete',\r\n            '112': 'F1',\r\n            '113': 'F2',\r\n            '114': 'F3',\r\n            '115': 'F4',\r\n            '116': 'F5',\r\n            '117': 'F6',\r\n            '118': 'F7',\r\n            '119': 'F8',\r\n            '120': 'F9',\r\n            '121': 'F10',\r\n            '122': 'F11',\r\n            '123': 'F12',\r\n            '144': 'NumLock',\r\n            '145': 'ScrollLock',\r\n            '224': 'Meta'\r\n        };\r\n        /**\r\n         * @param {object} nativeEvent Native browser event.\r\n         * @return {string} Normalized `key` property.\r\n         */\r\n        function getEventKey(nativeEvent) {\r\n            if (nativeEvent.key) {\r\n                // Normalize inconsistent values reported by browsers due to\r\n                // implementations of a working draft specification.\r\n                // FireFox implements `key` but returns `MozPrintableKey` for all\r\n                // printable characters (normalized to `Unidentified`), ignore it.\r\n                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\r\n                if (key !== 'Unidentified') {\r\n                    return key;\r\n                }\r\n            } // Browser does not implement `key`, polyfill as much of it as we can.\r\n            if (nativeEvent.type === 'keypress') {\r\n                var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can\r\n                // thus be captured by `keypress`, no other non-printable key should.\r\n                return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\r\n            }\r\n            if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\r\n                // While user keyboard layout determines the actual meaning of each\r\n                // `keyCode` value, almost all function keys have a universal value.\r\n                return translateToKey[nativeEvent.keyCode] || 'Unidentified';\r\n            }\r\n            return '';\r\n        }\r\n        /**\r\n         * Translation from modifier key to the associated property in the event.\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\r\n         */\r\n        var modifierKeyToProp = {\r\n            Alt: 'altKey',\r\n            Control: 'ctrlKey',\r\n            Meta: 'metaKey',\r\n            Shift: 'shiftKey'\r\n        }; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\r\n        // getModifierState. If getModifierState is not supported, we map it to a set of\r\n        // modifier keys exposed by the event. In this case, Lock-keys are not supported.\r\n        function modifierStateGetter(keyArg) {\r\n            var syntheticEvent = this;\r\n            var nativeEvent = syntheticEvent.nativeEvent;\r\n            if (nativeEvent.getModifierState) {\r\n                return nativeEvent.getModifierState(keyArg);\r\n            }\r\n            var keyProp = modifierKeyToProp[keyArg];\r\n            return keyProp ? !!nativeEvent[keyProp] : false;\r\n        }\r\n        function getEventModifierState(nativeEvent) {\r\n            return modifierStateGetter;\r\n        }\r\n        /**\r\n         * @interface KeyboardEvent\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var KeyboardEventInterface = _assign({}, UIEventInterface, {\r\n            key: getEventKey,\r\n            code: 0,\r\n            location: 0,\r\n            ctrlKey: 0,\r\n            shiftKey: 0,\r\n            altKey: 0,\r\n            metaKey: 0,\r\n            repeat: 0,\r\n            locale: 0,\r\n            getModifierState: getEventModifierState,\r\n            // Legacy Interface\r\n            charCode: function (event) {\r\n                // `charCode` is the result of a KeyPress event and represents the value of\r\n                // the actual printable character.\r\n                // KeyPress is deprecated, but its replacement is not yet final and not\r\n                // implemented in any major browser. Only KeyPress has charCode.\r\n                if (event.type === 'keypress') {\r\n                    return getEventCharCode(event);\r\n                }\r\n                return 0;\r\n            },\r\n            keyCode: function (event) {\r\n                // `keyCode` is the result of a KeyDown/Up event and represents the value of\r\n                // physical keyboard key.\r\n                // The actual meaning of the value depends on the users' keyboard layout\r\n                // which cannot be detected. Assuming that it is a US keyboard layout\r\n                // provides a surprisingly accurate mapping for US and European users.\r\n                // Due to this, it is left to the user to implement at this time.\r\n                if (event.type === 'keydown' || event.type === 'keyup') {\r\n                    return event.keyCode;\r\n                }\r\n                return 0;\r\n            },\r\n            which: function (event) {\r\n                // `which` is an alias for either `keyCode` or `charCode` depending on the\r\n                // type of the event.\r\n                if (event.type === 'keypress') {\r\n                    return getEventCharCode(event);\r\n                }\r\n                if (event.type === 'keydown' || event.type === 'keyup') {\r\n                    return event.keyCode;\r\n                }\r\n                return 0;\r\n            }\r\n        });\r\n        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);\r\n        /**\r\n         * @interface PointerEvent\r\n         * @see http://www.w3.org/TR/pointerevents/\r\n         */\r\n        var PointerEventInterface = _assign({}, MouseEventInterface, {\r\n            pointerId: 0,\r\n            width: 0,\r\n            height: 0,\r\n            pressure: 0,\r\n            tangentialPressure: 0,\r\n            tiltX: 0,\r\n            tiltY: 0,\r\n            twist: 0,\r\n            pointerType: 0,\r\n            isPrimary: 0\r\n        });\r\n        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);\r\n        /**\r\n         * @interface TouchEvent\r\n         * @see http://www.w3.org/TR/touch-events/\r\n         */\r\n        var TouchEventInterface = _assign({}, UIEventInterface, {\r\n            touches: 0,\r\n            targetTouches: 0,\r\n            changedTouches: 0,\r\n            altKey: 0,\r\n            metaKey: 0,\r\n            ctrlKey: 0,\r\n            shiftKey: 0,\r\n            getModifierState: getEventModifierState\r\n        });\r\n        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);\r\n        /**\r\n         * @interface Event\r\n         * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\r\n         */\r\n        var TransitionEventInterface = _assign({}, EventInterface, {\r\n            propertyName: 0,\r\n            elapsedTime: 0,\r\n            pseudoElement: 0\r\n        });\r\n        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);\r\n        /**\r\n         * @interface WheelEvent\r\n         * @see http://www.w3.org/TR/DOM-Level-3-Events/\r\n         */\r\n        var WheelEventInterface = _assign({}, MouseEventInterface, {\r\n            deltaX: function (event) {\r\n                return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\r\n                    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\r\n            },\r\n            deltaY: function (event) {\r\n                return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\r\n                    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\r\n                        'wheelDelta' in event ? -event.wheelDelta : 0;\r\n            },\r\n            deltaZ: 0,\r\n            // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\r\n            // notch on the scroll is always +/- 120, roughly equivalent to pixels.\r\n            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\r\n            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\r\n            deltaMode: 0\r\n        });\r\n        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);\r\n        var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\r\n        var START_KEYCODE = 229;\r\n        var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\r\n        var documentMode = null;\r\n        if (canUseDOM && 'documentMode' in document) {\r\n            documentMode = document.documentMode;\r\n        } // Webkit offers a very useful `textInput` event that can be used to\r\n        // directly represent `beforeInput`. The IE `textinput` event is not as\r\n        // useful, so we don't use it.\r\n        var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied\r\n        // by the native compositionend event may be incorrect. Japanese ideographic\r\n        // spaces, for instance (\\u3000) are not recorded correctly.\r\n        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\r\n        var SPACEBAR_CODE = 32;\r\n        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\r\n        function registerEvents() {\r\n            registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);\r\n            registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\r\n            registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\r\n            registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);\r\n        } // Track whether we've ever handled a keypress on the space key.\r\n        var hasSpaceKeypress = false;\r\n        /**\r\n         * Return whether a native keypress event is assumed to be a command.\r\n         * This is required because Firefox fires `keypress` events for key commands\r\n         * (cut, copy, select-all, etc.) even though no character is inserted.\r\n         */\r\n        function isKeypressCommand(nativeEvent) {\r\n            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\r\n                !(nativeEvent.ctrlKey && nativeEvent.altKey);\r\n        }\r\n        /**\r\n         * Translate native top level events into event types.\r\n         */\r\n        function getCompositionEventType(domEventName) {\r\n            switch (domEventName) {\r\n                case 'compositionstart':\r\n                    return 'onCompositionStart';\r\n                case 'compositionend':\r\n                    return 'onCompositionEnd';\r\n                case 'compositionupdate':\r\n                    return 'onCompositionUpdate';\r\n            }\r\n        }\r\n        /**\r\n         * Does our fallback best-guess model think this event signifies that\r\n         * composition has begun?\r\n         */\r\n        function isFallbackCompositionStart(domEventName, nativeEvent) {\r\n            return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;\r\n        }\r\n        /**\r\n         * Does our fallback mode think that this event is the end of composition?\r\n         */\r\n        function isFallbackCompositionEnd(domEventName, nativeEvent) {\r\n            switch (domEventName) {\r\n                case 'keyup':\r\n                    // Command keys insert or clear IME input.\r\n                    return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\r\n                case 'keydown':\r\n                    // Expect IME keyCode on each keydown. If we get any other\r\n                    // code we must have exited earlier.\r\n                    return nativeEvent.keyCode !== START_KEYCODE;\r\n                case 'keypress':\r\n                case 'mousedown':\r\n                case 'focusout':\r\n                    // Events are not possible without cancelling IME.\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n        /**\r\n         * Google Input Tools provides composition data via a CustomEvent,\r\n         * with the `data` property populated in the `detail` object. If this\r\n         * is available on the event object, use it. If not, this is a plain\r\n         * composition event and we have nothing special to extract.\r\n         *\r\n         * @param {object} nativeEvent\r\n         * @return {?string}\r\n         */\r\n        function getDataFromCustomEvent(nativeEvent) {\r\n            var detail = nativeEvent.detail;\r\n            if (typeof detail === 'object' && 'data' in detail) {\r\n                return detail.data;\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * Check if a composition event was triggered by Korean IME.\r\n         * Our fallback mode does not work well with IE's Korean IME,\r\n         * so just use native composition events when Korean IME is used.\r\n         * Although CompositionEvent.locale property is deprecated,\r\n         * it is available in IE, where our fallback mode is enabled.\r\n         *\r\n         * @param {object} nativeEvent\r\n         * @return {boolean}\r\n         */\r\n        function isUsingKoreanIME(nativeEvent) {\r\n            return nativeEvent.locale === 'ko';\r\n        } // Track the current IME composition status, if any.\r\n        var isComposing = false;\r\n        /**\r\n         * @return {?object} A SyntheticCompositionEvent.\r\n         */\r\n        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\r\n            var eventType;\r\n            var fallbackData;\r\n            if (canUseCompositionEvent) {\r\n                eventType = getCompositionEventType(domEventName);\r\n            }\r\n            else if (!isComposing) {\r\n                if (isFallbackCompositionStart(domEventName, nativeEvent)) {\r\n                    eventType = 'onCompositionStart';\r\n                }\r\n            }\r\n            else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\r\n                eventType = 'onCompositionEnd';\r\n            }\r\n            if (!eventType) {\r\n                return null;\r\n            }\r\n            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\r\n                // The current composition is stored statically and must not be\r\n                // overwritten while composition continues.\r\n                if (!isComposing && eventType === 'onCompositionStart') {\r\n                    isComposing = initialize(nativeEventTarget);\r\n                }\r\n                else if (eventType === 'onCompositionEnd') {\r\n                    if (isComposing) {\r\n                        fallbackData = getData();\r\n                    }\r\n                }\r\n            }\r\n            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);\r\n            if (listeners.length > 0) {\r\n                var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\r\n                dispatchQueue.push({\r\n                    event: event,\r\n                    listeners: listeners\r\n                });\r\n                if (fallbackData) {\r\n                    // Inject data generated from fallback path into the synthetic event.\r\n                    // This matches the property of native CompositionEventInterface.\r\n                    event.data = fallbackData;\r\n                }\r\n                else {\r\n                    var customData = getDataFromCustomEvent(nativeEvent);\r\n                    if (customData !== null) {\r\n                        event.data = customData;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function getNativeBeforeInputChars(domEventName, nativeEvent) {\r\n            switch (domEventName) {\r\n                case 'compositionend':\r\n                    return getDataFromCustomEvent(nativeEvent);\r\n                case 'keypress':\r\n                    /**\r\n                     * If native `textInput` events are available, our goal is to make\r\n                     * use of them. However, there is a special case: the spacebar key.\r\n                     * In Webkit, preventing default on a spacebar `textInput` event\r\n                     * cancels character insertion, but it *also* causes the browser\r\n                     * to fall back to its default spacebar behavior of scrolling the\r\n                     * page.\r\n                     *\r\n                     * Tracking at:\r\n                     * https://code.google.com/p/chromium/issues/detail?id=355103\r\n                     *\r\n                     * To avoid this issue, use the keypress event as if no `textInput`\r\n                     * event is available.\r\n                     */\r\n                    var which = nativeEvent.which;\r\n                    if (which !== SPACEBAR_CODE) {\r\n                        return null;\r\n                    }\r\n                    hasSpaceKeypress = true;\r\n                    return SPACEBAR_CHAR;\r\n                case 'textInput':\r\n                    // Record the characters to be added to the DOM.\r\n                    var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\r\n                    // it at the keypress level and bail immediately. Android Chrome\r\n                    // doesn't give us keycodes, so we need to ignore it.\r\n                    if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\r\n                        return null;\r\n                    }\r\n                    return chars;\r\n                default:\r\n                    // For other native event types, do nothing.\r\n                    return null;\r\n            }\r\n        }\r\n        /**\r\n         * For browsers that do not provide the `textInput` event, extract the\r\n         * appropriate string to use for SyntheticInputEvent.\r\n         */\r\n        function getFallbackBeforeInputChars(domEventName, nativeEvent) {\r\n            // If we are currently composing (IME) and using a fallback to do so,\r\n            // try to extract the composed characters from the fallback object.\r\n            // If composition event is available, we extract a string only at\r\n            // compositionevent, otherwise extract it at fallback events.\r\n            if (isComposing) {\r\n                if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\r\n                    var chars = getData();\r\n                    reset();\r\n                    isComposing = false;\r\n                    return chars;\r\n                }\r\n                return null;\r\n            }\r\n            switch (domEventName) {\r\n                case 'paste':\r\n                    // If a paste event occurs after a keypress, throw out the input\r\n                    // chars. Paste events should not lead to BeforeInput events.\r\n                    return null;\r\n                case 'keypress':\r\n                    /**\r\n                     * As of v27, Firefox may fire keypress events even when no character\r\n                     * will be inserted. A few possibilities:\r\n                     *\r\n                     * - `which` is `0`. Arrow keys, Esc key, etc.\r\n                     *\r\n                     * - `which` is the pressed key code, but no char is available.\r\n                     *   Ex: 'AltGr + d` in Polish. There is no modified character for\r\n                     *   this key combination and no character is inserted into the\r\n                     *   document, but FF fires the keypress for char code `100` anyway.\r\n                     *   No `input` event will occur.\r\n                     *\r\n                     * - `which` is the pressed key code, but a command combination is\r\n                     *   being used. Ex: `Cmd+C`. No character is inserted, and no\r\n                     *   `input` event will occur.\r\n                     */\r\n                    if (!isKeypressCommand(nativeEvent)) {\r\n                        // IE fires the `keypress` event when a user types an emoji via\r\n                        // Touch keyboard of Windows.  In such a case, the `char` property\r\n                        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\r\n                        // is 2, the property `which` does not represent an emoji correctly.\r\n                        // In such a case, we directly return the `char` property instead of\r\n                        // using `which`.\r\n                        if (nativeEvent.char && nativeEvent.char.length > 1) {\r\n                            return nativeEvent.char;\r\n                        }\r\n                        else if (nativeEvent.which) {\r\n                            return String.fromCharCode(nativeEvent.which);\r\n                        }\r\n                    }\r\n                    return null;\r\n                case 'compositionend':\r\n                    return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n        /**\r\n         * Extract a SyntheticInputEvent for `beforeInput`, based on either native\r\n         * `textInput` or fallback behavior.\r\n         *\r\n         * @return {?object} A SyntheticInputEvent.\r\n         */\r\n        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\r\n            var chars;\r\n            if (canUseTextInputEvent) {\r\n                chars = getNativeBeforeInputChars(domEventName, nativeEvent);\r\n            }\r\n            else {\r\n                chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\r\n            } // If no characters are being inserted, no BeforeInput event should\r\n            // be fired.\r\n            if (!chars) {\r\n                return null;\r\n            }\r\n            var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');\r\n            if (listeners.length > 0) {\r\n                var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);\r\n                dispatchQueue.push({\r\n                    event: event,\r\n                    listeners: listeners\r\n                });\r\n                event.data = chars;\r\n            }\r\n        }\r\n        /**\r\n         * Create an `onBeforeInput` event to match\r\n         * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\r\n         *\r\n         * This event plugin is based on the native `textInput` event\r\n         * available in Chrome, Safari, Opera, and IE. This event fires after\r\n         * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\r\n         *\r\n         * `beforeInput` is spec'd but not implemented in any browsers, and\r\n         * the `input` event does not provide any useful information about what has\r\n         * actually been added, contrary to the spec. Thus, `textInput` is the best\r\n         * available event to identify the characters that have actually been inserted\r\n         * into the target node.\r\n         *\r\n         * This plugin is also responsible for emitting `composition` events, thus\r\n         * allowing us to share composition fallback code for both `beforeInput` and\r\n         * `composition` event types.\r\n         */\r\n        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n        }\r\n        /**\r\n         * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\r\n         */\r\n        var supportedInputTypes = {\r\n            color: true,\r\n            date: true,\r\n            datetime: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            password: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true\r\n        };\r\n        function isTextInputElement(elem) {\r\n            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\r\n            if (nodeName === 'input') {\r\n                return !!supportedInputTypes[elem.type];\r\n            }\r\n            if (nodeName === 'textarea') {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        /**\r\n         * Checks if an event is supported in the current execution environment.\r\n         *\r\n         * NOTE: This will not work correctly for non-generic events such as `change`,\r\n         * `reset`, `load`, `error`, and `select`.\r\n         *\r\n         * Borrows from Modernizr.\r\n         *\r\n         * @param {string} eventNameSuffix Event name, e.g. \"click\".\r\n         * @return {boolean} True if the event is supported.\r\n         * @internal\r\n         * @license Modernizr 3.0.0pre (Custom Build) | MIT\r\n         */\r\n        function isEventSupported(eventNameSuffix) {\r\n            if (!canUseDOM) {\r\n                return false;\r\n            }\r\n            var eventName = 'on' + eventNameSuffix;\r\n            var isSupported = (eventName in document);\r\n            if (!isSupported) {\r\n                var element = document.createElement('div');\r\n                element.setAttribute(eventName, 'return;');\r\n                isSupported = typeof element[eventName] === 'function';\r\n            }\r\n            return isSupported;\r\n        }\r\n        function registerEvents$1() {\r\n            registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);\r\n        }\r\n        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\r\n            // Flag this event loop as needing state restore.\r\n            enqueueStateRestore(target);\r\n            var listeners = accumulateTwoPhaseListeners(inst, 'onChange');\r\n            if (listeners.length > 0) {\r\n                var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);\r\n                dispatchQueue.push({\r\n                    event: event,\r\n                    listeners: listeners\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * For IE shims\r\n         */\r\n        var activeElement = null;\r\n        var activeElementInst = null;\r\n        /**\r\n         * SECTION: handle `change` event\r\n         */\r\n        function shouldUseChangeEvent(elem) {\r\n            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\r\n            return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\r\n        }\r\n        function manualDispatchChangeEvent(nativeEvent) {\r\n            var dispatchQueue = [];\r\n            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\r\n            // other events and have it go through ReactBrowserEventEmitter. Since it\r\n            // doesn't, we manually listen for the events and so we have to enqueue and\r\n            // process the abstract event manually.\r\n            //\r\n            // Batching is necessary here in order to ensure that all event handlers run\r\n            // before the next rerender (including event handlers attached to ancestor\r\n            // elements instead of directly on the input). Without this, controlled\r\n            // components don't work properly in conjunction with event bubbling because\r\n            // the component is rerendered and the value reverted before all the event\r\n            // handlers can run. See https://github.com/facebook/react/issues/708.\r\n            batchedUpdates(runEventInBatch, dispatchQueue);\r\n        }\r\n        function runEventInBatch(dispatchQueue) {\r\n            processDispatchQueue(dispatchQueue, 0);\r\n        }\r\n        function getInstIfValueChanged(targetInst) {\r\n            var targetNode = getNodeFromInstance(targetInst);\r\n            if (updateValueIfChanged(targetNode)) {\r\n                return targetInst;\r\n            }\r\n        }\r\n        function getTargetInstForChangeEvent(domEventName, targetInst) {\r\n            if (domEventName === 'change') {\r\n                return targetInst;\r\n            }\r\n        }\r\n        /**\r\n         * SECTION: handle `input` event\r\n         */\r\n        var isInputEventSupported = false;\r\n        if (canUseDOM) {\r\n            // IE9 claims to support the input event but fails to trigger it when\r\n            // deleting text, so we ignore its input events.\r\n            isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\r\n        }\r\n        /**\r\n         * (For IE <=9) Starts tracking propertychange events on the passed-in element\r\n         * and override the value property so that we can distinguish user events from\r\n         * value changes in JS.\r\n         */\r\n        function startWatchingForValueChange(target, targetInst) {\r\n            activeElement = target;\r\n            activeElementInst = targetInst;\r\n            activeElement.attachEvent('onpropertychange', handlePropertyChange);\r\n        }\r\n        /**\r\n         * (For IE <=9) Removes the event listeners from the currently-tracked element,\r\n         * if any exists.\r\n         */\r\n        function stopWatchingForValueChange() {\r\n            if (!activeElement) {\r\n                return;\r\n            }\r\n            activeElement.detachEvent('onpropertychange', handlePropertyChange);\r\n            activeElement = null;\r\n            activeElementInst = null;\r\n        }\r\n        /**\r\n         * (For IE <=9) Handles a propertychange event, sending a `change` event if\r\n         * the value of the active element has changed.\r\n         */\r\n        function handlePropertyChange(nativeEvent) {\r\n            if (nativeEvent.propertyName !== 'value') {\r\n                return;\r\n            }\r\n            if (getInstIfValueChanged(activeElementInst)) {\r\n                manualDispatchChangeEvent(nativeEvent);\r\n            }\r\n        }\r\n        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\r\n            if (domEventName === 'focusin') {\r\n                // In IE9, propertychange fires for most input events but is buggy and\r\n                // doesn't fire when text is deleted, but conveniently, selectionchange\r\n                // appears to fire in all of the remaining cases so we catch those and\r\n                // forward the event if the value has changed\r\n                // In either case, we don't want to call the event handler if the value\r\n                // is changed from JS so we redefine a setter for `.value` that updates\r\n                // our activeElementValue variable, allowing us to ignore those changes\r\n                //\r\n                // stopWatching() should be a noop here but we call it just in case we\r\n                // missed a blur event somehow.\r\n                stopWatchingForValueChange();\r\n                startWatchingForValueChange(target, targetInst);\r\n            }\r\n            else if (domEventName === 'focusout') {\r\n                stopWatchingForValueChange();\r\n            }\r\n        } // For IE8 and IE9.\r\n        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {\r\n            if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {\r\n                // On the selectionchange event, the target is just document which isn't\r\n                // helpful for us so just check activeElement instead.\r\n                //\r\n                // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\r\n                // propertychange on the first input event after setting `value` from a\r\n                // script and fires only keydown, keypress, keyup. Catching keyup usually\r\n                // gets it and catching keydown lets us fire an event for the first\r\n                // keystroke if user does a key repeat (it'll be a little delayed: right\r\n                // before the second keystroke). Other input methods (e.g., paste) seem to\r\n                // fire selectionchange normally.\r\n                return getInstIfValueChanged(activeElementInst);\r\n            }\r\n        }\r\n        /**\r\n         * SECTION: handle `click` event\r\n         */\r\n        function shouldUseClickEvent(elem) {\r\n            // Use the `click` event to detect changes to checkbox and radio inputs.\r\n            // This approach works across all browsers, whereas `change` does not fire\r\n            // until `blur` in IE8.\r\n            var nodeName = elem.nodeName;\r\n            return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\r\n        }\r\n        function getTargetInstForClickEvent(domEventName, targetInst) {\r\n            if (domEventName === 'click') {\r\n                return getInstIfValueChanged(targetInst);\r\n            }\r\n        }\r\n        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\r\n            if (domEventName === 'input' || domEventName === 'change') {\r\n                return getInstIfValueChanged(targetInst);\r\n            }\r\n        }\r\n        function handleControlledInputBlur(node) {\r\n            var state = node._wrapperState;\r\n            if (!state || !state.controlled || node.type !== 'number') {\r\n                return;\r\n            }\r\n            {\r\n                // If controlled, assign the value attribute to the current value on blur\r\n                setDefaultValue(node, 'number', node.value);\r\n            }\r\n        }\r\n        /**\r\n         * This plugin creates an `onChange` event that normalizes change events\r\n         * across form elements. This event fires at a time when it's possible to\r\n         * change the element's value without seeing a flicker.\r\n         *\r\n         * Supported elements are:\r\n         * - input (see `isTextInputElement`)\r\n         * - textarea\r\n         * - select\r\n         */\r\n        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n            var getTargetInstFunc, handleEventFunc;\r\n            if (shouldUseChangeEvent(targetNode)) {\r\n                getTargetInstFunc = getTargetInstForChangeEvent;\r\n            }\r\n            else if (isTextInputElement(targetNode)) {\r\n                if (isInputEventSupported) {\r\n                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;\r\n                }\r\n                else {\r\n                    getTargetInstFunc = getTargetInstForInputEventPolyfill;\r\n                    handleEventFunc = handleEventsForInputEventPolyfill;\r\n                }\r\n            }\r\n            else if (shouldUseClickEvent(targetNode)) {\r\n                getTargetInstFunc = getTargetInstForClickEvent;\r\n            }\r\n            if (getTargetInstFunc) {\r\n                var inst = getTargetInstFunc(domEventName, targetInst);\r\n                if (inst) {\r\n                    createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\r\n                    return;\r\n                }\r\n            }\r\n            if (handleEventFunc) {\r\n                handleEventFunc(domEventName, targetNode, targetInst);\r\n            } // When blurring, set the value attribute for number inputs\r\n            if (domEventName === 'focusout') {\r\n                handleControlledInputBlur(targetNode);\r\n            }\r\n        }\r\n        function registerEvents$2() {\r\n            registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);\r\n            registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);\r\n            registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);\r\n            registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);\r\n        }\r\n        /**\r\n         * For almost every interaction we care about, there will be both a top-level\r\n         * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\r\n         * we do not extract duplicate events. However, moving the mouse into the\r\n         * browser from outside will not fire a `mouseout` event. In this case, we use\r\n         * the `mouseover` top-level event.\r\n         */\r\n        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';\r\n            var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';\r\n            if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {\r\n                // If this is an over event with a target, we might have already dispatched\r\n                // the event in the out event of the other target. If this is replayed,\r\n                // then it's because we couldn't dispatch against this target previously\r\n                // so we have to do it now instead.\r\n                var related = nativeEvent.relatedTarget || nativeEvent.fromElement;\r\n                if (related) {\r\n                    // If the related node is managed by React, we can assume that we have\r\n                    // already dispatched the corresponding events during its mouseout.\r\n                    if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            if (!isOutEvent && !isOverEvent) {\r\n                // Must not be a mouse or pointer in or out - ignoring.\r\n                return;\r\n            }\r\n            var win; // TODO: why is this nullable in the types but we read from it?\r\n            if (nativeEventTarget.window === nativeEventTarget) {\r\n                // `nativeEventTarget` is probably a window object.\r\n                win = nativeEventTarget;\r\n            }\r\n            else {\r\n                // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\r\n                var doc = nativeEventTarget.ownerDocument;\r\n                if (doc) {\r\n                    win = doc.defaultView || doc.parentWindow;\r\n                }\r\n                else {\r\n                    win = window;\r\n                }\r\n            }\r\n            var from;\r\n            var to;\r\n            if (isOutEvent) {\r\n                var _related = nativeEvent.relatedTarget || nativeEvent.toElement;\r\n                from = targetInst;\r\n                to = _related ? getClosestInstanceFromNode(_related) : null;\r\n                if (to !== null) {\r\n                    var nearestMounted = getNearestMountedFiber(to);\r\n                    if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\r\n                        to = null;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Moving to a node from outside the window.\r\n                from = null;\r\n                to = targetInst;\r\n            }\r\n            if (from === to) {\r\n                // Nothing pertains to our managed components.\r\n                return;\r\n            }\r\n            var SyntheticEventCtor = SyntheticMouseEvent;\r\n            var leaveEventType = 'onMouseLeave';\r\n            var enterEventType = 'onMouseEnter';\r\n            var eventTypePrefix = 'mouse';\r\n            if (domEventName === 'pointerout' || domEventName === 'pointerover') {\r\n                SyntheticEventCtor = SyntheticPointerEvent;\r\n                leaveEventType = 'onPointerLeave';\r\n                enterEventType = 'onPointerEnter';\r\n                eventTypePrefix = 'pointer';\r\n            }\r\n            var fromNode = from == null ? win : getNodeFromInstance(from);\r\n            var toNode = to == null ? win : getNodeFromInstance(to);\r\n            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);\r\n            leave.target = fromNode;\r\n            leave.relatedTarget = toNode;\r\n            var enter = null; // We should only process this nativeEvent if we are processing\r\n            // the first ancestor. Next time, we will ignore the event.\r\n            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\r\n            if (nativeTargetInst === targetInst) {\r\n                var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);\r\n                enterEvent.target = toNode;\r\n                enterEvent.relatedTarget = fromNode;\r\n                enter = enterEvent;\r\n            }\r\n            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\r\n        }\r\n        /**\r\n         * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n         */\r\n        function is(x, y) {\r\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n            ;\r\n        }\r\n        var objectIs = typeof Object.is === 'function' ? Object.is : is;\r\n        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;\r\n        /**\r\n         * Performs equality by iterating through keys on an object and returning false\r\n         * when any key has values which are not strictly equal between the arguments.\r\n         * Returns true when the values of all keys are strictly equal.\r\n         */\r\n        function shallowEqual(objA, objB) {\r\n            if (objectIs(objA, objB)) {\r\n                return true;\r\n            }\r\n            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\r\n                return false;\r\n            }\r\n            var keysA = Object.keys(objA);\r\n            var keysB = Object.keys(objB);\r\n            if (keysA.length !== keysB.length) {\r\n                return false;\r\n            } // Test for A's keys different from B.\r\n            for (var i = 0; i < keysA.length; i++) {\r\n                if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Given any node return the first leaf node without children.\r\n         *\r\n         * @param {DOMElement|DOMTextNode} node\r\n         * @return {DOMElement|DOMTextNode}\r\n         */\r\n        function getLeafNode(node) {\r\n            while (node && node.firstChild) {\r\n                node = node.firstChild;\r\n            }\r\n            return node;\r\n        }\r\n        /**\r\n         * Get the next sibling within a container. This will walk up the\r\n         * DOM if a node's siblings have been exhausted.\r\n         *\r\n         * @param {DOMElement|DOMTextNode} node\r\n         * @return {?DOMElement|DOMTextNode}\r\n         */\r\n        function getSiblingNode(node) {\r\n            while (node) {\r\n                if (node.nextSibling) {\r\n                    return node.nextSibling;\r\n                }\r\n                node = node.parentNode;\r\n            }\r\n        }\r\n        /**\r\n         * Get object describing the nodes which contain characters at offset.\r\n         *\r\n         * @param {DOMElement|DOMTextNode} root\r\n         * @param {number} offset\r\n         * @return {?object}\r\n         */\r\n        function getNodeForCharacterOffset(root, offset) {\r\n            var node = getLeafNode(root);\r\n            var nodeStart = 0;\r\n            var nodeEnd = 0;\r\n            while (node) {\r\n                if (node.nodeType === TEXT_NODE) {\r\n                    nodeEnd = nodeStart + node.textContent.length;\r\n                    if (nodeStart <= offset && nodeEnd >= offset) {\r\n                        return {\r\n                            node: node,\r\n                            offset: offset - nodeStart\r\n                        };\r\n                    }\r\n                    nodeStart = nodeEnd;\r\n                }\r\n                node = getLeafNode(getSiblingNode(node));\r\n            }\r\n        }\r\n        /**\r\n         * @param {DOMElement} outerNode\r\n         * @return {?object}\r\n         */\r\n        function getOffsets(outerNode) {\r\n            var ownerDocument = outerNode.ownerDocument;\r\n            var win = ownerDocument && ownerDocument.defaultView || window;\r\n            var selection = win.getSelection && win.getSelection();\r\n            if (!selection || selection.rangeCount === 0) {\r\n                return null;\r\n            }\r\n            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\r\n            // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\r\n            // expose properties, triggering a \"Permission denied error\" if any of its\r\n            // properties are accessed. The only seemingly possible way to avoid erroring\r\n            // is to access a property that typically works for non-anonymous divs and\r\n            // catch any error that may otherwise arise. See\r\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\r\n            try {\r\n                /* eslint-disable no-unused-expressions */\r\n                anchorNode.nodeType;\r\n                focusNode.nodeType;\r\n                /* eslint-enable no-unused-expressions */\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\r\n        }\r\n        /**\r\n         * Returns {start, end} where `start` is the character/codepoint index of\r\n         * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\r\n         * `end` is the index of (focusNode, focusOffset).\r\n         *\r\n         * Returns null if you pass in garbage input but we should probably just crash.\r\n         *\r\n         * Exported only for testing.\r\n         */\r\n        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\r\n            var length = 0;\r\n            var start = -1;\r\n            var end = -1;\r\n            var indexWithinAnchor = 0;\r\n            var indexWithinFocus = 0;\r\n            var node = outerNode;\r\n            var parentNode = null;\r\n            outer: while (true) {\r\n                var next = null;\r\n                while (true) {\r\n                    if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\r\n                        start = length + anchorOffset;\r\n                    }\r\n                    if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\r\n                        end = length + focusOffset;\r\n                    }\r\n                    if (node.nodeType === TEXT_NODE) {\r\n                        length += node.nodeValue.length;\r\n                    }\r\n                    if ((next = node.firstChild) === null) {\r\n                        break;\r\n                    } // Moving from `node` to its first child `next`.\r\n                    parentNode = node;\r\n                    node = next;\r\n                }\r\n                while (true) {\r\n                    if (node === outerNode) {\r\n                        // If `outerNode` has children, this is always the second time visiting\r\n                        // it. If it has no children, this is still the first loop, and the only\r\n                        // valid selection is anchorNode and focusNode both equal to this node\r\n                        // and both offsets 0, in which case we will have handled above.\r\n                        break outer;\r\n                    }\r\n                    if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\r\n                        start = length;\r\n                    }\r\n                    if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\r\n                        end = length;\r\n                    }\r\n                    if ((next = node.nextSibling) !== null) {\r\n                        break;\r\n                    }\r\n                    node = parentNode;\r\n                    parentNode = node.parentNode;\r\n                } // Moving from `node` to its next sibling `next`.\r\n                node = next;\r\n            }\r\n            if (start === -1 || end === -1) {\r\n                // This should never happen. (Would happen if the anchor/focus nodes aren't\r\n                // actually inside the passed-in node.)\r\n                return null;\r\n            }\r\n            return {\r\n                start: start,\r\n                end: end\r\n            };\r\n        }\r\n        /**\r\n         * In modern non-IE browsers, we can support both forward and backward\r\n         * selections.\r\n         *\r\n         * Note: IE10+ supports the Selection object, but it does not support\r\n         * the `extend` method, which means that even in modern IE, it's not possible\r\n         * to programmatically create a backward selection. Thus, for all IE\r\n         * versions, we use the old IE API to create our selections.\r\n         *\r\n         * @param {DOMElement|DOMTextNode} node\r\n         * @param {object} offsets\r\n         */\r\n        function setOffsets(node, offsets) {\r\n            var doc = node.ownerDocument || document;\r\n            var win = doc && doc.defaultView || window; // Edge fails with \"Object expected\" in some scenarios.\r\n            // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\r\n            // fails when pasting 100+ items)\r\n            if (!win.getSelection) {\r\n                return;\r\n            }\r\n            var selection = win.getSelection();\r\n            var length = node.textContent.length;\r\n            var start = Math.min(offsets.start, length);\r\n            var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.\r\n            // Flip backward selections, so we can set with a single range.\r\n            if (!selection.extend && start > end) {\r\n                var temp = end;\r\n                end = start;\r\n                start = temp;\r\n            }\r\n            var startMarker = getNodeForCharacterOffset(node, start);\r\n            var endMarker = getNodeForCharacterOffset(node, end);\r\n            if (startMarker && endMarker) {\r\n                if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\r\n                    return;\r\n                }\r\n                var range = doc.createRange();\r\n                range.setStart(startMarker.node, startMarker.offset);\r\n                selection.removeAllRanges();\r\n                if (start > end) {\r\n                    selection.addRange(range);\r\n                    selection.extend(endMarker.node, endMarker.offset);\r\n                }\r\n                else {\r\n                    range.setEnd(endMarker.node, endMarker.offset);\r\n                    selection.addRange(range);\r\n                }\r\n            }\r\n        }\r\n        function isTextNode(node) {\r\n            return node && node.nodeType === TEXT_NODE;\r\n        }\r\n        function containsNode(outerNode, innerNode) {\r\n            if (!outerNode || !innerNode) {\r\n                return false;\r\n            }\r\n            else if (outerNode === innerNode) {\r\n                return true;\r\n            }\r\n            else if (isTextNode(outerNode)) {\r\n                return false;\r\n            }\r\n            else if (isTextNode(innerNode)) {\r\n                return containsNode(outerNode, innerNode.parentNode);\r\n            }\r\n            else if ('contains' in outerNode) {\r\n                return outerNode.contains(innerNode);\r\n            }\r\n            else if (outerNode.compareDocumentPosition) {\r\n                return !!(outerNode.compareDocumentPosition(innerNode) & 16);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        function isInDocument(node) {\r\n            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\r\n        }\r\n        function isSameOriginFrame(iframe) {\r\n            try {\r\n                // Accessing the contentDocument of a HTMLIframeElement can cause the browser\r\n                // to throw, e.g. if it has a cross-origin src attribute.\r\n                // Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\r\n                // iframe.contentDocument.defaultView;\r\n                // A safety way is to access one of the cross origin properties: Window or Location\r\n                // Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\r\n                // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\r\n                return typeof iframe.contentWindow.location.href === 'string';\r\n            }\r\n            catch (err) {\r\n                return false;\r\n            }\r\n        }\r\n        function getActiveElementDeep() {\r\n            var win = window;\r\n            var element = getActiveElement();\r\n            while (element instanceof win.HTMLIFrameElement) {\r\n                if (isSameOriginFrame(element)) {\r\n                    win = element.contentWindow;\r\n                }\r\n                else {\r\n                    return element;\r\n                }\r\n                element = getActiveElement(win.document);\r\n            }\r\n            return element;\r\n        }\r\n        /**\r\n         * @ReactInputSelection: React input selection module. Based on Selection.js,\r\n         * but modified to be suitable for react and has a couple of bug fixes (doesn't\r\n         * assume buttons have range selections allowed).\r\n         * Input selection module for React.\r\n         */\r\n        /**\r\n         * @hasSelectionCapabilities: we get the element types that support selection\r\n         * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\r\n         * and `selectionEnd` rows.\r\n         */\r\n        function hasSelectionCapabilities(elem) {\r\n            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\r\n            return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\r\n        }\r\n        function getSelectionInformation() {\r\n            var focusedElem = getActiveElementDeep();\r\n            return {\r\n                focusedElem: focusedElem,\r\n                selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\r\n            };\r\n        }\r\n        /**\r\n         * @restoreSelection: If any selection information was potentially lost,\r\n         * restore it. This is useful when performing operations that could remove dom\r\n         * nodes and place them back in, resulting in focus being lost.\r\n         */\r\n        function restoreSelection(priorSelectionInformation) {\r\n            var curFocusedElem = getActiveElementDeep();\r\n            var priorFocusedElem = priorSelectionInformation.focusedElem;\r\n            var priorSelectionRange = priorSelectionInformation.selectionRange;\r\n            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\r\n                if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\r\n                    setSelection(priorFocusedElem, priorSelectionRange);\r\n                } // Focusing a node can change the scroll position, which is undesirable\r\n                var ancestors = [];\r\n                var ancestor = priorFocusedElem;\r\n                while (ancestor = ancestor.parentNode) {\r\n                    if (ancestor.nodeType === ELEMENT_NODE) {\r\n                        ancestors.push({\r\n                            element: ancestor,\r\n                            left: ancestor.scrollLeft,\r\n                            top: ancestor.scrollTop\r\n                        });\r\n                    }\r\n                }\r\n                if (typeof priorFocusedElem.focus === 'function') {\r\n                    priorFocusedElem.focus();\r\n                }\r\n                for (var i = 0; i < ancestors.length; i++) {\r\n                    var info = ancestors[i];\r\n                    info.element.scrollLeft = info.left;\r\n                    info.element.scrollTop = info.top;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * @getSelection: Gets the selection bounds of a focused textarea, input or\r\n         * contentEditable node.\r\n         * -@input: Look up selection bounds of this input\r\n         * -@return {start: selectionStart, end: selectionEnd}\r\n         */\r\n        function getSelection(input) {\r\n            var selection;\r\n            if ('selectionStart' in input) {\r\n                // Modern browser with input or textarea.\r\n                selection = {\r\n                    start: input.selectionStart,\r\n                    end: input.selectionEnd\r\n                };\r\n            }\r\n            else {\r\n                // Content editable or old IE textarea.\r\n                selection = getOffsets(input);\r\n            }\r\n            return selection || {\r\n                start: 0,\r\n                end: 0\r\n            };\r\n        }\r\n        /**\r\n         * @setSelection: Sets the selection bounds of a textarea or input and focuses\r\n         * the input.\r\n         * -@input     Set selection bounds of this input or textarea\r\n         * -@offsets   Object of same form that is returned from get*\r\n         */\r\n        function setSelection(input, offsets) {\r\n            var start = offsets.start;\r\n            var end = offsets.end;\r\n            if (end === undefined) {\r\n                end = start;\r\n            }\r\n            if ('selectionStart' in input) {\r\n                input.selectionStart = start;\r\n                input.selectionEnd = Math.min(end, input.value.length);\r\n            }\r\n            else {\r\n                setOffsets(input, offsets);\r\n            }\r\n        }\r\n        var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\r\n        function registerEvents$3() {\r\n            registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);\r\n        }\r\n        var activeElement$1 = null;\r\n        var activeElementInst$1 = null;\r\n        var lastSelection = null;\r\n        var mouseDown = false;\r\n        /**\r\n         * Get an object which is a unique representation of the current selection.\r\n         *\r\n         * The return value will not be consistent across nodes or browsers, but\r\n         * two identical selections on the same node will return identical objects.\r\n         */\r\n        function getSelection$1(node) {\r\n            if ('selectionStart' in node && hasSelectionCapabilities(node)) {\r\n                return {\r\n                    start: node.selectionStart,\r\n                    end: node.selectionEnd\r\n                };\r\n            }\r\n            else {\r\n                var win = node.ownerDocument && node.ownerDocument.defaultView || window;\r\n                var selection = win.getSelection();\r\n                return {\r\n                    anchorNode: selection.anchorNode,\r\n                    anchorOffset: selection.anchorOffset,\r\n                    focusNode: selection.focusNode,\r\n                    focusOffset: selection.focusOffset\r\n                };\r\n            }\r\n        }\r\n        /**\r\n         * Get document associated with the event target.\r\n         */\r\n        function getEventTargetDocument(eventTarget) {\r\n            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\r\n        }\r\n        /**\r\n         * Poll selection to see whether it's changed.\r\n         *\r\n         * @param {object} nativeEvent\r\n         * @param {object} nativeEventTarget\r\n         * @return {?SyntheticEvent}\r\n         */\r\n        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\r\n            // Ensure we have the right element, and that the user is not dragging a\r\n            // selection (this matches native `select` event behavior). In HTML5, select\r\n            // fires only on input and textarea thus if there's no focused element we\r\n            // won't dispatch.\r\n            var doc = getEventTargetDocument(nativeEventTarget);\r\n            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\r\n                return;\r\n            } // Only fire when selection has actually changed.\r\n            var currentSelection = getSelection$1(activeElement$1);\r\n            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\r\n                lastSelection = currentSelection;\r\n                var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');\r\n                if (listeners.length > 0) {\r\n                    var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);\r\n                    dispatchQueue.push({\r\n                        event: event,\r\n                        listeners: listeners\r\n                    });\r\n                    event.target = activeElement$1;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * This plugin creates an `onSelect` event that normalizes select events\r\n         * across form elements.\r\n         *\r\n         * Supported elements are:\r\n         * - input (see `isTextInputElement`)\r\n         * - textarea\r\n         * - contentEditable\r\n         *\r\n         * This differs from native browser implementations in the following ways:\r\n         * - Fires on contentEditable fields as well as inputs.\r\n         * - Fires for collapsed selection.\r\n         * - Fires after user input.\r\n         */\r\n        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n            switch (domEventName) {\r\n                // Track the input node that has focus.\r\n                case 'focusin':\r\n                    if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\r\n                        activeElement$1 = targetNode;\r\n                        activeElementInst$1 = targetInst;\r\n                        lastSelection = null;\r\n                    }\r\n                    break;\r\n                case 'focusout':\r\n                    activeElement$1 = null;\r\n                    activeElementInst$1 = null;\r\n                    lastSelection = null;\r\n                    break;\r\n                // Don't fire the event while the user is dragging. This matches the\r\n                // semantics of the native select event.\r\n                case 'mousedown':\r\n                    mouseDown = true;\r\n                    break;\r\n                case 'contextmenu':\r\n                case 'mouseup':\r\n                case 'dragend':\r\n                    mouseDown = false;\r\n                    constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n                    break;\r\n                // Chrome and IE fire non-standard event when selection is changed (and\r\n                // sometimes when it hasn't). IE's event fires out of order with respect\r\n                // to key and input events on deletion, so we discard it.\r\n                //\r\n                // Firefox doesn't support selectionchange, so check selection status\r\n                // after each key entry. The selection changes after keydown and before\r\n                // keyup, but we check on keydown as well in the case of holding down a\r\n                // key, when multiple keydown events are fired but only one keyup is.\r\n                // This is also our approach for IE handling, for the reason above.\r\n                case 'selectionchange':\r\n                    if (skipSelectionChangeEvent) {\r\n                        break;\r\n                    }\r\n                // falls through\r\n                case 'keydown':\r\n                case 'keyup':\r\n                    constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n            }\r\n        }\r\n        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            var reactName = topLevelEventsToReactNames.get(domEventName);\r\n            if (reactName === undefined) {\r\n                return;\r\n            }\r\n            var SyntheticEventCtor = SyntheticEvent;\r\n            var reactEventType = domEventName;\r\n            switch (domEventName) {\r\n                case 'keypress':\r\n                    // Firefox creates a keypress event for function keys too. This removes\r\n                    // the unwanted keypress events. Enter is however both printable and\r\n                    // non-printable. One would expect Tab to be as well (but it isn't).\r\n                    if (getEventCharCode(nativeEvent) === 0) {\r\n                        return;\r\n                    }\r\n                /* falls through */\r\n                case 'keydown':\r\n                case 'keyup':\r\n                    SyntheticEventCtor = SyntheticKeyboardEvent;\r\n                    break;\r\n                case 'focusin':\r\n                    reactEventType = 'focus';\r\n                    SyntheticEventCtor = SyntheticFocusEvent;\r\n                    break;\r\n                case 'focusout':\r\n                    reactEventType = 'blur';\r\n                    SyntheticEventCtor = SyntheticFocusEvent;\r\n                    break;\r\n                case 'beforeblur':\r\n                case 'afterblur':\r\n                    SyntheticEventCtor = SyntheticFocusEvent;\r\n                    break;\r\n                case 'click':\r\n                    // Firefox creates a click event on right mouse clicks. This removes the\r\n                    // unwanted click events.\r\n                    if (nativeEvent.button === 2) {\r\n                        return;\r\n                    }\r\n                /* falls through */\r\n                case 'auxclick':\r\n                case 'dblclick':\r\n                case 'mousedown':\r\n                case 'mousemove':\r\n                case 'mouseup': // TODO: Disabled elements should not respond to mouse events\r\n                /* falls through */\r\n                case 'mouseout':\r\n                case 'mouseover':\r\n                case 'contextmenu':\r\n                    SyntheticEventCtor = SyntheticMouseEvent;\r\n                    break;\r\n                case 'drag':\r\n                case 'dragend':\r\n                case 'dragenter':\r\n                case 'dragexit':\r\n                case 'dragleave':\r\n                case 'dragover':\r\n                case 'dragstart':\r\n                case 'drop':\r\n                    SyntheticEventCtor = SyntheticDragEvent;\r\n                    break;\r\n                case 'touchcancel':\r\n                case 'touchend':\r\n                case 'touchmove':\r\n                case 'touchstart':\r\n                    SyntheticEventCtor = SyntheticTouchEvent;\r\n                    break;\r\n                case ANIMATION_END:\r\n                case ANIMATION_ITERATION:\r\n                case ANIMATION_START:\r\n                    SyntheticEventCtor = SyntheticAnimationEvent;\r\n                    break;\r\n                case TRANSITION_END:\r\n                    SyntheticEventCtor = SyntheticTransitionEvent;\r\n                    break;\r\n                case 'scroll':\r\n                    SyntheticEventCtor = SyntheticUIEvent;\r\n                    break;\r\n                case 'wheel':\r\n                    SyntheticEventCtor = SyntheticWheelEvent;\r\n                    break;\r\n                case 'copy':\r\n                case 'cut':\r\n                case 'paste':\r\n                    SyntheticEventCtor = SyntheticClipboardEvent;\r\n                    break;\r\n                case 'gotpointercapture':\r\n                case 'lostpointercapture':\r\n                case 'pointercancel':\r\n                case 'pointerdown':\r\n                case 'pointermove':\r\n                case 'pointerout':\r\n                case 'pointerover':\r\n                case 'pointerup':\r\n                    SyntheticEventCtor = SyntheticPointerEvent;\r\n                    break;\r\n            }\r\n            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n            {\r\n                // Some events don't bubble in the browser.\r\n                // In the past, React has always bubbled them, but this can be surprising.\r\n                // We're going to try aligning closer to the browser behavior by not bubbling\r\n                // them in React either. We'll start by not bubbling onScroll, and then expand.\r\n                var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from\r\n                    // nonDelegatedEvents list in DOMPluginEventSystem.\r\n                    // Then we can remove this special list.\r\n                    // This is a breaking change that can wait until React 18.\r\n                    domEventName === 'scroll';\r\n                var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\r\n                if (_listeners.length > 0) {\r\n                    // Intentionally create event lazily.\r\n                    var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\r\n                    dispatchQueue.push({\r\n                        event: _event,\r\n                        listeners: _listeners\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // TODO: remove top-level side effect.\r\n        registerSimpleEvents();\r\n        registerEvents$2();\r\n        registerEvents$1();\r\n        registerEvents$3();\r\n        registerEvents();\r\n        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n            // TODO: we should remove the concept of a \"SimpleEventPlugin\".\r\n            // This is the basic functionality of the event system. All\r\n            // the other plugins are essentially polyfills. So the plugin\r\n            // should probably be inlined somewhere and have its logic\r\n            // be core the to event system. This would potentially allow\r\n            // us to ship builds of React without the polyfilled plugins below.\r\n            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\r\n            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the\r\n            // event's native \"bubble\" phase, which means that we're\r\n            // not in the capture phase. That's because we emulate\r\n            // the capture phase here still. This is a trade-off,\r\n            // because in an ideal world we would not emulate and use\r\n            // the phases properly, like we do with the SimpleEvent\r\n            // plugin. However, the plugins below either expect\r\n            // emulation (EnterLeave) or use state localized to that\r\n            // plugin (BeforeInput, Change, Select). The state in\r\n            // these modules complicates things, as you'll essentially\r\n            // get the case where the capture phase event might change\r\n            // state, only for the following bubble event to come in\r\n            // later and not trigger anything as the state now\r\n            // invalidates the heuristics of the event plugin. We\r\n            // could alter all these plugins to work in such ways, but\r\n            // that might cause other unknown side-effects that we\r\n            // can't forsee right now.\r\n            if (shouldProcessPolyfillPlugins) {\r\n                extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\r\n                extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n            }\r\n        } // List of events that need to be individually attached to media elements.\r\n        var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather\r\n        // set them on the actual target element itself. This is primarily\r\n        // because these events do not consistently bubble in the DOM.\r\n        var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));\r\n        function executeDispatch(event, listener, currentTarget) {\r\n            var type = event.type || 'unknown-event';\r\n            event.currentTarget = currentTarget;\r\n            invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\r\n            event.currentTarget = null;\r\n        }\r\n        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\r\n            var previousInstance;\r\n            if (inCapturePhase) {\r\n                for (var i = dispatchListeners.length - 1; i >= 0; i--) {\r\n                    var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;\r\n                    if (instance !== previousInstance && event.isPropagationStopped()) {\r\n                        return;\r\n                    }\r\n                    executeDispatch(event, listener, currentTarget);\r\n                    previousInstance = instance;\r\n                }\r\n            }\r\n            else {\r\n                for (var _i = 0; _i < dispatchListeners.length; _i++) {\r\n                    var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;\r\n                    if (_instance !== previousInstance && event.isPropagationStopped()) {\r\n                        return;\r\n                    }\r\n                    executeDispatch(event, _listener, _currentTarget);\r\n                    previousInstance = _instance;\r\n                }\r\n            }\r\n        }\r\n        function processDispatchQueue(dispatchQueue, eventSystemFlags) {\r\n            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n            for (var i = 0; i < dispatchQueue.length; i++) {\r\n                var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;\r\n                processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.\r\n            } // This would be a good time to rethrow if any of the event handlers threw.\r\n            rethrowCaughtError();\r\n        }\r\n        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\r\n            var nativeEventTarget = getEventTarget(nativeEvent);\r\n            var dispatchQueue = [];\r\n            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\r\n            processDispatchQueue(dispatchQueue, eventSystemFlags);\r\n        }\r\n        function listenToNonDelegatedEvent(domEventName, targetElement) {\r\n            var isCapturePhaseListener = false;\r\n            var listenerSet = getEventListenerSet(targetElement);\r\n            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\r\n            if (!listenerSet.has(listenerSetKey)) {\r\n                addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\r\n                listenerSet.add(listenerSetKey);\r\n            }\r\n        }\r\n        var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);\r\n        function listenToAllSupportedEvents(rootContainerElement) {\r\n            {\r\n                if (rootContainerElement[listeningMarker]) {\r\n                    // Performance optimization: don't iterate through events\r\n                    // for the same portal container or root node more than once.\r\n                    // TODO: once we remove the flag, we may be able to also\r\n                    // remove some of the bookkeeping maps used for laziness.\r\n                    return;\r\n                }\r\n                rootContainerElement[listeningMarker] = true;\r\n                allNativeEvents.forEach(function (domEventName) {\r\n                    if (!nonDelegatedEvents.has(domEventName)) {\r\n                        listenToNativeEvent(domEventName, false, rootContainerElement, null);\r\n                    }\r\n                    listenToNativeEvent(domEventName, true, rootContainerElement, null);\r\n                });\r\n            }\r\n        }\r\n        function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {\r\n            var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\r\n            var target = rootContainerElement; // selectionchange needs to be attached to the document\r\n            // otherwise it won't capture incoming events that are only\r\n            // triggered on the document directly.\r\n            if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {\r\n                target = rootContainerElement.ownerDocument;\r\n            } // If the event can be delegated (or is capture phase), we can\r\n            // register it to the root container. Otherwise, we should\r\n            // register the event to the target element and mark it as\r\n            // a non-delegated event.\r\n            if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {\r\n                // For all non-delegated events, apart from scroll, we attach\r\n                // their event listeners to the respective elements that their\r\n                // events fire on. That means we can skip this step, as event\r\n                // listener has already been added previously. However, we\r\n                // special case the scroll event because the reality is that any\r\n                // element can scroll.\r\n                // TODO: ideally, we'd eventually apply the same logic to all\r\n                // events from the nonDelegatedEvents list. Then we can remove\r\n                // this special case and use the same logic for all events.\r\n                if (domEventName !== 'scroll') {\r\n                    return;\r\n                }\r\n                eventSystemFlags |= IS_NON_DELEGATED;\r\n                target = targetElement;\r\n            }\r\n            var listenerSet = getEventListenerSet(target);\r\n            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then\r\n            // we need to trap an event listener onto the target.\r\n            if (!listenerSet.has(listenerSetKey)) {\r\n                if (isCapturePhaseListener) {\r\n                    eventSystemFlags |= IS_CAPTURE_PHASE;\r\n                }\r\n                addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\r\n                listenerSet.add(listenerSetKey);\r\n            }\r\n        }\r\n        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\r\n            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be\r\n            // active and not passive.\r\n            var isPassiveListener = undefined;\r\n            if (passiveBrowserEventsSupported) {\r\n                // Browsers introduced an intervention, making these events\r\n                // passive by default on document. React doesn't bind them\r\n                // to document anymore, but changing this now would undo\r\n                // the performance wins from the change. So we emulate\r\n                // the existing behavior manually on the roots now.\r\n                // https://github.com/facebook/react/issues/19651\r\n                if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {\r\n                    isPassiveListener = true;\r\n                }\r\n            }\r\n            targetContainer = targetContainer;\r\n            var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we\r\n            if (isCapturePhaseListener) {\r\n                if (isPassiveListener !== undefined) {\r\n                    unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\r\n                }\r\n                else {\r\n                    unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\r\n                }\r\n            }\r\n            else {\r\n                if (isPassiveListener !== undefined) {\r\n                    unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\r\n                }\r\n                else {\r\n                    unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\r\n                }\r\n            }\r\n        }\r\n        function isMatchingRootContainer(grandContainer, targetContainer) {\r\n            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\r\n        }\r\n        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\r\n            var ancestorInst = targetInst;\r\n            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\r\n                var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we\r\n                if (targetInst !== null) {\r\n                    // The below logic attempts to work out if we need to change\r\n                    // the target fiber to a different ancestor. We had similar logic\r\n                    // in the legacy event system, except the big difference between\r\n                    // systems is that the modern event system now has an event listener\r\n                    // attached to each React Root and React Portal Root. Together,\r\n                    // the DOM nodes representing these roots are the \"rootContainer\".\r\n                    // To figure out which ancestor instance we should use, we traverse\r\n                    // up the fiber tree from the target instance and attempt to find\r\n                    // root boundaries that match that of our current \"rootContainer\".\r\n                    // If we find that \"rootContainer\", we find the parent fiber\r\n                    // sub-tree for that root and make that our ancestor instance.\r\n                    var node = targetInst;\r\n                    mainLoop: while (true) {\r\n                        if (node === null) {\r\n                            return;\r\n                        }\r\n                        var nodeTag = node.tag;\r\n                        if (nodeTag === HostRoot || nodeTag === HostPortal) {\r\n                            var container = node.stateNode.containerInfo;\r\n                            if (isMatchingRootContainer(container, targetContainerNode)) {\r\n                                break;\r\n                            }\r\n                            if (nodeTag === HostPortal) {\r\n                                // The target is a portal, but it's not the rootContainer we're looking for.\r\n                                // Normally portals handle their own events all the way down to the root.\r\n                                // So we should be able to stop now. However, we don't know if this portal\r\n                                // was part of *our* root.\r\n                                var grandNode = node.return;\r\n                                while (grandNode !== null) {\r\n                                    var grandTag = grandNode.tag;\r\n                                    if (grandTag === HostRoot || grandTag === HostPortal) {\r\n                                        var grandContainer = grandNode.stateNode.containerInfo;\r\n                                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\r\n                                            // This is the rootContainer we're looking for and we found it as\r\n                                            // a parent of the Portal. That means we can ignore it because the\r\n                                            // Portal will bubble through to us.\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                    grandNode = grandNode.return;\r\n                                }\r\n                            } // Now we need to find it's corresponding host fiber in the other\r\n                            // tree. To do this we can use getClosestInstanceFromNode, but we\r\n                            // need to validate that the fiber is a host instance, otherwise\r\n                            // we need to traverse up through the DOM till we find the correct\r\n                            // node that is from the other tree.\r\n                            while (container !== null) {\r\n                                var parentNode = getClosestInstanceFromNode(container);\r\n                                if (parentNode === null) {\r\n                                    return;\r\n                                }\r\n                                var parentTag = parentNode.tag;\r\n                                if (parentTag === HostComponent || parentTag === HostText) {\r\n                                    node = ancestorInst = parentNode;\r\n                                    continue mainLoop;\r\n                                }\r\n                                container = container.parentNode;\r\n                            }\r\n                        }\r\n                        node = node.return;\r\n                    }\r\n                }\r\n            }\r\n            batchedEventUpdates(function () {\r\n                return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\r\n            });\r\n        }\r\n        function createDispatchListener(instance, listener, currentTarget) {\r\n            return {\r\n                instance: instance,\r\n                listener: listener,\r\n                currentTarget: currentTarget\r\n            };\r\n        }\r\n        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {\r\n            var captureName = reactName !== null ? reactName + 'Capture' : null;\r\n            var reactEventName = inCapturePhase ? captureName : reactName;\r\n            var listeners = [];\r\n            var instance = targetFiber;\r\n            var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.\r\n            while (instance !== null) {\r\n                var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)\r\n                if (tag === HostComponent && stateNode !== null) {\r\n                    lastHostComponent = stateNode; // createEventHandle listeners\r\n                    if (reactEventName !== null) {\r\n                        var listener = getListener(instance, reactEventName);\r\n                        if (listener != null) {\r\n                            listeners.push(createDispatchListener(instance, listener, lastHostComponent));\r\n                        }\r\n                    }\r\n                } // If we are only accumulating events for the target, then we don't\r\n                // continue to propagate through the React fiber tree to find other\r\n                // listeners.\r\n                if (accumulateTargetOnly) {\r\n                    break;\r\n                }\r\n                instance = instance.return;\r\n            }\r\n            return listeners;\r\n        } // We should only use this function for:\r\n        // - BeforeInputEventPlugin\r\n        // - ChangeEventPlugin\r\n        // - SelectEventPlugin\r\n        // This is because we only process these plugins\r\n        // in the bubble phase, so we need to accumulate two\r\n        // phase event listeners (via emulation).\r\n        function accumulateTwoPhaseListeners(targetFiber, reactName) {\r\n            var captureName = reactName + 'Capture';\r\n            var listeners = [];\r\n            var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.\r\n            while (instance !== null) {\r\n                var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)\r\n                if (tag === HostComponent && stateNode !== null) {\r\n                    var currentTarget = stateNode;\r\n                    var captureListener = getListener(instance, captureName);\r\n                    if (captureListener != null) {\r\n                        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\r\n                    }\r\n                    var bubbleListener = getListener(instance, reactName);\r\n                    if (bubbleListener != null) {\r\n                        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\r\n                    }\r\n                }\r\n                instance = instance.return;\r\n            }\r\n            return listeners;\r\n        }\r\n        function getParent(inst) {\r\n            if (inst === null) {\r\n                return null;\r\n            }\r\n            do {\r\n                inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.\r\n                // That is depending on if we want nested subtrees (layers) to bubble\r\n                // events to their parent. We could also go through parentNode on the\r\n                // host node but that wouldn't work for React Native and doesn't let us\r\n                // do the portal feature.\r\n            } while (inst && inst.tag !== HostComponent);\r\n            if (inst) {\r\n                return inst;\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * Return the lowest common ancestor of A and B, or null if they are in\r\n         * different trees.\r\n         */\r\n        function getLowestCommonAncestor(instA, instB) {\r\n            var nodeA = instA;\r\n            var nodeB = instB;\r\n            var depthA = 0;\r\n            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {\r\n                depthA++;\r\n            }\r\n            var depthB = 0;\r\n            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {\r\n                depthB++;\r\n            } // If A is deeper, crawl up.\r\n            while (depthA - depthB > 0) {\r\n                nodeA = getParent(nodeA);\r\n                depthA--;\r\n            } // If B is deeper, crawl up.\r\n            while (depthB - depthA > 0) {\r\n                nodeB = getParent(nodeB);\r\n                depthB--;\r\n            } // Walk in lockstep until we find a match.\r\n            var depth = depthA;\r\n            while (depth--) {\r\n                if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\r\n                    return nodeA;\r\n                }\r\n                nodeA = getParent(nodeA);\r\n                nodeB = getParent(nodeB);\r\n            }\r\n            return null;\r\n        }\r\n        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\r\n            var registrationName = event._reactName;\r\n            var listeners = [];\r\n            var instance = target;\r\n            while (instance !== null) {\r\n                if (instance === common) {\r\n                    break;\r\n                }\r\n                var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;\r\n                if (alternate !== null && alternate === common) {\r\n                    break;\r\n                }\r\n                if (tag === HostComponent && stateNode !== null) {\r\n                    var currentTarget = stateNode;\r\n                    if (inCapturePhase) {\r\n                        var captureListener = getListener(instance, registrationName);\r\n                        if (captureListener != null) {\r\n                            listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\r\n                        }\r\n                    }\r\n                    else if (!inCapturePhase) {\r\n                        var bubbleListener = getListener(instance, registrationName);\r\n                        if (bubbleListener != null) {\r\n                            listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\r\n                        }\r\n                    }\r\n                }\r\n                instance = instance.return;\r\n            }\r\n            if (listeners.length !== 0) {\r\n                dispatchQueue.push({\r\n                    event: event,\r\n                    listeners: listeners\r\n                });\r\n            }\r\n        } // We should only use this function for:\r\n        // - EnterLeaveEventPlugin\r\n        // This is because we only process this plugin\r\n        // in the bubble phase, so we need to accumulate two\r\n        // phase event listeners.\r\n        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\r\n            var common = from && to ? getLowestCommonAncestor(from, to) : null;\r\n            if (from !== null) {\r\n                accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\r\n            }\r\n            if (to !== null && enterEvent !== null) {\r\n                accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\r\n            }\r\n        }\r\n        function getListenerSetKey(domEventName, capture) {\r\n            return domEventName + \"__\" + (capture ? 'capture' : 'bubble');\r\n        }\r\n        var didWarnInvalidHydration = false;\r\n        var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\r\n        var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\r\n        var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\r\n        var AUTOFOCUS = 'autoFocus';\r\n        var CHILDREN = 'children';\r\n        var STYLE = 'style';\r\n        var HTML$1 = '__html';\r\n        var HTML_NAMESPACE$1 = Namespaces.html;\r\n        var warnedUnknownTags;\r\n        var suppressHydrationWarning;\r\n        var validatePropertiesInDevelopment;\r\n        var warnForTextDifference;\r\n        var warnForPropDifference;\r\n        var warnForExtraAttributes;\r\n        var warnForInvalidEventListener;\r\n        var canDiffStyleForHydrationWarning;\r\n        var normalizeMarkupForTextOrAttribute;\r\n        var normalizeHTML;\r\n        {\r\n            warnedUnknownTags = {\r\n                // There are working polyfills for <dialog>. Let people use it.\r\n                dialog: true,\r\n                // Electron ships a custom <webview> tag to display external web content in\r\n                // an isolated frame and process.\r\n                // This tag is not present in non Electron environments such as JSDom which\r\n                // is often used for testing purposes.\r\n                // @see https://electronjs.org/docs/api/webview-tag\r\n                webview: true\r\n            };\r\n            validatePropertiesInDevelopment = function (type, props) {\r\n                validateProperties(type, props);\r\n                validateProperties$1(type, props);\r\n                validateProperties$2(type, props, {\r\n                    registrationNameDependencies: registrationNameDependencies,\r\n                    possibleRegistrationNames: possibleRegistrationNames\r\n                });\r\n            }; // IE 11 parses & normalizes the style attribute as opposed to other\r\n            // browsers. It adds spaces and sorts the properties in some\r\n            // non-alphabetical order. Handling that would require sorting CSS\r\n            // properties in the client & server versions or applying\r\n            // `expectedStyle` to a temporary DOM node to read its `style` attribute\r\n            // normalized. Since it only affects IE, we're skipping style warnings\r\n            // in that browser completely in favor of doing all that work.\r\n            // See https://github.com/facebook/react/issues/11807\r\n            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.\r\n            // It also can turn \\u0000 into \\uFFFD inside attributes.\r\n            // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\r\n            // If we have a mismatch, it might be caused by that.\r\n            // We will still patch up in this case but not fire the warning.\r\n            var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\r\n            var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\r\n            normalizeMarkupForTextOrAttribute = function (markup) {\r\n                var markupString = typeof markup === 'string' ? markup : '' + markup;\r\n                return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\r\n            };\r\n            warnForTextDifference = function (serverText, clientText) {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\r\n                var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\r\n                if (normalizedServerText === normalizedClientText) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\r\n            };\r\n            warnForPropDifference = function (propName, serverValue, clientValue) {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\r\n                var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\r\n                if (normalizedServerValue === normalizedClientValue) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\r\n            };\r\n            warnForExtraAttributes = function (attributeNames) {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                var names = [];\r\n                attributeNames.forEach(function (name) {\r\n                    names.push(name);\r\n                });\r\n                error('Extra attributes from the server: %s', names);\r\n            };\r\n            warnForInvalidEventListener = function (registrationName, listener) {\r\n                if (listener === false) {\r\n                    error('Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);\r\n                }\r\n                else {\r\n                    error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);\r\n                }\r\n            }; // Parse the HTML and read it back to normalize the HTML string so that it\r\n            // can be used for comparison.\r\n            normalizeHTML = function (parent, html) {\r\n                // We could have created a separate document here to avoid\r\n                // re-initializing custom elements if they exist. But this breaks\r\n                // how <noscript> is being handled. So we use the same document.\r\n                // See the discussion in https://github.com/facebook/react/pull/11157.\r\n                var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\r\n                testElement.innerHTML = html;\r\n                return testElement.innerHTML;\r\n            };\r\n        }\r\n        function getOwnerDocumentFromRootContainer(rootContainerElement) {\r\n            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\r\n        }\r\n        function noop() { }\r\n        function trapClickOnNonInteractiveElement(node) {\r\n            // Mobile Safari does not fire properly bubble click events on\r\n            // non-interactive elements, which means delegated click listeners do not\r\n            // fire. The workaround for this bug involves attaching an empty click\r\n            // listener on the target node.\r\n            // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n            // Just set it using the onclick property so that we don't have to manage any\r\n            // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n            // removed.\r\n            // TODO: Only do this for the relevant Safaris maybe?\r\n            node.onclick = noop;\r\n        }\r\n        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\r\n            for (var propKey in nextProps) {\r\n                if (!nextProps.hasOwnProperty(propKey)) {\r\n                    continue;\r\n                }\r\n                var nextProp = nextProps[propKey];\r\n                if (propKey === STYLE) {\r\n                    {\r\n                        if (nextProp) {\r\n                            // Freeze the next style object so that we can assume it won't be\r\n                            // mutated. We have already warned for this in the past.\r\n                            Object.freeze(nextProp);\r\n                        }\r\n                    } // Relies on `updateStylesByID` not mutating `styleUpdates`.\r\n                    setValueForStyles(domElement, nextProp);\r\n                }\r\n                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\r\n                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\r\n                    if (nextHtml != null) {\r\n                        setInnerHTML(domElement, nextHtml);\r\n                    }\r\n                }\r\n                else if (propKey === CHILDREN) {\r\n                    if (typeof nextProp === 'string') {\r\n                        // Avoid setting initial textContent when the text is empty. In IE11 setting\r\n                        // textContent on a <textarea> will cause the placeholder to not\r\n                        // show within the <textarea> until it has been focused and blurred again.\r\n                        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\r\n                        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\r\n                        if (canSetTextContent) {\r\n                            setTextContent(domElement, nextProp);\r\n                        }\r\n                    }\r\n                    else if (typeof nextProp === 'number') {\r\n                        setTextContent(domElement, '' + nextProp);\r\n                    }\r\n                }\r\n                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\r\n                    ;\r\n                else if (propKey === AUTOFOCUS)\r\n                    ;\r\n                else if (registrationNameDependencies.hasOwnProperty(propKey)) {\r\n                    if (nextProp != null) {\r\n                        if (typeof nextProp !== 'function') {\r\n                            warnForInvalidEventListener(propKey, nextProp);\r\n                        }\r\n                        if (propKey === 'onScroll') {\r\n                            listenToNonDelegatedEvent('scroll', domElement);\r\n                        }\r\n                    }\r\n                }\r\n                else if (nextProp != null) {\r\n                    setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\r\n                }\r\n            }\r\n        }\r\n        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\r\n            // TODO: Handle wasCustomComponentTag\r\n            for (var i = 0; i < updatePayload.length; i += 2) {\r\n                var propKey = updatePayload[i];\r\n                var propValue = updatePayload[i + 1];\r\n                if (propKey === STYLE) {\r\n                    setValueForStyles(domElement, propValue);\r\n                }\r\n                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\r\n                    setInnerHTML(domElement, propValue);\r\n                }\r\n                else if (propKey === CHILDREN) {\r\n                    setTextContent(domElement, propValue);\r\n                }\r\n                else {\r\n                    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\r\n                }\r\n            }\r\n        }\r\n        function createElement(type, props, rootContainerElement, parentNamespace) {\r\n            var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML\r\n            // tags get no namespace.\r\n            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\r\n            var domElement;\r\n            var namespaceURI = parentNamespace;\r\n            if (namespaceURI === HTML_NAMESPACE$1) {\r\n                namespaceURI = getIntrinsicNamespace(type);\r\n            }\r\n            if (namespaceURI === HTML_NAMESPACE$1) {\r\n                {\r\n                    isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to\r\n                    // allow <SVG> or <mATH>.\r\n                    if (!isCustomComponentTag && type !== type.toLowerCase()) {\r\n                        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);\r\n                    }\r\n                }\r\n                if (type === 'script') {\r\n                    // Create the script via .innerHTML so its \"parser-inserted\" flag is\r\n                    // set to true and it does not execute\r\n                    var div = ownerDocument.createElement('div');\r\n                    div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\r\n                    // This is guaranteed to yield a script element.\r\n                    var firstChild = div.firstChild;\r\n                    domElement = div.removeChild(firstChild);\r\n                }\r\n                else if (typeof props.is === 'string') {\r\n                    // $FlowIssue `createElement` should be updated for Web Components\r\n                    domElement = ownerDocument.createElement(type, {\r\n                        is: props.is\r\n                    });\r\n                }\r\n                else {\r\n                    // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\r\n                    // See discussion in https://github.com/facebook/react/pull/6896\r\n                    // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\r\n                    domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\r\n                    // attributes on `select`s needs to be added before `option`s are inserted.\r\n                    // This prevents:\r\n                    // - a bug where the `select` does not scroll to the correct option because singular\r\n                    //  `select` elements automatically pick the first item #13222\r\n                    // - a bug where the `select` set the first item as selected despite the `size` attribute #14239\r\n                    // See https://github.com/facebook/react/issues/13222\r\n                    // and https://github.com/facebook/react/issues/14239\r\n                    if (type === 'select') {\r\n                        var node = domElement;\r\n                        if (props.multiple) {\r\n                            node.multiple = true;\r\n                        }\r\n                        else if (props.size) {\r\n                            // Setting a size greater than 1 causes a select to behave like `multiple=true`, where\r\n                            // it is possible that no option is selected.\r\n                            //\r\n                            // This is only necessary when a select in \"single selection mode\".\r\n                            node.size = props.size;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                domElement = ownerDocument.createElementNS(namespaceURI, type);\r\n            }\r\n            {\r\n                if (namespaceURI === HTML_NAMESPACE$1) {\r\n                    if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\r\n                        warnedUnknownTags[type] = true;\r\n                        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\r\n                    }\r\n                }\r\n            }\r\n            return domElement;\r\n        }\r\n        function createTextNode(text, rootContainerElement) {\r\n            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\r\n        }\r\n        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\r\n            var isCustomComponentTag = isCustomComponent(tag, rawProps);\r\n            {\r\n                validatePropertiesInDevelopment(tag, rawProps);\r\n            } // TODO: Make sure that we check isMounted before firing any of these events.\r\n            var props;\r\n            switch (tag) {\r\n                case 'dialog':\r\n                    listenToNonDelegatedEvent('cancel', domElement);\r\n                    listenToNonDelegatedEvent('close', domElement);\r\n                    props = rawProps;\r\n                    break;\r\n                case 'iframe':\r\n                case 'object':\r\n                case 'embed':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the load event.\r\n                    listenToNonDelegatedEvent('load', domElement);\r\n                    props = rawProps;\r\n                    break;\r\n                case 'video':\r\n                case 'audio':\r\n                    // We listen to these events in case to ensure emulated bubble\r\n                    // listeners still fire for all the media events.\r\n                    for (var i = 0; i < mediaEventTypes.length; i++) {\r\n                        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\r\n                    }\r\n                    props = rawProps;\r\n                    break;\r\n                case 'source':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the error event.\r\n                    listenToNonDelegatedEvent('error', domElement);\r\n                    props = rawProps;\r\n                    break;\r\n                case 'img':\r\n                case 'image':\r\n                case 'link':\r\n                    // We listen to these events in case to ensure emulated bubble\r\n                    // listeners still fire for error and load events.\r\n                    listenToNonDelegatedEvent('error', domElement);\r\n                    listenToNonDelegatedEvent('load', domElement);\r\n                    props = rawProps;\r\n                    break;\r\n                case 'details':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the toggle event.\r\n                    listenToNonDelegatedEvent('toggle', domElement);\r\n                    props = rawProps;\r\n                    break;\r\n                case 'input':\r\n                    initWrapperState(domElement, rawProps);\r\n                    props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n                case 'option':\r\n                    validateProps(domElement, rawProps);\r\n                    props = getHostProps$1(domElement, rawProps);\r\n                    break;\r\n                case 'select':\r\n                    initWrapperState$1(domElement, rawProps);\r\n                    props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n                case 'textarea':\r\n                    initWrapperState$2(domElement, rawProps);\r\n                    props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n                default:\r\n                    props = rawProps;\r\n            }\r\n            assertValidProps(tag, props);\r\n            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\r\n            switch (tag) {\r\n                case 'input':\r\n                    // TODO: Make sure we check if this is still unmounted or do any clean\r\n                    // up necessary since we never stop tracking anymore.\r\n                    track(domElement);\r\n                    postMountWrapper(domElement, rawProps, false);\r\n                    break;\r\n                case 'textarea':\r\n                    // TODO: Make sure we check if this is still unmounted or do any clean\r\n                    // up necessary since we never stop tracking anymore.\r\n                    track(domElement);\r\n                    postMountWrapper$3(domElement);\r\n                    break;\r\n                case 'option':\r\n                    postMountWrapper$1(domElement, rawProps);\r\n                    break;\r\n                case 'select':\r\n                    postMountWrapper$2(domElement, rawProps);\r\n                    break;\r\n                default:\r\n                    if (typeof props.onClick === 'function') {\r\n                        // TODO: This cast may not be sound for SVG, MathML or custom elements.\r\n                        trapClickOnNonInteractiveElement(domElement);\r\n                    }\r\n                    break;\r\n            }\r\n        } // Calculate the diff between the two objects.\r\n        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\r\n            {\r\n                validatePropertiesInDevelopment(tag, nextRawProps);\r\n            }\r\n            var updatePayload = null;\r\n            var lastProps;\r\n            var nextProps;\r\n            switch (tag) {\r\n                case 'input':\r\n                    lastProps = getHostProps(domElement, lastRawProps);\r\n                    nextProps = getHostProps(domElement, nextRawProps);\r\n                    updatePayload = [];\r\n                    break;\r\n                case 'option':\r\n                    lastProps = getHostProps$1(domElement, lastRawProps);\r\n                    nextProps = getHostProps$1(domElement, nextRawProps);\r\n                    updatePayload = [];\r\n                    break;\r\n                case 'select':\r\n                    lastProps = getHostProps$2(domElement, lastRawProps);\r\n                    nextProps = getHostProps$2(domElement, nextRawProps);\r\n                    updatePayload = [];\r\n                    break;\r\n                case 'textarea':\r\n                    lastProps = getHostProps$3(domElement, lastRawProps);\r\n                    nextProps = getHostProps$3(domElement, nextRawProps);\r\n                    updatePayload = [];\r\n                    break;\r\n                default:\r\n                    lastProps = lastRawProps;\r\n                    nextProps = nextRawProps;\r\n                    if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\r\n                        // TODO: This cast may not be sound for SVG, MathML or custom elements.\r\n                        trapClickOnNonInteractiveElement(domElement);\r\n                    }\r\n                    break;\r\n            }\r\n            assertValidProps(tag, nextProps);\r\n            var propKey;\r\n            var styleName;\r\n            var styleUpdates = null;\r\n            for (propKey in lastProps) {\r\n                if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\r\n                    continue;\r\n                }\r\n                if (propKey === STYLE) {\r\n                    var lastStyle = lastProps[propKey];\r\n                    for (styleName in lastStyle) {\r\n                        if (lastStyle.hasOwnProperty(styleName)) {\r\n                            if (!styleUpdates) {\r\n                                styleUpdates = {};\r\n                            }\r\n                            styleUpdates[styleName] = '';\r\n                        }\r\n                    }\r\n                }\r\n                else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)\r\n                    ;\r\n                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\r\n                    ;\r\n                else if (propKey === AUTOFOCUS)\r\n                    ;\r\n                else if (registrationNameDependencies.hasOwnProperty(propKey)) {\r\n                    // This is a special case. If any listener updates we need to ensure\r\n                    // that the \"current\" fiber pointer gets updated so we need a commit\r\n                    // to update this element.\r\n                    if (!updatePayload) {\r\n                        updatePayload = [];\r\n                    }\r\n                }\r\n                else {\r\n                    // For all other deleted properties we add it to the queue. We use\r\n                    // the allowed property list in the commit phase instead.\r\n                    (updatePayload = updatePayload || []).push(propKey, null);\r\n                }\r\n            }\r\n            for (propKey in nextProps) {\r\n                var nextProp = nextProps[propKey];\r\n                var lastProp = lastProps != null ? lastProps[propKey] : undefined;\r\n                if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\r\n                    continue;\r\n                }\r\n                if (propKey === STYLE) {\r\n                    {\r\n                        if (nextProp) {\r\n                            // Freeze the next style object so that we can assume it won't be\r\n                            // mutated. We have already warned for this in the past.\r\n                            Object.freeze(nextProp);\r\n                        }\r\n                    }\r\n                    if (lastProp) {\r\n                        // Unset styles on `lastProp` but not on `nextProp`.\r\n                        for (styleName in lastProp) {\r\n                            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\r\n                                if (!styleUpdates) {\r\n                                    styleUpdates = {};\r\n                                }\r\n                                styleUpdates[styleName] = '';\r\n                            }\r\n                        } // Update styles that changed since `lastProp`.\r\n                        for (styleName in nextProp) {\r\n                            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\r\n                                if (!styleUpdates) {\r\n                                    styleUpdates = {};\r\n                                }\r\n                                styleUpdates[styleName] = nextProp[styleName];\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Relies on `updateStylesByID` not mutating `styleUpdates`.\r\n                        if (!styleUpdates) {\r\n                            if (!updatePayload) {\r\n                                updatePayload = [];\r\n                            }\r\n                            updatePayload.push(propKey, styleUpdates);\r\n                        }\r\n                        styleUpdates = nextProp;\r\n                    }\r\n                }\r\n                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\r\n                    var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\r\n                    var lastHtml = lastProp ? lastProp[HTML$1] : undefined;\r\n                    if (nextHtml != null) {\r\n                        if (lastHtml !== nextHtml) {\r\n                            (updatePayload = updatePayload || []).push(propKey, nextHtml);\r\n                        }\r\n                    }\r\n                }\r\n                else if (propKey === CHILDREN) {\r\n                    if (typeof nextProp === 'string' || typeof nextProp === 'number') {\r\n                        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\r\n                    }\r\n                }\r\n                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\r\n                    ;\r\n                else if (registrationNameDependencies.hasOwnProperty(propKey)) {\r\n                    if (nextProp != null) {\r\n                        // We eagerly listen to this even though we haven't committed yet.\r\n                        if (typeof nextProp !== 'function') {\r\n                            warnForInvalidEventListener(propKey, nextProp);\r\n                        }\r\n                        if (propKey === 'onScroll') {\r\n                            listenToNonDelegatedEvent('scroll', domElement);\r\n                        }\r\n                    }\r\n                    if (!updatePayload && lastProp !== nextProp) {\r\n                        // This is a special case. If any listener updates we need to ensure\r\n                        // that the \"current\" props pointer gets updated so we need a commit\r\n                        // to update this element.\r\n                        updatePayload = [];\r\n                    }\r\n                }\r\n                else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {\r\n                    // If we encounter useOpaqueReference's opaque object, this means we are hydrating.\r\n                    // In this case, call the opaque object's toString function which generates a new client\r\n                    // ID so client and server IDs match and throws to rerender.\r\n                    nextProp.toString();\r\n                }\r\n                else {\r\n                    // For any other property we always add it to the queue and then we\r\n                    // filter it out using the allowed property list during the commit.\r\n                    (updatePayload = updatePayload || []).push(propKey, nextProp);\r\n                }\r\n            }\r\n            if (styleUpdates) {\r\n                {\r\n                    validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);\r\n                }\r\n                (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\r\n            }\r\n            return updatePayload;\r\n        } // Apply the diff.\r\n        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\r\n            // Update checked *before* name.\r\n            // In the middle of an update, it is possible to have multiple checked.\r\n            // When a checked radio tries to change name, browser makes another radio's checked false.\r\n            if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\r\n                updateChecked(domElement, nextRawProps);\r\n            }\r\n            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\r\n            var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.\r\n            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props\r\n            // changed.\r\n            switch (tag) {\r\n                case 'input':\r\n                    // Update the wrapper around inputs *after* updating props. This has to\r\n                    // happen after `updateDOMProperties`. Otherwise HTML5 input validations\r\n                    // raise warnings and prevent the new value from being assigned.\r\n                    updateWrapper(domElement, nextRawProps);\r\n                    break;\r\n                case 'textarea':\r\n                    updateWrapper$1(domElement, nextRawProps);\r\n                    break;\r\n                case 'select':\r\n                    // <select> value update needs to occur after <option> children\r\n                    // reconciliation\r\n                    postUpdateWrapper(domElement, nextRawProps);\r\n                    break;\r\n            }\r\n        }\r\n        function getPossibleStandardName(propName) {\r\n            {\r\n                var lowerCasedName = propName.toLowerCase();\r\n                if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\r\n                    return null;\r\n                }\r\n                return possibleStandardNames[lowerCasedName] || null;\r\n            }\r\n        }\r\n        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\r\n            var isCustomComponentTag;\r\n            var extraAttributeNames;\r\n            {\r\n                suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;\r\n                isCustomComponentTag = isCustomComponent(tag, rawProps);\r\n                validatePropertiesInDevelopment(tag, rawProps);\r\n            } // TODO: Make sure that we check isMounted before firing any of these events.\r\n            switch (tag) {\r\n                case 'dialog':\r\n                    listenToNonDelegatedEvent('cancel', domElement);\r\n                    listenToNonDelegatedEvent('close', domElement);\r\n                    break;\r\n                case 'iframe':\r\n                case 'object':\r\n                case 'embed':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the load event.\r\n                    listenToNonDelegatedEvent('load', domElement);\r\n                    break;\r\n                case 'video':\r\n                case 'audio':\r\n                    // We listen to these events in case to ensure emulated bubble\r\n                    // listeners still fire for all the media events.\r\n                    for (var i = 0; i < mediaEventTypes.length; i++) {\r\n                        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\r\n                    }\r\n                    break;\r\n                case 'source':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the error event.\r\n                    listenToNonDelegatedEvent('error', domElement);\r\n                    break;\r\n                case 'img':\r\n                case 'image':\r\n                case 'link':\r\n                    // We listen to these events in case to ensure emulated bubble\r\n                    // listeners still fire for error and load events.\r\n                    listenToNonDelegatedEvent('error', domElement);\r\n                    listenToNonDelegatedEvent('load', domElement);\r\n                    break;\r\n                case 'details':\r\n                    // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the toggle event.\r\n                    listenToNonDelegatedEvent('toggle', domElement);\r\n                    break;\r\n                case 'input':\r\n                    initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n                case 'option':\r\n                    validateProps(domElement, rawProps);\r\n                    break;\r\n                case 'select':\r\n                    initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n                case 'textarea':\r\n                    initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble\r\n                    // listeners still fire for the invalid event.\r\n                    listenToNonDelegatedEvent('invalid', domElement);\r\n                    break;\r\n            }\r\n            assertValidProps(tag, rawProps);\r\n            {\r\n                extraAttributeNames = new Set();\r\n                var attributes = domElement.attributes;\r\n                for (var _i = 0; _i < attributes.length; _i++) {\r\n                    var name = attributes[_i].name.toLowerCase();\r\n                    switch (name) {\r\n                        // Built-in SSR attribute is allowed\r\n                        case 'data-reactroot':\r\n                            break;\r\n                        // Controlled attributes are not validated\r\n                        // TODO: Only ignore them on controlled tags.\r\n                        case 'value':\r\n                            break;\r\n                        case 'checked':\r\n                            break;\r\n                        case 'selected':\r\n                            break;\r\n                        default:\r\n                            // Intentionally use the original name.\r\n                            // See discussion in https://github.com/facebook/react/pull/10676.\r\n                            extraAttributeNames.add(attributes[_i].name);\r\n                    }\r\n                }\r\n            }\r\n            var updatePayload = null;\r\n            for (var propKey in rawProps) {\r\n                if (!rawProps.hasOwnProperty(propKey)) {\r\n                    continue;\r\n                }\r\n                var nextProp = rawProps[propKey];\r\n                if (propKey === CHILDREN) {\r\n                    // For text content children we compare against textContent. This\r\n                    // might match additional HTML that is hidden when we read it using\r\n                    // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\r\n                    // satisfies our requirement. Our requirement is not to produce perfect\r\n                    // HTML and attributes. Ideally we should preserve structure but it's\r\n                    // ok not to if the visible content is still enough to indicate what\r\n                    // even listeners these nodes might be wired up to.\r\n                    // TODO: Warn if there is more than a single textNode as a child.\r\n                    // TODO: Should we use domElement.firstChild.nodeValue to compare?\r\n                    if (typeof nextProp === 'string') {\r\n                        if (domElement.textContent !== nextProp) {\r\n                            if (!suppressHydrationWarning) {\r\n                                warnForTextDifference(domElement.textContent, nextProp);\r\n                            }\r\n                            updatePayload = [CHILDREN, nextProp];\r\n                        }\r\n                    }\r\n                    else if (typeof nextProp === 'number') {\r\n                        if (domElement.textContent !== '' + nextProp) {\r\n                            if (!suppressHydrationWarning) {\r\n                                warnForTextDifference(domElement.textContent, nextProp);\r\n                            }\r\n                            updatePayload = [CHILDREN, '' + nextProp];\r\n                        }\r\n                    }\r\n                }\r\n                else if (registrationNameDependencies.hasOwnProperty(propKey)) {\r\n                    if (nextProp != null) {\r\n                        if (typeof nextProp !== 'function') {\r\n                            warnForInvalidEventListener(propKey, nextProp);\r\n                        }\r\n                        if (propKey === 'onScroll') {\r\n                            listenToNonDelegatedEvent('scroll', domElement);\r\n                        }\r\n                    }\r\n                }\r\n                else if ( // Convince Flow we've calculated it (it's DEV-only in this method.)\r\n                typeof isCustomComponentTag === 'boolean') {\r\n                    // Validate that the properties correspond to their expected values.\r\n                    var serverValue = void 0;\r\n                    var propertyInfo = getPropertyInfo(propKey);\r\n                    if (suppressHydrationWarning)\r\n                        ;\r\n                    else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated\r\n                        // TODO: Only ignore them on controlled tags.\r\n                        propKey === 'value' || propKey === 'checked' || propKey === 'selected')\r\n                        ;\r\n                    else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\r\n                        var serverHTML = domElement.innerHTML;\r\n                        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\r\n                        if (nextHtml != null) {\r\n                            var expectedHTML = normalizeHTML(domElement, nextHtml);\r\n                            if (expectedHTML !== serverHTML) {\r\n                                warnForPropDifference(propKey, serverHTML, expectedHTML);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (propKey === STYLE) {\r\n                        // $FlowFixMe - Should be inferred as not undefined.\r\n                        extraAttributeNames.delete(propKey);\r\n                        if (canDiffStyleForHydrationWarning) {\r\n                            var expectedStyle = createDangerousStringForStyles(nextProp);\r\n                            serverValue = domElement.getAttribute('style');\r\n                            if (expectedStyle !== serverValue) {\r\n                                warnForPropDifference(propKey, serverValue, expectedStyle);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (isCustomComponentTag) {\r\n                        // $FlowFixMe - Should be inferred as not undefined.\r\n                        extraAttributeNames.delete(propKey.toLowerCase());\r\n                        serverValue = getValueForAttribute(domElement, propKey, nextProp);\r\n                        if (nextProp !== serverValue) {\r\n                            warnForPropDifference(propKey, serverValue, nextProp);\r\n                        }\r\n                    }\r\n                    else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\r\n                        var isMismatchDueToBadCasing = false;\r\n                        if (propertyInfo !== null) {\r\n                            // $FlowFixMe - Should be inferred as not undefined.\r\n                            extraAttributeNames.delete(propertyInfo.attributeName);\r\n                            serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\r\n                        }\r\n                        else {\r\n                            var ownNamespace = parentNamespace;\r\n                            if (ownNamespace === HTML_NAMESPACE$1) {\r\n                                ownNamespace = getIntrinsicNamespace(tag);\r\n                            }\r\n                            if (ownNamespace === HTML_NAMESPACE$1) {\r\n                                // $FlowFixMe - Should be inferred as not undefined.\r\n                                extraAttributeNames.delete(propKey.toLowerCase());\r\n                            }\r\n                            else {\r\n                                var standardName = getPossibleStandardName(propKey);\r\n                                if (standardName !== null && standardName !== propKey) {\r\n                                    // If an SVG prop is supplied with bad casing, it will\r\n                                    // be successfully parsed from HTML, but will produce a mismatch\r\n                                    // (and would be incorrectly rendered on the client).\r\n                                    // However, we already warn about bad casing elsewhere.\r\n                                    // So we'll skip the misleading extra mismatch warning in this case.\r\n                                    isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.\r\n                                    extraAttributeNames.delete(standardName);\r\n                                } // $FlowFixMe - Should be inferred as not undefined.\r\n                                extraAttributeNames.delete(propKey);\r\n                            }\r\n                            serverValue = getValueForAttribute(domElement, propKey, nextProp);\r\n                        }\r\n                        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\r\n                            warnForPropDifference(propKey, serverValue, nextProp);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            {\r\n                // $FlowFixMe - Should be inferred as not undefined.\r\n                if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\r\n                    // $FlowFixMe - Should be inferred as not undefined.\r\n                    warnForExtraAttributes(extraAttributeNames);\r\n                }\r\n            }\r\n            switch (tag) {\r\n                case 'input':\r\n                    // TODO: Make sure we check if this is still unmounted or do any clean\r\n                    // up necessary since we never stop tracking anymore.\r\n                    track(domElement);\r\n                    postMountWrapper(domElement, rawProps, true);\r\n                    break;\r\n                case 'textarea':\r\n                    // TODO: Make sure we check if this is still unmounted or do any clean\r\n                    // up necessary since we never stop tracking anymore.\r\n                    track(domElement);\r\n                    postMountWrapper$3(domElement);\r\n                    break;\r\n                case 'select':\r\n                case 'option':\r\n                    // For input and textarea we current always set the value property at\r\n                    // post mount to force it to diverge from attributes. However, for\r\n                    // option and select we don't quite do the same thing and select\r\n                    // is not resilient to the DOM state changing so we don't do that here.\r\n                    // TODO: Consider not doing this for input and textarea.\r\n                    break;\r\n                default:\r\n                    if (typeof rawProps.onClick === 'function') {\r\n                        // TODO: This cast may not be sound for SVG, MathML or custom elements.\r\n                        trapClickOnNonInteractiveElement(domElement);\r\n                    }\r\n                    break;\r\n            }\r\n            return updatePayload;\r\n        }\r\n        function diffHydratedText(textNode, text) {\r\n            var isDifferent = textNode.nodeValue !== text;\r\n            return isDifferent;\r\n        }\r\n        function warnForUnmatchedText(textNode, text) {\r\n            {\r\n                warnForTextDifference(textNode.nodeValue, text);\r\n            }\r\n        }\r\n        function warnForDeletedHydratableElement(parentNode, child) {\r\n            {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\r\n            }\r\n        }\r\n        function warnForDeletedHydratableText(parentNode, child) {\r\n            {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\r\n            }\r\n        }\r\n        function warnForInsertedHydratedElement(parentNode, tag, props) {\r\n            {\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\r\n            }\r\n        }\r\n        function warnForInsertedHydratedText(parentNode, text) {\r\n            {\r\n                if (text === '') {\r\n                    // We expect to insert empty text nodes since they're not represented in\r\n                    // the HTML.\r\n                    // TODO: Remove this special case if we can just avoid inserting empty\r\n                    // text nodes.\r\n                    return;\r\n                }\r\n                if (didWarnInvalidHydration) {\r\n                    return;\r\n                }\r\n                didWarnInvalidHydration = true;\r\n                error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\r\n            }\r\n        }\r\n        function restoreControlledState$3(domElement, tag, props) {\r\n            switch (tag) {\r\n                case 'input':\r\n                    restoreControlledState(domElement, props);\r\n                    return;\r\n                case 'textarea':\r\n                    restoreControlledState$2(domElement, props);\r\n                    return;\r\n                case 'select':\r\n                    restoreControlledState$1(domElement, props);\r\n                    return;\r\n            }\r\n        }\r\n        var validateDOMNesting = function () { };\r\n        var updatedAncestorInfo = function () { };\r\n        {\r\n            // This validation code was written based on the HTML5 parsing spec:\r\n            // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\r\n            //\r\n            // Note: this does not catch all invalid nesting, nor does it try to (as it's\r\n            // not clear what practical benefit doing so provides); instead, we warn only\r\n            // for cases where the parser will give a parse tree differing from what React\r\n            // intended. For example, <b><div></div></b> is invalid but we don't warn\r\n            // because it still parses correctly; we do warn for other cases like nested\r\n            // <p> tags where the beginning of the second element implicitly closes the\r\n            // first, causing a confusing mess.\r\n            // https://html.spec.whatwg.org/multipage/syntax.html#special\r\n            var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\r\n            var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\r\n                // TODO: Distinguish by namespace here -- for <title>, including it here\r\n                // errs on the side of fewer warnings\r\n                'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\r\n            var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\r\n            var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\r\n            var emptyAncestorInfo = {\r\n                current: null,\r\n                formTag: null,\r\n                aTagInScope: null,\r\n                buttonTagInScope: null,\r\n                nobrTagInScope: null,\r\n                pTagInButtonScope: null,\r\n                listItemTagAutoclosing: null,\r\n                dlItemTagAutoclosing: null\r\n            };\r\n            updatedAncestorInfo = function (oldInfo, tag) {\r\n                var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\r\n                var info = {\r\n                    tag: tag\r\n                };\r\n                if (inScopeTags.indexOf(tag) !== -1) {\r\n                    ancestorInfo.aTagInScope = null;\r\n                    ancestorInfo.buttonTagInScope = null;\r\n                    ancestorInfo.nobrTagInScope = null;\r\n                }\r\n                if (buttonScopeTags.indexOf(tag) !== -1) {\r\n                    ancestorInfo.pTagInButtonScope = null;\r\n                } // See rules for 'li', 'dd', 'dt' start tags in\r\n                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\r\n                if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\r\n                    ancestorInfo.listItemTagAutoclosing = null;\r\n                    ancestorInfo.dlItemTagAutoclosing = null;\r\n                }\r\n                ancestorInfo.current = info;\r\n                if (tag === 'form') {\r\n                    ancestorInfo.formTag = info;\r\n                }\r\n                if (tag === 'a') {\r\n                    ancestorInfo.aTagInScope = info;\r\n                }\r\n                if (tag === 'button') {\r\n                    ancestorInfo.buttonTagInScope = info;\r\n                }\r\n                if (tag === 'nobr') {\r\n                    ancestorInfo.nobrTagInScope = info;\r\n                }\r\n                if (tag === 'p') {\r\n                    ancestorInfo.pTagInButtonScope = info;\r\n                }\r\n                if (tag === 'li') {\r\n                    ancestorInfo.listItemTagAutoclosing = info;\r\n                }\r\n                if (tag === 'dd' || tag === 'dt') {\r\n                    ancestorInfo.dlItemTagAutoclosing = info;\r\n                }\r\n                return ancestorInfo;\r\n            };\r\n            /**\r\n             * Returns whether\r\n             */\r\n            var isTagValidWithParent = function (tag, parentTag) {\r\n                // First, let's check if we're in an unusual parsing mode...\r\n                switch (parentTag) {\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\r\n                    case 'select':\r\n                        return tag === 'option' || tag === 'optgroup' || tag === '#text';\r\n                    case 'optgroup':\r\n                        return tag === 'option' || tag === '#text';\r\n                    // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\r\n                    // but\r\n                    case 'option':\r\n                        return tag === '#text';\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\r\n                    // No special behavior since these rules fall back to \"in body\" mode for\r\n                    // all except special table nodes which cause bad parsing behavior anyway.\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\r\n                    case 'tr':\r\n                        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\r\n                    case 'tbody':\r\n                    case 'thead':\r\n                    case 'tfoot':\r\n                        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\r\n                    case 'colgroup':\r\n                        return tag === 'col' || tag === 'template';\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\r\n                    case 'table':\r\n                        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\r\n                    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\r\n                    case 'head':\r\n                        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\r\n                    // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\r\n                    case 'html':\r\n                        return tag === 'head' || tag === 'body' || tag === 'frameset';\r\n                    case 'frameset':\r\n                        return tag === 'frame';\r\n                    case '#document':\r\n                        return tag === 'html';\r\n                } // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\r\n                // where the parsing rules cause implicit opens or closes to be added.\r\n                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\r\n                switch (tag) {\r\n                    case 'h1':\r\n                    case 'h2':\r\n                    case 'h3':\r\n                    case 'h4':\r\n                    case 'h5':\r\n                    case 'h6':\r\n                        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\r\n                    case 'rp':\r\n                    case 'rt':\r\n                        return impliedEndTags.indexOf(parentTag) === -1;\r\n                    case 'body':\r\n                    case 'caption':\r\n                    case 'col':\r\n                    case 'colgroup':\r\n                    case 'frameset':\r\n                    case 'frame':\r\n                    case 'head':\r\n                    case 'html':\r\n                    case 'tbody':\r\n                    case 'td':\r\n                    case 'tfoot':\r\n                    case 'th':\r\n                    case 'thead':\r\n                    case 'tr':\r\n                        // These tags are only valid with a few parents that have special child\r\n                        // parsing rules -- if we're down here, then none of those matched and\r\n                        // so we allow it only if we don't know what the parent is, as all other\r\n                        // cases are invalid.\r\n                        return parentTag == null;\r\n                }\r\n                return true;\r\n            };\r\n            /**\r\n             * Returns whether\r\n             */\r\n            var findInvalidAncestorForTag = function (tag, ancestorInfo) {\r\n                switch (tag) {\r\n                    case 'address':\r\n                    case 'article':\r\n                    case 'aside':\r\n                    case 'blockquote':\r\n                    case 'center':\r\n                    case 'details':\r\n                    case 'dialog':\r\n                    case 'dir':\r\n                    case 'div':\r\n                    case 'dl':\r\n                    case 'fieldset':\r\n                    case 'figcaption':\r\n                    case 'figure':\r\n                    case 'footer':\r\n                    case 'header':\r\n                    case 'hgroup':\r\n                    case 'main':\r\n                    case 'menu':\r\n                    case 'nav':\r\n                    case 'ol':\r\n                    case 'p':\r\n                    case 'section':\r\n                    case 'summary':\r\n                    case 'ul':\r\n                    case 'pre':\r\n                    case 'listing':\r\n                    case 'table':\r\n                    case 'hr':\r\n                    case 'xmp':\r\n                    case 'h1':\r\n                    case 'h2':\r\n                    case 'h3':\r\n                    case 'h4':\r\n                    case 'h5':\r\n                    case 'h6':\r\n                        return ancestorInfo.pTagInButtonScope;\r\n                    case 'form':\r\n                        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\r\n                    case 'li':\r\n                        return ancestorInfo.listItemTagAutoclosing;\r\n                    case 'dd':\r\n                    case 'dt':\r\n                        return ancestorInfo.dlItemTagAutoclosing;\r\n                    case 'button':\r\n                        return ancestorInfo.buttonTagInScope;\r\n                    case 'a':\r\n                        // Spec says something about storing a list of markers, but it sounds\r\n                        // equivalent to this check.\r\n                        return ancestorInfo.aTagInScope;\r\n                    case 'nobr':\r\n                        return ancestorInfo.nobrTagInScope;\r\n                }\r\n                return null;\r\n            };\r\n            var didWarn$1 = {};\r\n            validateDOMNesting = function (childTag, childText, ancestorInfo) {\r\n                ancestorInfo = ancestorInfo || emptyAncestorInfo;\r\n                var parentInfo = ancestorInfo.current;\r\n                var parentTag = parentInfo && parentInfo.tag;\r\n                if (childText != null) {\r\n                    if (childTag != null) {\r\n                        error('validateDOMNesting: when childText is passed, childTag should be null');\r\n                    }\r\n                    childTag = '#text';\r\n                }\r\n                var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\r\n                var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\r\n                var invalidParentOrAncestor = invalidParent || invalidAncestor;\r\n                if (!invalidParentOrAncestor) {\r\n                    return;\r\n                }\r\n                var ancestorTag = invalidParentOrAncestor.tag;\r\n                var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;\r\n                if (didWarn$1[warnKey]) {\r\n                    return;\r\n                }\r\n                didWarn$1[warnKey] = true;\r\n                var tagDisplayName = childTag;\r\n                var whitespaceInfo = '';\r\n                if (childTag === '#text') {\r\n                    if (/\\S/.test(childText)) {\r\n                        tagDisplayName = 'Text nodes';\r\n                    }\r\n                    else {\r\n                        tagDisplayName = 'Whitespace text nodes';\r\n                        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\r\n                    }\r\n                }\r\n                else {\r\n                    tagDisplayName = '<' + childTag + '>';\r\n                }\r\n                if (invalidParent) {\r\n                    var info = '';\r\n                    if (ancestorTag === 'table' && childTag === 'tr') {\r\n                        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';\r\n                    }\r\n                    error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);\r\n                }\r\n                else {\r\n                    error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);\r\n                }\r\n            };\r\n        }\r\n        var SUPPRESS_HYDRATION_WARNING$1;\r\n        {\r\n            SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\r\n        }\r\n        var SUSPENSE_START_DATA = '$';\r\n        var SUSPENSE_END_DATA = '/$';\r\n        var SUSPENSE_PENDING_START_DATA = '$?';\r\n        var SUSPENSE_FALLBACK_START_DATA = '$!';\r\n        var STYLE$1 = 'style';\r\n        var eventsEnabled = null;\r\n        var selectionInformation = null;\r\n        function shouldAutoFocusHostComponent(type, props) {\r\n            switch (type) {\r\n                case 'button':\r\n                case 'input':\r\n                case 'select':\r\n                case 'textarea':\r\n                    return !!props.autoFocus;\r\n            }\r\n            return false;\r\n        }\r\n        function getRootHostContext(rootContainerInstance) {\r\n            var type;\r\n            var namespace;\r\n            var nodeType = rootContainerInstance.nodeType;\r\n            switch (nodeType) {\r\n                case DOCUMENT_NODE:\r\n                case DOCUMENT_FRAGMENT_NODE:\r\n                    {\r\n                        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\r\n                        var root = rootContainerInstance.documentElement;\r\n                        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\r\n                        break;\r\n                    }\r\n                default:\r\n                    {\r\n                        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\r\n                        var ownNamespace = container.namespaceURI || null;\r\n                        type = container.tagName;\r\n                        namespace = getChildNamespace(ownNamespace, type);\r\n                        break;\r\n                    }\r\n            }\r\n            {\r\n                var validatedTag = type.toLowerCase();\r\n                var ancestorInfo = updatedAncestorInfo(null, validatedTag);\r\n                return {\r\n                    namespace: namespace,\r\n                    ancestorInfo: ancestorInfo\r\n                };\r\n            }\r\n        }\r\n        function getChildHostContext(parentHostContext, type, rootContainerInstance) {\r\n            {\r\n                var parentHostContextDev = parentHostContext;\r\n                var namespace = getChildNamespace(parentHostContextDev.namespace, type);\r\n                var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\r\n                return {\r\n                    namespace: namespace,\r\n                    ancestorInfo: ancestorInfo\r\n                };\r\n            }\r\n        }\r\n        function getPublicInstance(instance) {\r\n            return instance;\r\n        }\r\n        function prepareForCommit(containerInfo) {\r\n            eventsEnabled = isEnabled();\r\n            selectionInformation = getSelectionInformation();\r\n            var activeInstance = null;\r\n            setEnabled(false);\r\n            return activeInstance;\r\n        }\r\n        function resetAfterCommit(containerInfo) {\r\n            restoreSelection(selectionInformation);\r\n            setEnabled(eventsEnabled);\r\n            eventsEnabled = null;\r\n            selectionInformation = null;\r\n        }\r\n        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\r\n            var parentNamespace;\r\n            {\r\n                // TODO: take namespace into account when validating.\r\n                var hostContextDev = hostContext;\r\n                validateDOMNesting(type, null, hostContextDev.ancestorInfo);\r\n                if (typeof props.children === 'string' || typeof props.children === 'number') {\r\n                    var string = '' + props.children;\r\n                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\r\n                    validateDOMNesting(null, string, ownAncestorInfo);\r\n                }\r\n                parentNamespace = hostContextDev.namespace;\r\n            }\r\n            var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\r\n            precacheFiberNode(internalInstanceHandle, domElement);\r\n            updateFiberProps(domElement, props);\r\n            return domElement;\r\n        }\r\n        function appendInitialChild(parentInstance, child) {\r\n            parentInstance.appendChild(child);\r\n        }\r\n        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\r\n            setInitialProperties(domElement, type, props, rootContainerInstance);\r\n            return shouldAutoFocusHostComponent(type, props);\r\n        }\r\n        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\r\n            {\r\n                var hostContextDev = hostContext;\r\n                if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\r\n                    var string = '' + newProps.children;\r\n                    var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\r\n                    validateDOMNesting(null, string, ownAncestorInfo);\r\n                }\r\n            }\r\n            return diffProperties(domElement, type, oldProps, newProps);\r\n        }\r\n        function shouldSetTextContent(type, props) {\r\n            return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\r\n        }\r\n        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\r\n            {\r\n                var hostContextDev = hostContext;\r\n                validateDOMNesting(null, text, hostContextDev.ancestorInfo);\r\n            }\r\n            var textNode = createTextNode(text, rootContainerInstance);\r\n            precacheFiberNode(internalInstanceHandle, textNode);\r\n            return textNode;\r\n        }\r\n        // if a component just imports ReactDOM (e.g. for findDOMNode).\r\n        // Some environments might not have setTimeout or clearTimeout.\r\n        var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\r\n        var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\r\n        var noTimeout = -1; // -------------------\r\n        function commitMount(domElement, type, newProps, internalInstanceHandle) {\r\n            // Despite the naming that might imply otherwise, this method only\r\n            // fires if there is an `Update` effect scheduled during mounting.\r\n            // This happens if `finalizeInitialChildren` returns `true` (which it\r\n            // does to implement the `autoFocus` attribute on the client). But\r\n            // there are also other cases when this might happen (such as patching\r\n            // up text content during hydration mismatch). So we'll check this again.\r\n            if (shouldAutoFocusHostComponent(type, newProps)) {\r\n                domElement.focus();\r\n            }\r\n        }\r\n        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\r\n            // Update the props handle so that we know which props are the ones with\r\n            // with current event handlers.\r\n            updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\r\n            updateProperties(domElement, updatePayload, type, oldProps, newProps);\r\n        }\r\n        function resetTextContent(domElement) {\r\n            setTextContent(domElement, '');\r\n        }\r\n        function commitTextUpdate(textInstance, oldText, newText) {\r\n            textInstance.nodeValue = newText;\r\n        }\r\n        function appendChild(parentInstance, child) {\r\n            parentInstance.appendChild(child);\r\n        }\r\n        function appendChildToContainer(container, child) {\r\n            var parentNode;\r\n            if (container.nodeType === COMMENT_NODE) {\r\n                parentNode = container.parentNode;\r\n                parentNode.insertBefore(child, container);\r\n            }\r\n            else {\r\n                parentNode = container;\r\n                parentNode.appendChild(child);\r\n            } // This container might be used for a portal.\r\n            // If something inside a portal is clicked, that click should bubble\r\n            // through the React tree. However, on Mobile Safari the click would\r\n            // never bubble through the *DOM* tree unless an ancestor with onclick\r\n            // event exists. So we wouldn't see it and dispatch it.\r\n            // This is why we ensure that non React root containers have inline onclick\r\n            // defined.\r\n            // https://github.com/facebook/react/issues/11918\r\n            var reactRootContainer = container._reactRootContainer;\r\n            if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\r\n                // TODO: This cast may not be sound for SVG, MathML or custom elements.\r\n                trapClickOnNonInteractiveElement(parentNode);\r\n            }\r\n        }\r\n        function insertBefore(parentInstance, child, beforeChild) {\r\n            parentInstance.insertBefore(child, beforeChild);\r\n        }\r\n        function insertInContainerBefore(container, child, beforeChild) {\r\n            if (container.nodeType === COMMENT_NODE) {\r\n                container.parentNode.insertBefore(child, beforeChild);\r\n            }\r\n            else {\r\n                container.insertBefore(child, beforeChild);\r\n            }\r\n        }\r\n        function removeChild(parentInstance, child) {\r\n            parentInstance.removeChild(child);\r\n        }\r\n        function removeChildFromContainer(container, child) {\r\n            if (container.nodeType === COMMENT_NODE) {\r\n                container.parentNode.removeChild(child);\r\n            }\r\n            else {\r\n                container.removeChild(child);\r\n            }\r\n        }\r\n        function hideInstance(instance) {\r\n            // TODO: Does this work for all element types? What about MathML? Should we\r\n            // pass host context to this method?\r\n            instance = instance;\r\n            var style = instance.style;\r\n            if (typeof style.setProperty === 'function') {\r\n                style.setProperty('display', 'none', 'important');\r\n            }\r\n            else {\r\n                style.display = 'none';\r\n            }\r\n        }\r\n        function hideTextInstance(textInstance) {\r\n            textInstance.nodeValue = '';\r\n        }\r\n        function unhideInstance(instance, props) {\r\n            instance = instance;\r\n            var styleProp = props[STYLE$1];\r\n            var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\r\n            instance.style.display = dangerousStyleValue('display', display);\r\n        }\r\n        function unhideTextInstance(textInstance, text) {\r\n            textInstance.nodeValue = text;\r\n        }\r\n        function clearContainer(container) {\r\n            if (container.nodeType === ELEMENT_NODE) {\r\n                container.textContent = '';\r\n            }\r\n            else if (container.nodeType === DOCUMENT_NODE) {\r\n                var body = container.body;\r\n                if (body != null) {\r\n                    body.textContent = '';\r\n                }\r\n            }\r\n        } // -------------------\r\n        function canHydrateInstance(instance, type, props) {\r\n            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\r\n                return null;\r\n            } // This has now been refined to an element node.\r\n            return instance;\r\n        }\r\n        function canHydrateTextInstance(instance, text) {\r\n            if (text === '' || instance.nodeType !== TEXT_NODE) {\r\n                // Empty strings are not parsed by HTML so there won't be a correct match here.\r\n                return null;\r\n            } // This has now been refined to a text node.\r\n            return instance;\r\n        }\r\n        function isSuspenseInstancePending(instance) {\r\n            return instance.data === SUSPENSE_PENDING_START_DATA;\r\n        }\r\n        function isSuspenseInstanceFallback(instance) {\r\n            return instance.data === SUSPENSE_FALLBACK_START_DATA;\r\n        }\r\n        function getNextHydratable(node) {\r\n            // Skip non-hydratable nodes.\r\n            for (; node != null; node = node.nextSibling) {\r\n                var nodeType = node.nodeType;\r\n                if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\r\n                    break;\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n        function getNextHydratableSibling(instance) {\r\n            return getNextHydratable(instance.nextSibling);\r\n        }\r\n        function getFirstHydratableChild(parentInstance) {\r\n            return getNextHydratable(parentInstance.firstChild);\r\n        }\r\n        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\r\n            precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\r\n            // get attached.\r\n            updateFiberProps(instance, props);\r\n            var parentNamespace;\r\n            {\r\n                var hostContextDev = hostContext;\r\n                parentNamespace = hostContextDev.namespace;\r\n            }\r\n            return diffHydratedProperties(instance, type, props, parentNamespace);\r\n        }\r\n        function hydrateTextInstance(textInstance, text, internalInstanceHandle) {\r\n            precacheFiberNode(internalInstanceHandle, textInstance);\r\n            return diffHydratedText(textInstance, text);\r\n        }\r\n        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\r\n            var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\r\n            // There might be nested nodes so we need to keep track of how\r\n            // deep we are and only break out when we're back on top.\r\n            var depth = 0;\r\n            while (node) {\r\n                if (node.nodeType === COMMENT_NODE) {\r\n                    var data = node.data;\r\n                    if (data === SUSPENSE_END_DATA) {\r\n                        if (depth === 0) {\r\n                            return getNextHydratableSibling(node);\r\n                        }\r\n                        else {\r\n                            depth--;\r\n                        }\r\n                    }\r\n                    else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\r\n                        depth++;\r\n                    }\r\n                }\r\n                node = node.nextSibling;\r\n            } // TODO: Warn, we didn't find the end comment boundary.\r\n            return null;\r\n        } // Returns the SuspenseInstance if this node is a direct child of a\r\n        // SuspenseInstance. I.e. if its previous sibling is a Comment with\r\n        // SUSPENSE_x_START_DATA. Otherwise, null.\r\n        function getParentSuspenseInstance(targetInstance) {\r\n            var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\r\n            // There might be nested nodes so we need to keep track of how\r\n            // deep we are and only break out when we're back on top.\r\n            var depth = 0;\r\n            while (node) {\r\n                if (node.nodeType === COMMENT_NODE) {\r\n                    var data = node.data;\r\n                    if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\r\n                        if (depth === 0) {\r\n                            return node;\r\n                        }\r\n                        else {\r\n                            depth--;\r\n                        }\r\n                    }\r\n                    else if (data === SUSPENSE_END_DATA) {\r\n                        depth++;\r\n                    }\r\n                }\r\n                node = node.previousSibling;\r\n            }\r\n            return null;\r\n        }\r\n        function commitHydratedContainer(container) {\r\n            // Retry if any event replaying was blocked on this.\r\n            retryIfBlockedOn(container);\r\n        }\r\n        function commitHydratedSuspenseInstance(suspenseInstance) {\r\n            // Retry if any event replaying was blocked on this.\r\n            retryIfBlockedOn(suspenseInstance);\r\n        }\r\n        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\r\n            {\r\n                warnForUnmatchedText(textInstance, text);\r\n            }\r\n        }\r\n        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\r\n            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\r\n                warnForUnmatchedText(textInstance, text);\r\n            }\r\n        }\r\n        function didNotHydrateContainerInstance(parentContainer, instance) {\r\n            {\r\n                if (instance.nodeType === ELEMENT_NODE) {\r\n                    warnForDeletedHydratableElement(parentContainer, instance);\r\n                }\r\n                else if (instance.nodeType === COMMENT_NODE)\r\n                    ;\r\n                else {\r\n                    warnForDeletedHydratableText(parentContainer, instance);\r\n                }\r\n            }\r\n        }\r\n        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\r\n            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\r\n                if (instance.nodeType === ELEMENT_NODE) {\r\n                    warnForDeletedHydratableElement(parentInstance, instance);\r\n                }\r\n                else if (instance.nodeType === COMMENT_NODE)\r\n                    ;\r\n                else {\r\n                    warnForDeletedHydratableText(parentInstance, instance);\r\n                }\r\n            }\r\n        }\r\n        function didNotFindHydratableContainerInstance(parentContainer, type, props) {\r\n            {\r\n                warnForInsertedHydratedElement(parentContainer, type);\r\n            }\r\n        }\r\n        function didNotFindHydratableContainerTextInstance(parentContainer, text) {\r\n            {\r\n                warnForInsertedHydratedText(parentContainer, text);\r\n            }\r\n        }\r\n        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\r\n            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\r\n                warnForInsertedHydratedElement(parentInstance, type);\r\n            }\r\n        }\r\n        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\r\n            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\r\n                warnForInsertedHydratedText(parentInstance, text);\r\n            }\r\n        }\r\n        function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\r\n            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true)\r\n                ;\r\n        }\r\n        var clientId = 0;\r\n        function makeClientIdInDEV(warnOnAccessInDEV) {\r\n            var id = 'r:' + (clientId++).toString(36);\r\n            return {\r\n                toString: function () {\r\n                    warnOnAccessInDEV();\r\n                    return id;\r\n                },\r\n                valueOf: function () {\r\n                    warnOnAccessInDEV();\r\n                    return id;\r\n                }\r\n            };\r\n        }\r\n        function isOpaqueHydratingObject(value) {\r\n            return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;\r\n        }\r\n        function makeOpaqueHydratingObject(attemptToReadValue) {\r\n            return {\r\n                $$typeof: REACT_OPAQUE_ID_TYPE,\r\n                toString: attemptToReadValue,\r\n                valueOf: attemptToReadValue\r\n            };\r\n        }\r\n        function preparePortalMount(portalInstance) {\r\n            {\r\n                listenToAllSupportedEvents(portalInstance);\r\n            }\r\n        }\r\n        var randomKey = Math.random().toString(36).slice(2);\r\n        var internalInstanceKey = '__reactFiber$' + randomKey;\r\n        var internalPropsKey = '__reactProps$' + randomKey;\r\n        var internalContainerInstanceKey = '__reactContainer$' + randomKey;\r\n        var internalEventHandlersKey = '__reactEvents$' + randomKey;\r\n        function precacheFiberNode(hostInst, node) {\r\n            node[internalInstanceKey] = hostInst;\r\n        }\r\n        function markContainerAsRoot(hostRoot, node) {\r\n            node[internalContainerInstanceKey] = hostRoot;\r\n        }\r\n        function unmarkContainerAsRoot(node) {\r\n            node[internalContainerInstanceKey] = null;\r\n        }\r\n        function isContainerMarkedAsRoot(node) {\r\n            return !!node[internalContainerInstanceKey];\r\n        } // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\r\n        // If the target node is part of a hydrated or not yet rendered subtree, then\r\n        // this may also return a SuspenseComponent or HostRoot to indicate that.\r\n        // Conceptually the HostRoot fiber is a child of the Container node. So if you\r\n        // pass the Container node as the targetNode, you will not actually get the\r\n        // HostRoot back. To get to the HostRoot, you need to pass a child of it.\r\n        // The same thing applies to Suspense boundaries.\r\n        function getClosestInstanceFromNode(targetNode) {\r\n            var targetInst = targetNode[internalInstanceKey];\r\n            if (targetInst) {\r\n                // Don't return HostRoot or SuspenseComponent here.\r\n                return targetInst;\r\n            } // If the direct event target isn't a React owned DOM node, we need to look\r\n            // to see if one of its parents is a React owned DOM node.\r\n            var parentNode = targetNode.parentNode;\r\n            while (parentNode) {\r\n                // We'll check if this is a container root that could include\r\n                // React nodes in the future. We need to check this first because\r\n                // if we're a child of a dehydrated container, we need to first\r\n                // find that inner container before moving on to finding the parent\r\n                // instance. Note that we don't check this field on  the targetNode\r\n                // itself because the fibers are conceptually between the container\r\n                // node and the first child. It isn't surrounding the container node.\r\n                // If it's not a container, we check if it's an instance.\r\n                targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\r\n                if (targetInst) {\r\n                    // Since this wasn't the direct target of the event, we might have\r\n                    // stepped past dehydrated DOM nodes to get here. However they could\r\n                    // also have been non-React nodes. We need to answer which one.\r\n                    // If we the instance doesn't have any children, then there can't be\r\n                    // a nested suspense boundary within it. So we can use this as a fast\r\n                    // bailout. Most of the time, when people add non-React children to\r\n                    // the tree, it is using a ref to a child-less DOM node.\r\n                    // Normally we'd only need to check one of the fibers because if it\r\n                    // has ever gone from having children to deleting them or vice versa\r\n                    // it would have deleted the dehydrated boundary nested inside already.\r\n                    // However, since the HostRoot starts out with an alternate it might\r\n                    // have one on the alternate so we need to check in case this was a\r\n                    // root.\r\n                    var alternate = targetInst.alternate;\r\n                    if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\r\n                        // Next we need to figure out if the node that skipped past is\r\n                        // nested within a dehydrated boundary and if so, which one.\r\n                        var suspenseInstance = getParentSuspenseInstance(targetNode);\r\n                        while (suspenseInstance !== null) {\r\n                            // We found a suspense instance. That means that we haven't\r\n                            // hydrated it yet. Even though we leave the comments in the\r\n                            // DOM after hydrating, and there are boundaries in the DOM\r\n                            // that could already be hydrated, we wouldn't have found them\r\n                            // through this pass since if the target is hydrated it would\r\n                            // have had an internalInstanceKey on it.\r\n                            // Let's get the fiber associated with the SuspenseComponent\r\n                            // as the deepest instance.\r\n                            var targetSuspenseInst = suspenseInstance[internalInstanceKey];\r\n                            if (targetSuspenseInst) {\r\n                                return targetSuspenseInst;\r\n                            } // If we don't find a Fiber on the comment, it might be because\r\n                            // we haven't gotten to hydrate it yet. There might still be a\r\n                            // parent boundary that hasn't above this one so we need to find\r\n                            // the outer most that is known.\r\n                            suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent\r\n                            // host component also hasn't hydrated yet. We can return it\r\n                            // below since it will bail out on the isMounted check later.\r\n                        }\r\n                    }\r\n                    return targetInst;\r\n                }\r\n                targetNode = parentNode;\r\n                parentNode = targetNode.parentNode;\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\r\n         * instance, or null if the node was not rendered by this React.\r\n         */\r\n        function getInstanceFromNode(node) {\r\n            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\r\n            if (inst) {\r\n                if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\r\n                    return inst;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\r\n         * DOM node.\r\n         */\r\n        function getNodeFromInstance(inst) {\r\n            if (inst.tag === HostComponent || inst.tag === HostText) {\r\n                // In Fiber this, is just the state node right now. We assume it will be\r\n                // a host component or host text.\r\n                return inst.stateNode;\r\n            } // Without this first invariant, passing a non-DOM-component triggers the next\r\n            // invariant for a missing parent, which is super confusing.\r\n            {\r\n                {\r\n                    throw Error(\"getNodeFromInstance: Invalid argument.\");\r\n                }\r\n            }\r\n        }\r\n        function getFiberCurrentPropsFromNode(node) {\r\n            return node[internalPropsKey] || null;\r\n        }\r\n        function updateFiberProps(node, props) {\r\n            node[internalPropsKey] = props;\r\n        }\r\n        function getEventListenerSet(node) {\r\n            var elementListenerSet = node[internalEventHandlersKey];\r\n            if (elementListenerSet === undefined) {\r\n                elementListenerSet = node[internalEventHandlersKey] = new Set();\r\n            }\r\n            return elementListenerSet;\r\n        }\r\n        var loggedTypeFailures = {};\r\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n        function setCurrentlyValidatingElement(element) {\r\n            {\r\n                if (element) {\r\n                    var owner = element._owner;\r\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n                }\r\n                else {\r\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n                }\r\n            }\r\n        }\r\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n            {\r\n                // $FlowFixMe This is okay but Flow doesn't know it.\r\n                var has = Function.call.bind(Object.prototype.hasOwnProperty);\r\n                for (var typeSpecName in typeSpecs) {\r\n                    if (has(typeSpecs, typeSpecName)) {\r\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n                        // fail the render phase where it didn't fail before. So we log it.\r\n                        // After these have been cleaned up, we'll let them throw.\r\n                        try {\r\n                            // This is intentionally an invariant that gets caught. It's the same\r\n                            // behavior as without this statement except with a better message.\r\n                            if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n                                err.name = 'Invariant Violation';\r\n                                throw err;\r\n                            }\r\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n                        }\r\n                        catch (ex) {\r\n                            error$1 = ex;\r\n                        }\r\n                        if (error$1 && !(error$1 instanceof Error)) {\r\n                            setCurrentlyValidatingElement(element);\r\n                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n                            setCurrentlyValidatingElement(null);\r\n                        }\r\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n                            // Only monitor this failure once because there tends to be a lot of the\r\n                            // same error.\r\n                            loggedTypeFailures[error$1.message] = true;\r\n                            setCurrentlyValidatingElement(element);\r\n                            error('Failed %s type: %s', location, error$1.message);\r\n                            setCurrentlyValidatingElement(null);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var valueStack = [];\r\n        var fiberStack;\r\n        {\r\n            fiberStack = [];\r\n        }\r\n        var index = -1;\r\n        function createCursor(defaultValue) {\r\n            return {\r\n                current: defaultValue\r\n            };\r\n        }\r\n        function pop(cursor, fiber) {\r\n            if (index < 0) {\r\n                {\r\n                    error('Unexpected pop.');\r\n                }\r\n                return;\r\n            }\r\n            {\r\n                if (fiber !== fiberStack[index]) {\r\n                    error('Unexpected Fiber popped.');\r\n                }\r\n            }\r\n            cursor.current = valueStack[index];\r\n            valueStack[index] = null;\r\n            {\r\n                fiberStack[index] = null;\r\n            }\r\n            index--;\r\n        }\r\n        function push(cursor, value, fiber) {\r\n            index++;\r\n            valueStack[index] = cursor.current;\r\n            {\r\n                fiberStack[index] = fiber;\r\n            }\r\n            cursor.current = value;\r\n        }\r\n        var warnedAboutMissingGetChildContext;\r\n        {\r\n            warnedAboutMissingGetChildContext = {};\r\n        }\r\n        var emptyContextObject = {};\r\n        {\r\n            Object.freeze(emptyContextObject);\r\n        } // A cursor to the current merged context object on the stack.\r\n        var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\r\n        var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\r\n        // We use this to get access to the parent context after we have already\r\n        // pushed the next context provider, and now need to merge their contexts.\r\n        var previousContext = emptyContextObject;\r\n        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\r\n            {\r\n                if (didPushOwnContextIfProvider && isContextProvider(Component)) {\r\n                    // If the fiber is a context provider itself, when we read its context\r\n                    // we may have already pushed its own child context on the stack. A context\r\n                    // provider should not \"see\" its own child context. Therefore we read the\r\n                    // previous (parent) context instead for a context provider.\r\n                    return previousContext;\r\n                }\r\n                return contextStackCursor.current;\r\n            }\r\n        }\r\n        function cacheContext(workInProgress, unmaskedContext, maskedContext) {\r\n            {\r\n                var instance = workInProgress.stateNode;\r\n                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\r\n                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\r\n            }\r\n        }\r\n        function getMaskedContext(workInProgress, unmaskedContext) {\r\n            {\r\n                var type = workInProgress.type;\r\n                var contextTypes = type.contextTypes;\r\n                if (!contextTypes) {\r\n                    return emptyContextObject;\r\n                } // Avoid recreating masked context unless unmasked context has changed.\r\n                // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\r\n                // This may trigger infinite loops if componentWillReceiveProps calls setState.\r\n                var instance = workInProgress.stateNode;\r\n                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\r\n                    return instance.__reactInternalMemoizedMaskedChildContext;\r\n                }\r\n                var context = {};\r\n                for (var key in contextTypes) {\r\n                    context[key] = unmaskedContext[key];\r\n                }\r\n                {\r\n                    var name = getComponentName(type) || 'Unknown';\r\n                    checkPropTypes(contextTypes, context, 'context', name);\r\n                } // Cache unmasked context so we can avoid recreating masked context unless necessary.\r\n                // Context is created before the class component is instantiated so check for instance.\r\n                if (instance) {\r\n                    cacheContext(workInProgress, unmaskedContext, context);\r\n                }\r\n                return context;\r\n            }\r\n        }\r\n        function hasContextChanged() {\r\n            {\r\n                return didPerformWorkStackCursor.current;\r\n            }\r\n        }\r\n        function isContextProvider(type) {\r\n            {\r\n                var childContextTypes = type.childContextTypes;\r\n                return childContextTypes !== null && childContextTypes !== undefined;\r\n            }\r\n        }\r\n        function popContext(fiber) {\r\n            {\r\n                pop(didPerformWorkStackCursor, fiber);\r\n                pop(contextStackCursor, fiber);\r\n            }\r\n        }\r\n        function popTopLevelContextObject(fiber) {\r\n            {\r\n                pop(didPerformWorkStackCursor, fiber);\r\n                pop(contextStackCursor, fiber);\r\n            }\r\n        }\r\n        function pushTopLevelContextObject(fiber, context, didChange) {\r\n            {\r\n                if (!(contextStackCursor.current === emptyContextObject)) {\r\n                    {\r\n                        throw Error(\"Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                push(contextStackCursor, context, fiber);\r\n                push(didPerformWorkStackCursor, didChange, fiber);\r\n            }\r\n        }\r\n        function processChildContext(fiber, type, parentContext) {\r\n            {\r\n                var instance = fiber.stateNode;\r\n                var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\r\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\r\n                if (typeof instance.getChildContext !== 'function') {\r\n                    {\r\n                        var componentName = getComponentName(type) || 'Unknown';\r\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\r\n                            warnedAboutMissingGetChildContext[componentName] = true;\r\n                            error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\r\n                        }\r\n                    }\r\n                    return parentContext;\r\n                }\r\n                var childContext = instance.getChildContext();\r\n                for (var contextKey in childContext) {\r\n                    if (!(contextKey in childContextTypes)) {\r\n                        {\r\n                            throw Error((getComponentName(type) || 'Unknown') + \".getChildContext(): key \\\"\" + contextKey + \"\\\" is not defined in childContextTypes.\");\r\n                        }\r\n                    }\r\n                }\r\n                {\r\n                    var name = getComponentName(type) || 'Unknown';\r\n                    checkPropTypes(childContextTypes, childContext, 'child context', name);\r\n                }\r\n                return _assign({}, parentContext, childContext);\r\n            }\r\n        }\r\n        function pushContextProvider(workInProgress) {\r\n            {\r\n                var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\r\n                // If the instance does not exist yet, we will push null at first,\r\n                // and replace it on the stack later when invalidating the context.\r\n                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\r\n                // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\r\n                previousContext = contextStackCursor.current;\r\n                push(contextStackCursor, memoizedMergedChildContext, workInProgress);\r\n                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\r\n                return true;\r\n            }\r\n        }\r\n        function invalidateContextProvider(workInProgress, type, didChange) {\r\n            {\r\n                var instance = workInProgress.stateNode;\r\n                if (!instance) {\r\n                    {\r\n                        throw Error(\"Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                if (didChange) {\r\n                    // Merge parent and own context.\r\n                    // Skip this if we're not updating due to sCU.\r\n                    // This avoids unnecessarily recomputing memoized values.\r\n                    var mergedContext = processChildContext(workInProgress, type, previousContext);\r\n                    instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\r\n                    // It is important to unwind the context in the reverse order.\r\n                    pop(didPerformWorkStackCursor, workInProgress);\r\n                    pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\r\n                    push(contextStackCursor, mergedContext, workInProgress);\r\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\r\n                }\r\n                else {\r\n                    pop(didPerformWorkStackCursor, workInProgress);\r\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\r\n                }\r\n            }\r\n        }\r\n        function findCurrentUnmaskedContext(fiber) {\r\n            {\r\n                // Currently this is only used with renderSubtreeIntoContainer; not sure if it\r\n                // makes sense elsewhere\r\n                if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {\r\n                    {\r\n                        throw Error(\"Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                var node = fiber;\r\n                do {\r\n                    switch (node.tag) {\r\n                        case HostRoot:\r\n                            return node.stateNode.context;\r\n                        case ClassComponent:\r\n                            {\r\n                                var Component = node.type;\r\n                                if (isContextProvider(Component)) {\r\n                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\r\n                                }\r\n                                break;\r\n                            }\r\n                    }\r\n                    node = node.return;\r\n                } while (node !== null);\r\n                {\r\n                    {\r\n                        throw Error(\"Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var LegacyRoot = 0;\r\n        var BlockingRoot = 1;\r\n        var ConcurrentRoot = 2;\r\n        var rendererID = null;\r\n        var injectedHook = null;\r\n        var hasLoggedError = false;\r\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\r\n        function injectInternals(internals) {\r\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\r\n                // No DevTools\r\n                return false;\r\n            }\r\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n            if (hook.isDisabled) {\r\n                // This isn't a real property on the hook, but it can be set to opt out\r\n                // of DevTools integration and associated warnings and logs.\r\n                // https://github.com/facebook/react/issues/3877\r\n                return true;\r\n            }\r\n            if (!hook.supportsFiber) {\r\n                {\r\n                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');\r\n                } // DevTools exists, even though it doesn't support Fiber.\r\n                return true;\r\n            }\r\n            try {\r\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\r\n                injectedHook = hook;\r\n            }\r\n            catch (err) {\r\n                // Catch all errors because it is unsafe to throw during initialization.\r\n                {\r\n                    error('React instrumentation encountered an error: %s.', err);\r\n                }\r\n            } // DevTools exists\r\n            return true;\r\n        }\r\n        function onScheduleRoot(root, children) {\r\n            {\r\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\r\n                    try {\r\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\r\n                    }\r\n                    catch (err) {\r\n                        if (!hasLoggedError) {\r\n                            hasLoggedError = true;\r\n                            error('React instrumentation encountered an error: %s', err);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function onCommitRoot(root, priorityLevel) {\r\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\r\n                try {\r\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\r\n                    if (enableProfilerTimer) {\r\n                        injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);\r\n                    }\r\n                    else {\r\n                        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    {\r\n                        if (!hasLoggedError) {\r\n                            hasLoggedError = true;\r\n                            error('React instrumentation encountered an error: %s', err);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function onCommitUnmount(fiber) {\r\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\r\n                try {\r\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\r\n                }\r\n                catch (err) {\r\n                    {\r\n                        if (!hasLoggedError) {\r\n                            hasLoggedError = true;\r\n                            error('React instrumentation encountered an error: %s', err);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;\r\n        {\r\n            // Provide explicit error message when production+profiling bundle of e.g.\r\n            // react-dom is used with production (non-profiling) bundle of\r\n            // scheduler/tracing\r\n            if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {\r\n                {\r\n                    throw Error(\"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling\");\r\n                }\r\n            }\r\n        }\r\n        var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use\r\n        // ascending numbers so we can compare them like numbers. They start at 90 to\r\n        // avoid clashing with Scheduler's priorities.\r\n        var ImmediatePriority$1 = 99;\r\n        var UserBlockingPriority$2 = 98;\r\n        var NormalPriority$1 = 97;\r\n        var LowPriority$1 = 96;\r\n        var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.\r\n        var NoPriority$1 = 90;\r\n        var shouldYield = Scheduler_shouldYield;\r\n        var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.\r\n         Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function () { };\r\n        var syncQueue = null;\r\n        var immediateQueueCallbackNode = null;\r\n        var isFlushingSyncQueue = false;\r\n        var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.\r\n        // This will be the case for modern browsers that support `performance.now`. In\r\n        // older browsers, Scheduler falls back to `Date.now`, which returns a Unix\r\n        // timestamp. In that case, subtract the module initialization time to simulate\r\n        // the behavior of performance.now and keep our times small enough to fit\r\n        // within 32 bits.\r\n        // TODO: Consider lifting this into Scheduler.\r\n        var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function () {\r\n            return Scheduler_now$1() - initialTimeMs$1;\r\n        };\r\n        function getCurrentPriorityLevel() {\r\n            switch (Scheduler_getCurrentPriorityLevel()) {\r\n                case Scheduler_ImmediatePriority:\r\n                    return ImmediatePriority$1;\r\n                case Scheduler_UserBlockingPriority:\r\n                    return UserBlockingPriority$2;\r\n                case Scheduler_NormalPriority:\r\n                    return NormalPriority$1;\r\n                case Scheduler_LowPriority:\r\n                    return LowPriority$1;\r\n                case Scheduler_IdlePriority:\r\n                    return IdlePriority$1;\r\n                default:\r\n                    {\r\n                        {\r\n                            throw Error(\"Unknown priority level.\");\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        function reactPriorityToSchedulerPriority(reactPriorityLevel) {\r\n            switch (reactPriorityLevel) {\r\n                case ImmediatePriority$1:\r\n                    return Scheduler_ImmediatePriority;\r\n                case UserBlockingPriority$2:\r\n                    return Scheduler_UserBlockingPriority;\r\n                case NormalPriority$1:\r\n                    return Scheduler_NormalPriority;\r\n                case LowPriority$1:\r\n                    return Scheduler_LowPriority;\r\n                case IdlePriority$1:\r\n                    return Scheduler_IdlePriority;\r\n                default:\r\n                    {\r\n                        {\r\n                            throw Error(\"Unknown priority level.\");\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        function runWithPriority$1(reactPriorityLevel, fn) {\r\n            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\r\n            return Scheduler_runWithPriority(priorityLevel, fn);\r\n        }\r\n        function scheduleCallback(reactPriorityLevel, callback, options) {\r\n            var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\r\n            return Scheduler_scheduleCallback(priorityLevel, callback, options);\r\n        }\r\n        function scheduleSyncCallback(callback) {\r\n            // Push this callback into an internal queue. We'll flush these either in\r\n            // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\r\n            if (syncQueue === null) {\r\n                syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.\r\n                immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);\r\n            }\r\n            else {\r\n                // Push onto existing queue. Don't need to schedule a callback because\r\n                // we already scheduled one when we created the queue.\r\n                syncQueue.push(callback);\r\n            }\r\n            return fakeCallbackNode;\r\n        }\r\n        function cancelCallback(callbackNode) {\r\n            if (callbackNode !== fakeCallbackNode) {\r\n                Scheduler_cancelCallback(callbackNode);\r\n            }\r\n        }\r\n        function flushSyncCallbackQueue() {\r\n            if (immediateQueueCallbackNode !== null) {\r\n                var node = immediateQueueCallbackNode;\r\n                immediateQueueCallbackNode = null;\r\n                Scheduler_cancelCallback(node);\r\n            }\r\n            flushSyncCallbackQueueImpl();\r\n        }\r\n        function flushSyncCallbackQueueImpl() {\r\n            if (!isFlushingSyncQueue && syncQueue !== null) {\r\n                // Prevent re-entrancy.\r\n                isFlushingSyncQueue = true;\r\n                var i = 0;\r\n                {\r\n                    try {\r\n                        var _isSync2 = true;\r\n                        var _queue = syncQueue;\r\n                        runWithPriority$1(ImmediatePriority$1, function () {\r\n                            for (; i < _queue.length; i++) {\r\n                                var callback = _queue[i];\r\n                                do {\r\n                                    callback = callback(_isSync2);\r\n                                } while (callback !== null);\r\n                            }\r\n                        });\r\n                        syncQueue = null;\r\n                    }\r\n                    catch (error) {\r\n                        // If something throws, leave the remaining callbacks on the queue.\r\n                        if (syncQueue !== null) {\r\n                            syncQueue = syncQueue.slice(i + 1);\r\n                        } // Resume flushing in the next tick\r\n                        Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);\r\n                        throw error;\r\n                    }\r\n                    finally {\r\n                        isFlushingSyncQueue = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // TODO: this is special because it gets imported during build.\r\n        var ReactVersion = '17.0.1';\r\n        var NoMode = 0;\r\n        var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root\r\n        // tag instead\r\n        var BlockingMode = 2;\r\n        var ConcurrentMode = 4;\r\n        var ProfileMode = 8;\r\n        var DebugTracingMode = 16;\r\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\r\n        var NoTransition = 0;\r\n        function requestCurrentTransition() {\r\n            return ReactCurrentBatchConfig.transition;\r\n        }\r\n        var ReactStrictModeWarnings = {\r\n            recordUnsafeLifecycleWarnings: function (fiber, instance) { },\r\n            flushPendingUnsafeLifecycleWarnings: function () { },\r\n            recordLegacyContextWarning: function (fiber, instance) { },\r\n            flushLegacyContextWarning: function () { },\r\n            discardPendingWarnings: function () { }\r\n        };\r\n        {\r\n            var findStrictRoot = function (fiber) {\r\n                var maybeStrictRoot = null;\r\n                var node = fiber;\r\n                while (node !== null) {\r\n                    if (node.mode & StrictMode) {\r\n                        maybeStrictRoot = node;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                return maybeStrictRoot;\r\n            };\r\n            var setToSortedString = function (set) {\r\n                var array = [];\r\n                set.forEach(function (value) {\r\n                    array.push(value);\r\n                });\r\n                return array.sort().join(', ');\r\n            };\r\n            var pendingComponentWillMountWarnings = [];\r\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\r\n            var pendingComponentWillReceivePropsWarnings = [];\r\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\r\n            var pendingComponentWillUpdateWarnings = [];\r\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\r\n            var didWarnAboutUnsafeLifecycles = new Set();\r\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\r\n                // Dedup strategy: Warn once per component.\r\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\r\n                    return;\r\n                }\r\n                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\r\n                    instance.componentWillMount.__suppressDeprecationWarning !== true) {\r\n                    pendingComponentWillMountWarnings.push(fiber);\r\n                }\r\n                if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') {\r\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\r\n                }\r\n                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\r\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\r\n                }\r\n                if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\r\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\r\n                }\r\n                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\r\n                    pendingComponentWillUpdateWarnings.push(fiber);\r\n                }\r\n                if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\r\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\r\n                }\r\n            };\r\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\r\n                // We do an initial pass to gather component names\r\n                var componentWillMountUniqueNames = new Set();\r\n                if (pendingComponentWillMountWarnings.length > 0) {\r\n                    pendingComponentWillMountWarnings.forEach(function (fiber) {\r\n                        componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingComponentWillMountWarnings = [];\r\n                }\r\n                var UNSAFE_componentWillMountUniqueNames = new Set();\r\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\r\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {\r\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\r\n                }\r\n                var componentWillReceivePropsUniqueNames = new Set();\r\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\r\n                    pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\r\n                        componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingComponentWillReceivePropsWarnings = [];\r\n                }\r\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\r\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\r\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {\r\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\r\n                }\r\n                var componentWillUpdateUniqueNames = new Set();\r\n                if (pendingComponentWillUpdateWarnings.length > 0) {\r\n                    pendingComponentWillUpdateWarnings.forEach(function (fiber) {\r\n                        componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingComponentWillUpdateWarnings = [];\r\n                }\r\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\r\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\r\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {\r\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\r\n                    });\r\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\r\n                } // Finally, we flush all the warnings\r\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\r\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\r\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\r\n                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\r\n                }\r\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\r\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\r\n                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\r\n                }\r\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\r\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\r\n                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\r\n                }\r\n                if (componentWillMountUniqueNames.size > 0) {\r\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\r\n                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\r\n                }\r\n                if (componentWillReceivePropsUniqueNames.size > 0) {\r\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\r\n                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\r\n                }\r\n                if (componentWillUpdateUniqueNames.size > 0) {\r\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\r\n                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\r\n                }\r\n            };\r\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\r\n            var didWarnAboutLegacyContext = new Set();\r\n            ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\r\n                var strictRoot = findStrictRoot(fiber);\r\n                if (strictRoot === null) {\r\n                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\r\n                    return;\r\n                } // Dedup strategy: Warn once per component.\r\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\r\n                    return;\r\n                }\r\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\r\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\r\n                    if (warningsForRoot === undefined) {\r\n                        warningsForRoot = [];\r\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\r\n                    }\r\n                    warningsForRoot.push(fiber);\r\n                }\r\n            };\r\n            ReactStrictModeWarnings.flushLegacyContextWarning = function () {\r\n                pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\r\n                    if (fiberArray.length === 0) {\r\n                        return;\r\n                    }\r\n                    var firstFiber = fiberArray[0];\r\n                    var uniqueNames = new Set();\r\n                    fiberArray.forEach(function (fiber) {\r\n                        uniqueNames.add(getComponentName(fiber.type) || 'Component');\r\n                        didWarnAboutLegacyContext.add(fiber.type);\r\n                    });\r\n                    var sortedNames = setToSortedString(uniqueNames);\r\n                    try {\r\n                        setCurrentFiber(firstFiber);\r\n                        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);\r\n                    }\r\n                    finally {\r\n                        resetCurrentFiber();\r\n                    }\r\n                });\r\n            };\r\n            ReactStrictModeWarnings.discardPendingWarnings = function () {\r\n                pendingComponentWillMountWarnings = [];\r\n                pendingUNSAFE_ComponentWillMountWarnings = [];\r\n                pendingComponentWillReceivePropsWarnings = [];\r\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\r\n                pendingComponentWillUpdateWarnings = [];\r\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\r\n                pendingLegacyContextWarning = new Map();\r\n            };\r\n        }\r\n        function resolveDefaultProps(Component, baseProps) {\r\n            if (Component && Component.defaultProps) {\r\n                // Resolve default props. Taken from ReactElement\r\n                var props = _assign({}, baseProps);\r\n                var defaultProps = Component.defaultProps;\r\n                for (var propName in defaultProps) {\r\n                    if (props[propName] === undefined) {\r\n                        props[propName] = defaultProps[propName];\r\n                    }\r\n                }\r\n                return props;\r\n            }\r\n            return baseProps;\r\n        }\r\n        // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n        // Math.pow(2, 30) - 1\r\n        // 0b111111111111111111111111111111\r\n        var MAX_SIGNED_31_BIT_INT = 1073741823;\r\n        var valueCursor = createCursor(null);\r\n        var rendererSigil;\r\n        {\r\n            // Use this to detect multiple renderers using the same context\r\n            rendererSigil = {};\r\n        }\r\n        var currentlyRenderingFiber = null;\r\n        var lastContextDependency = null;\r\n        var lastContextWithAllBitsObserved = null;\r\n        var isDisallowedContextReadInDEV = false;\r\n        function resetContextDependencies() {\r\n            // This is called right before React yields execution, to ensure `readContext`\r\n            // cannot be called outside the render phase.\r\n            currentlyRenderingFiber = null;\r\n            lastContextDependency = null;\r\n            lastContextWithAllBitsObserved = null;\r\n            {\r\n                isDisallowedContextReadInDEV = false;\r\n            }\r\n        }\r\n        function enterDisallowedContextReadInDEV() {\r\n            {\r\n                isDisallowedContextReadInDEV = true;\r\n            }\r\n        }\r\n        function exitDisallowedContextReadInDEV() {\r\n            {\r\n                isDisallowedContextReadInDEV = false;\r\n            }\r\n        }\r\n        function pushProvider(providerFiber, nextValue) {\r\n            var context = providerFiber.type._context;\r\n            {\r\n                push(valueCursor, context._currentValue, providerFiber);\r\n                context._currentValue = nextValue;\r\n                {\r\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\r\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\r\n                    }\r\n                    context._currentRenderer = rendererSigil;\r\n                }\r\n            }\r\n        }\r\n        function popProvider(providerFiber) {\r\n            var currentValue = valueCursor.current;\r\n            pop(valueCursor, providerFiber);\r\n            var context = providerFiber.type._context;\r\n            {\r\n                context._currentValue = currentValue;\r\n            }\r\n        }\r\n        function calculateChangedBits(context, newValue, oldValue) {\r\n            if (objectIs(oldValue, newValue)) {\r\n                // No change\r\n                return 0;\r\n            }\r\n            else {\r\n                var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;\r\n                {\r\n                    if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {\r\n                        error('calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);\r\n                    }\r\n                }\r\n                return changedBits | 0;\r\n            }\r\n        }\r\n        function scheduleWorkOnParentPath(parent, renderLanes) {\r\n            // Update the child lanes of all the ancestors, including the alternates.\r\n            var node = parent;\r\n            while (node !== null) {\r\n                var alternate = node.alternate;\r\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\r\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\r\n                    if (alternate !== null) {\r\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\r\n                    }\r\n                }\r\n                else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\r\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\r\n                }\r\n                else {\r\n                    // Neither alternate was updated, which means the rest of the\r\n                    // ancestor path already has sufficient priority.\r\n                    break;\r\n                }\r\n                node = node.return;\r\n            }\r\n        }\r\n        function propagateContextChange(workInProgress, context, changedBits, renderLanes) {\r\n            var fiber = workInProgress.child;\r\n            if (fiber !== null) {\r\n                // Set the return pointer of the child to the work-in-progress fiber.\r\n                fiber.return = workInProgress;\r\n            }\r\n            while (fiber !== null) {\r\n                var nextFiber = void 0; // Visit this fiber.\r\n                var list = fiber.dependencies;\r\n                if (list !== null) {\r\n                    nextFiber = fiber.child;\r\n                    var dependency = list.firstContext;\r\n                    while (dependency !== null) {\r\n                        // Check if the context matches.\r\n                        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {\r\n                            // Match! Schedule an update on this fiber.\r\n                            if (fiber.tag === ClassComponent) {\r\n                                // Schedule a force update on the work-in-progress.\r\n                                var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));\r\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\r\n                                // update to the current fiber, too, which means it will persist even if\r\n                                // this render is thrown away. Since it's a race condition, not sure it's\r\n                                // worth fixing.\r\n                                enqueueUpdate(fiber, update);\r\n                            }\r\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\r\n                            var alternate = fiber.alternate;\r\n                            if (alternate !== null) {\r\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\r\n                            }\r\n                            scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.\r\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\r\n                            // dependency list.\r\n                            break;\r\n                        }\r\n                        dependency = dependency.next;\r\n                    }\r\n                }\r\n                else if (fiber.tag === ContextProvider) {\r\n                    // Don't scan deeper if this is a matching provider\r\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\r\n                }\r\n                else {\r\n                    // Traverse down.\r\n                    nextFiber = fiber.child;\r\n                }\r\n                if (nextFiber !== null) {\r\n                    // Set the return pointer of the child to the work-in-progress fiber.\r\n                    nextFiber.return = fiber;\r\n                }\r\n                else {\r\n                    // No child. Traverse to next sibling.\r\n                    nextFiber = fiber;\r\n                    while (nextFiber !== null) {\r\n                        if (nextFiber === workInProgress) {\r\n                            // We're back to the root of this subtree. Exit.\r\n                            nextFiber = null;\r\n                            break;\r\n                        }\r\n                        var sibling = nextFiber.sibling;\r\n                        if (sibling !== null) {\r\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\r\n                            sibling.return = nextFiber.return;\r\n                            nextFiber = sibling;\r\n                            break;\r\n                        } // No more siblings. Traverse up.\r\n                        nextFiber = nextFiber.return;\r\n                    }\r\n                }\r\n                fiber = nextFiber;\r\n            }\r\n        }\r\n        function prepareToReadContext(workInProgress, renderLanes) {\r\n            currentlyRenderingFiber = workInProgress;\r\n            lastContextDependency = null;\r\n            lastContextWithAllBitsObserved = null;\r\n            var dependencies = workInProgress.dependencies;\r\n            if (dependencies !== null) {\r\n                var firstContext = dependencies.firstContext;\r\n                if (firstContext !== null) {\r\n                    if (includesSomeLane(dependencies.lanes, renderLanes)) {\r\n                        // Context list has a pending update. Mark that this fiber performed work.\r\n                        markWorkInProgressReceivedUpdate();\r\n                    } // Reset the work-in-progress list\r\n                    dependencies.firstContext = null;\r\n                }\r\n            }\r\n        }\r\n        function readContext(context, observedBits) {\r\n            {\r\n                // This warning would fire if you read context inside a Hook like useMemo.\r\n                // Unlike the class check below, it's not enforced in production for perf.\r\n                if (isDisallowedContextReadInDEV) {\r\n                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\r\n                }\r\n            }\r\n            if (lastContextWithAllBitsObserved === context)\r\n                ;\r\n            else if (observedBits === false || observedBits === 0)\r\n                ;\r\n            else {\r\n                var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.\r\n                if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {\r\n                    // Observe all updates.\r\n                    lastContextWithAllBitsObserved = context;\r\n                    resolvedObservedBits = MAX_SIGNED_31_BIT_INT;\r\n                }\r\n                else {\r\n                    resolvedObservedBits = observedBits;\r\n                }\r\n                var contextItem = {\r\n                    context: context,\r\n                    observedBits: resolvedObservedBits,\r\n                    next: null\r\n                };\r\n                if (lastContextDependency === null) {\r\n                    if (!(currentlyRenderingFiber !== null)) {\r\n                        {\r\n                            throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\r\n                        }\r\n                    } // This is the first dependency for this component. Create a new list.\r\n                    lastContextDependency = contextItem;\r\n                    currentlyRenderingFiber.dependencies = {\r\n                        lanes: NoLanes,\r\n                        firstContext: contextItem,\r\n                        responders: null\r\n                    };\r\n                }\r\n                else {\r\n                    // Append a new context item.\r\n                    lastContextDependency = lastContextDependency.next = contextItem;\r\n                }\r\n            }\r\n            return context._currentValue;\r\n        }\r\n        var UpdateState = 0;\r\n        var ReplaceState = 1;\r\n        var ForceUpdate = 2;\r\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\r\n        // It should only be read right after calling `processUpdateQueue`, via\r\n        // `checkHasForceUpdateAfterProcessing`.\r\n        var hasForceUpdate = false;\r\n        var didWarnUpdateInsideUpdate;\r\n        var currentlyProcessingQueue;\r\n        {\r\n            didWarnUpdateInsideUpdate = false;\r\n            currentlyProcessingQueue = null;\r\n        }\r\n        function initializeUpdateQueue(fiber) {\r\n            var queue = {\r\n                baseState: fiber.memoizedState,\r\n                firstBaseUpdate: null,\r\n                lastBaseUpdate: null,\r\n                shared: {\r\n                    pending: null\r\n                },\r\n                effects: null\r\n            };\r\n            fiber.updateQueue = queue;\r\n        }\r\n        function cloneUpdateQueue(current, workInProgress) {\r\n            // Clone the update queue from current. Unless it's already a clone.\r\n            var queue = workInProgress.updateQueue;\r\n            var currentQueue = current.updateQueue;\r\n            if (queue === currentQueue) {\r\n                var clone = {\r\n                    baseState: currentQueue.baseState,\r\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\r\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\r\n                    shared: currentQueue.shared,\r\n                    effects: currentQueue.effects\r\n                };\r\n                workInProgress.updateQueue = clone;\r\n            }\r\n        }\r\n        function createUpdate(eventTime, lane) {\r\n            var update = {\r\n                eventTime: eventTime,\r\n                lane: lane,\r\n                tag: UpdateState,\r\n                payload: null,\r\n                callback: null,\r\n                next: null\r\n            };\r\n            return update;\r\n        }\r\n        function enqueueUpdate(fiber, update) {\r\n            var updateQueue = fiber.updateQueue;\r\n            if (updateQueue === null) {\r\n                // Only occurs if the fiber has been unmounted.\r\n                return;\r\n            }\r\n            var sharedQueue = updateQueue.shared;\r\n            var pending = sharedQueue.pending;\r\n            if (pending === null) {\r\n                // This is the first update. Create a circular list.\r\n                update.next = update;\r\n            }\r\n            else {\r\n                update.next = pending.next;\r\n                pending.next = update;\r\n            }\r\n            sharedQueue.pending = update;\r\n            {\r\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\r\n                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\r\n                    didWarnUpdateInsideUpdate = true;\r\n                }\r\n            }\r\n        }\r\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\r\n            // Captured updates are updates that are thrown by a child during the render\r\n            // phase. They should be discarded if the render is aborted. Therefore,\r\n            // we should only put them on the work-in-progress queue, not the current one.\r\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\r\n            var current = workInProgress.alternate;\r\n            if (current !== null) {\r\n                var currentQueue = current.updateQueue;\r\n                if (queue === currentQueue) {\r\n                    // The work-in-progress queue is the same as current. This happens when\r\n                    // we bail out on a parent fiber that then captures an error thrown by\r\n                    // a child. Since we want to append the update only to the work-in\r\n                    // -progress queue, we need to clone the updates. We usually clone during\r\n                    // processUpdateQueue, but that didn't happen in this case because we\r\n                    // skipped over the parent when we bailed out.\r\n                    var newFirst = null;\r\n                    var newLast = null;\r\n                    var firstBaseUpdate = queue.firstBaseUpdate;\r\n                    if (firstBaseUpdate !== null) {\r\n                        // Loop through the updates and clone them.\r\n                        var update = firstBaseUpdate;\r\n                        do {\r\n                            var clone = {\r\n                                eventTime: update.eventTime,\r\n                                lane: update.lane,\r\n                                tag: update.tag,\r\n                                payload: update.payload,\r\n                                callback: update.callback,\r\n                                next: null\r\n                            };\r\n                            if (newLast === null) {\r\n                                newFirst = newLast = clone;\r\n                            }\r\n                            else {\r\n                                newLast.next = clone;\r\n                                newLast = clone;\r\n                            }\r\n                            update = update.next;\r\n                        } while (update !== null); // Append the captured update the end of the cloned list.\r\n                        if (newLast === null) {\r\n                            newFirst = newLast = capturedUpdate;\r\n                        }\r\n                        else {\r\n                            newLast.next = capturedUpdate;\r\n                            newLast = capturedUpdate;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // There are no base updates.\r\n                        newFirst = newLast = capturedUpdate;\r\n                    }\r\n                    queue = {\r\n                        baseState: currentQueue.baseState,\r\n                        firstBaseUpdate: newFirst,\r\n                        lastBaseUpdate: newLast,\r\n                        shared: currentQueue.shared,\r\n                        effects: currentQueue.effects\r\n                    };\r\n                    workInProgress.updateQueue = queue;\r\n                    return;\r\n                }\r\n            } // Append the update to the end of the list.\r\n            var lastBaseUpdate = queue.lastBaseUpdate;\r\n            if (lastBaseUpdate === null) {\r\n                queue.firstBaseUpdate = capturedUpdate;\r\n            }\r\n            else {\r\n                lastBaseUpdate.next = capturedUpdate;\r\n            }\r\n            queue.lastBaseUpdate = capturedUpdate;\r\n        }\r\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\r\n            switch (update.tag) {\r\n                case ReplaceState:\r\n                    {\r\n                        var payload = update.payload;\r\n                        if (typeof payload === 'function') {\r\n                            // Updater function\r\n                            {\r\n                                enterDisallowedContextReadInDEV();\r\n                            }\r\n                            var nextState = payload.call(instance, prevState, nextProps);\r\n                            {\r\n                                if (workInProgress.mode & StrictMode) {\r\n                                    disableLogs();\r\n                                    try {\r\n                                        payload.call(instance, prevState, nextProps);\r\n                                    }\r\n                                    finally {\r\n                                        reenableLogs();\r\n                                    }\r\n                                }\r\n                                exitDisallowedContextReadInDEV();\r\n                            }\r\n                            return nextState;\r\n                        } // State object\r\n                        return payload;\r\n                    }\r\n                case CaptureUpdate:\r\n                    {\r\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\r\n                    }\r\n                // Intentional fallthrough\r\n                case UpdateState:\r\n                    {\r\n                        var _payload = update.payload;\r\n                        var partialState;\r\n                        if (typeof _payload === 'function') {\r\n                            // Updater function\r\n                            {\r\n                                enterDisallowedContextReadInDEV();\r\n                            }\r\n                            partialState = _payload.call(instance, prevState, nextProps);\r\n                            {\r\n                                if (workInProgress.mode & StrictMode) {\r\n                                    disableLogs();\r\n                                    try {\r\n                                        _payload.call(instance, prevState, nextProps);\r\n                                    }\r\n                                    finally {\r\n                                        reenableLogs();\r\n                                    }\r\n                                }\r\n                                exitDisallowedContextReadInDEV();\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Partial state object\r\n                            partialState = _payload;\r\n                        }\r\n                        if (partialState === null || partialState === undefined) {\r\n                            // Null and undefined are treated as no-ops.\r\n                            return prevState;\r\n                        } // Merge the partial state and the previous state.\r\n                        return _assign({}, prevState, partialState);\r\n                    }\r\n                case ForceUpdate:\r\n                    {\r\n                        hasForceUpdate = true;\r\n                        return prevState;\r\n                    }\r\n            }\r\n            return prevState;\r\n        }\r\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\r\n            // This is always non-null on a ClassComponent or HostRoot\r\n            var queue = workInProgress.updateQueue;\r\n            hasForceUpdate = false;\r\n            {\r\n                currentlyProcessingQueue = queue.shared;\r\n            }\r\n            var firstBaseUpdate = queue.firstBaseUpdate;\r\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\r\n            var pendingQueue = queue.shared.pending;\r\n            if (pendingQueue !== null) {\r\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\r\n                // and last so that it's non-circular.\r\n                var lastPendingUpdate = pendingQueue;\r\n                var firstPendingUpdate = lastPendingUpdate.next;\r\n                lastPendingUpdate.next = null; // Append pending updates to base queue\r\n                if (lastBaseUpdate === null) {\r\n                    firstBaseUpdate = firstPendingUpdate;\r\n                }\r\n                else {\r\n                    lastBaseUpdate.next = firstPendingUpdate;\r\n                }\r\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\r\n                // we need to transfer the updates to that queue, too. Because the base\r\n                // queue is a singly-linked list with no cycles, we can append to both\r\n                // lists and take advantage of structural sharing.\r\n                // TODO: Pass `current` as argument\r\n                var current = workInProgress.alternate;\r\n                if (current !== null) {\r\n                    // This is always non-null on a ClassComponent or HostRoot\r\n                    var currentQueue = current.updateQueue;\r\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\r\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\r\n                        if (currentLastBaseUpdate === null) {\r\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\r\n                        }\r\n                        else {\r\n                            currentLastBaseUpdate.next = firstPendingUpdate;\r\n                        }\r\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\r\n                    }\r\n                }\r\n            } // These values may change as we process the queue.\r\n            if (firstBaseUpdate !== null) {\r\n                // Iterate through the list of updates to compute the result.\r\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\r\n                // from the original lanes.\r\n                var newLanes = NoLanes;\r\n                var newBaseState = null;\r\n                var newFirstBaseUpdate = null;\r\n                var newLastBaseUpdate = null;\r\n                var update = firstBaseUpdate;\r\n                do {\r\n                    var updateLane = update.lane;\r\n                    var updateEventTime = update.eventTime;\r\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\r\n                        // Priority is insufficient. Skip this update. If this is the first\r\n                        // skipped update, the previous update/state is the new base\r\n                        // update/state.\r\n                        var clone = {\r\n                            eventTime: updateEventTime,\r\n                            lane: updateLane,\r\n                            tag: update.tag,\r\n                            payload: update.payload,\r\n                            callback: update.callback,\r\n                            next: null\r\n                        };\r\n                        if (newLastBaseUpdate === null) {\r\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\r\n                            newBaseState = newState;\r\n                        }\r\n                        else {\r\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\r\n                        } // Update the remaining priority in the queue.\r\n                        newLanes = mergeLanes(newLanes, updateLane);\r\n                    }\r\n                    else {\r\n                        // This update does have sufficient priority.\r\n                        if (newLastBaseUpdate !== null) {\r\n                            var _clone = {\r\n                                eventTime: updateEventTime,\r\n                                // This update is going to be committed so we never want uncommit\r\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\r\n                                // this will never be skipped by the check above.\r\n                                lane: NoLane,\r\n                                tag: update.tag,\r\n                                payload: update.payload,\r\n                                callback: update.callback,\r\n                                next: null\r\n                            };\r\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\r\n                        } // Process this update.\r\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\r\n                        var callback = update.callback;\r\n                        if (callback !== null) {\r\n                            workInProgress.flags |= Callback;\r\n                            var effects = queue.effects;\r\n                            if (effects === null) {\r\n                                queue.effects = [update];\r\n                            }\r\n                            else {\r\n                                effects.push(update);\r\n                            }\r\n                        }\r\n                    }\r\n                    update = update.next;\r\n                    if (update === null) {\r\n                        pendingQueue = queue.shared.pending;\r\n                        if (pendingQueue === null) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            // An update was scheduled from inside a reducer. Add the new\r\n                            // pending updates to the end of the list and keep processing.\r\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\r\n                            // unravel them when transferring them to the base queue.\r\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\r\n                            _lastPendingUpdate.next = null;\r\n                            update = _firstPendingUpdate;\r\n                            queue.lastBaseUpdate = _lastPendingUpdate;\r\n                            queue.shared.pending = null;\r\n                        }\r\n                    }\r\n                } while (true);\r\n                if (newLastBaseUpdate === null) {\r\n                    newBaseState = newState;\r\n                }\r\n                queue.baseState = newBaseState;\r\n                queue.firstBaseUpdate = newFirstBaseUpdate;\r\n                queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.\r\n                // This should be fine because the only two other things that contribute to\r\n                // expiration time are props and context. We're already in the middle of the\r\n                // begin phase by the time we start processing the queue, so we've already\r\n                // dealt with the props. Context in components that specify\r\n                // shouldComponentUpdate is tricky; but we'll have to account for\r\n                // that regardless.\r\n                markSkippedUpdateLanes(newLanes);\r\n                workInProgress.lanes = newLanes;\r\n                workInProgress.memoizedState = newState;\r\n            }\r\n            {\r\n                currentlyProcessingQueue = null;\r\n            }\r\n        }\r\n        function callCallback(callback, context) {\r\n            if (!(typeof callback === 'function')) {\r\n                {\r\n                    throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\r\n                }\r\n            }\r\n            callback.call(context);\r\n        }\r\n        function resetHasForceUpdateBeforeProcessing() {\r\n            hasForceUpdate = false;\r\n        }\r\n        function checkHasForceUpdateAfterProcessing() {\r\n            return hasForceUpdate;\r\n        }\r\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\r\n            // Commit the effects\r\n            var effects = finishedQueue.effects;\r\n            finishedQueue.effects = null;\r\n            if (effects !== null) {\r\n                for (var i = 0; i < effects.length; i++) {\r\n                    var effect = effects[i];\r\n                    var callback = effect.callback;\r\n                    if (callback !== null) {\r\n                        effect.callback = null;\r\n                        callCallback(callback, instance);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var fakeInternalInstance = {};\r\n        var isArray = Array.isArray; // React.Component uses a shared frozen object by default.\r\n        // We'll use it to determine whether we need to initialize legacy refs.\r\n        var emptyRefsObject = new React.Component().refs;\r\n        var didWarnAboutStateAssignmentForComponent;\r\n        var didWarnAboutUninitializedState;\r\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\r\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\r\n        var didWarnAboutUndefinedDerivedState;\r\n        var warnOnUndefinedDerivedState;\r\n        var warnOnInvalidCallback;\r\n        var didWarnAboutDirectlyAssigningPropsToState;\r\n        var didWarnAboutContextTypeAndContextTypes;\r\n        var didWarnAboutInvalidateContextType;\r\n        {\r\n            didWarnAboutStateAssignmentForComponent = new Set();\r\n            didWarnAboutUninitializedState = new Set();\r\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\r\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\r\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\r\n            didWarnAboutUndefinedDerivedState = new Set();\r\n            didWarnAboutContextTypeAndContextTypes = new Set();\r\n            didWarnAboutInvalidateContextType = new Set();\r\n            var didWarnOnInvalidCallback = new Set();\r\n            warnOnInvalidCallback = function (callback, callerName) {\r\n                if (callback === null || typeof callback === 'function') {\r\n                    return;\r\n                }\r\n                var key = callerName + '_' + callback;\r\n                if (!didWarnOnInvalidCallback.has(key)) {\r\n                    didWarnOnInvalidCallback.add(key);\r\n                    error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\r\n                }\r\n            };\r\n            warnOnUndefinedDerivedState = function (type, partialState) {\r\n                if (partialState === undefined) {\r\n                    var componentName = getComponentName(type) || 'Component';\r\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\r\n                        didWarnAboutUndefinedDerivedState.add(componentName);\r\n                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\r\n                    }\r\n                }\r\n            }; // This is so gross but it's at least non-critical and can be removed if\r\n            // it causes problems. This is meant to give a nicer error message for\r\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\r\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\r\n            // exception.\r\n            Object.defineProperty(fakeInternalInstance, '_processChildContext', {\r\n                enumerable: false,\r\n                value: function () {\r\n                    {\r\n                        {\r\n                            throw Error(\"_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).\");\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            Object.freeze(fakeInternalInstance);\r\n        }\r\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\r\n            var prevState = workInProgress.memoizedState;\r\n            {\r\n                if (workInProgress.mode & StrictMode) {\r\n                    disableLogs();\r\n                    try {\r\n                        // Invoke the function an extra time to help detect side-effects.\r\n                        getDerivedStateFromProps(nextProps, prevState);\r\n                    }\r\n                    finally {\r\n                        reenableLogs();\r\n                    }\r\n                }\r\n            }\r\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\r\n            {\r\n                warnOnUndefinedDerivedState(ctor, partialState);\r\n            } // Merge the partial state and the previous state.\r\n            var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);\r\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\r\n            // base state.\r\n            if (workInProgress.lanes === NoLanes) {\r\n                // Queue is always non-null for classes\r\n                var updateQueue = workInProgress.updateQueue;\r\n                updateQueue.baseState = memoizedState;\r\n            }\r\n        }\r\n        var classComponentUpdater = {\r\n            isMounted: isMounted,\r\n            enqueueSetState: function (inst, payload, callback) {\r\n                var fiber = get(inst);\r\n                var eventTime = requestEventTime();\r\n                var lane = requestUpdateLane(fiber);\r\n                var update = createUpdate(eventTime, lane);\r\n                update.payload = payload;\r\n                if (callback !== undefined && callback !== null) {\r\n                    {\r\n                        warnOnInvalidCallback(callback, 'setState');\r\n                    }\r\n                    update.callback = callback;\r\n                }\r\n                enqueueUpdate(fiber, update);\r\n                scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            },\r\n            enqueueReplaceState: function (inst, payload, callback) {\r\n                var fiber = get(inst);\r\n                var eventTime = requestEventTime();\r\n                var lane = requestUpdateLane(fiber);\r\n                var update = createUpdate(eventTime, lane);\r\n                update.tag = ReplaceState;\r\n                update.payload = payload;\r\n                if (callback !== undefined && callback !== null) {\r\n                    {\r\n                        warnOnInvalidCallback(callback, 'replaceState');\r\n                    }\r\n                    update.callback = callback;\r\n                }\r\n                enqueueUpdate(fiber, update);\r\n                scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            },\r\n            enqueueForceUpdate: function (inst, callback) {\r\n                var fiber = get(inst);\r\n                var eventTime = requestEventTime();\r\n                var lane = requestUpdateLane(fiber);\r\n                var update = createUpdate(eventTime, lane);\r\n                update.tag = ForceUpdate;\r\n                if (callback !== undefined && callback !== null) {\r\n                    {\r\n                        warnOnInvalidCallback(callback, 'forceUpdate');\r\n                    }\r\n                    update.callback = callback;\r\n                }\r\n                enqueueUpdate(fiber, update);\r\n                scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            }\r\n        };\r\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\r\n            var instance = workInProgress.stateNode;\r\n            if (typeof instance.shouldComponentUpdate === 'function') {\r\n                {\r\n                    if (workInProgress.mode & StrictMode) {\r\n                        disableLogs();\r\n                        try {\r\n                            // Invoke the function an extra time to help detect side-effects.\r\n                            instance.shouldComponentUpdate(newProps, newState, nextContext);\r\n                        }\r\n                        finally {\r\n                            reenableLogs();\r\n                        }\r\n                    }\r\n                }\r\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\r\n                {\r\n                    if (shouldUpdate === undefined) {\r\n                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');\r\n                    }\r\n                }\r\n                return shouldUpdate;\r\n            }\r\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\r\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\r\n            }\r\n            return true;\r\n        }\r\n        function checkClassInstance(workInProgress, ctor, newProps) {\r\n            var instance = workInProgress.stateNode;\r\n            {\r\n                var name = getComponentName(ctor) || 'Component';\r\n                var renderPresent = instance.render;\r\n                if (!renderPresent) {\r\n                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {\r\n                        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\r\n                    }\r\n                    else {\r\n                        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\r\n                    }\r\n                }\r\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\r\n                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\r\n                }\r\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\r\n                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\r\n                }\r\n                if (instance.propTypes) {\r\n                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\r\n                }\r\n                if (instance.contextType) {\r\n                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\r\n                }\r\n                {\r\n                    if (instance.contextTypes) {\r\n                        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\r\n                    }\r\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\r\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\r\n                        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\r\n                    }\r\n                }\r\n                if (typeof instance.componentShouldUpdate === 'function') {\r\n                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\r\n                }\r\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\r\n                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');\r\n                }\r\n                if (typeof instance.componentDidUnmount === 'function') {\r\n                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\r\n                }\r\n                if (typeof instance.componentDidReceiveProps === 'function') {\r\n                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\r\n                }\r\n                if (typeof instance.componentWillRecieveProps === 'function') {\r\n                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\r\n                }\r\n                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\r\n                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\r\n                }\r\n                var hasMutatedProps = instance.props !== newProps;\r\n                if (instance.props !== undefined && hasMutatedProps) {\r\n                    error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\r\n                }\r\n                if (instance.defaultProps) {\r\n                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\r\n                }\r\n                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\r\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\r\n                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));\r\n                }\r\n                if (typeof instance.getDerivedStateFromProps === 'function') {\r\n                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\r\n                }\r\n                if (typeof instance.getDerivedStateFromError === 'function') {\r\n                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\r\n                }\r\n                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\r\n                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\r\n                }\r\n                var _state = instance.state;\r\n                if (_state && (typeof _state !== 'object' || isArray(_state))) {\r\n                    error('%s.state: must be set to an object or null', name);\r\n                }\r\n                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\r\n                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\r\n                }\r\n            }\r\n        }\r\n        function adoptClassInstance(workInProgress, instance) {\r\n            instance.updater = classComponentUpdater;\r\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\r\n            set(instance, workInProgress);\r\n            {\r\n                instance._reactInternalInstance = fakeInternalInstance;\r\n            }\r\n        }\r\n        function constructClassInstance(workInProgress, ctor, props) {\r\n            var isLegacyContextConsumer = false;\r\n            var unmaskedContext = emptyContextObject;\r\n            var context = emptyContextObject;\r\n            var contextType = ctor.contextType;\r\n            {\r\n                if ('contextType' in ctor) {\r\n                    var isValid = // Allow null for conditional declaration\r\n                     contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\r\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\r\n                        didWarnAboutInvalidateContextType.add(ctor);\r\n                        var addendum = '';\r\n                        if (contextType === undefined) {\r\n                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\r\n                        }\r\n                        else if (typeof contextType !== 'object') {\r\n                            addendum = ' However, it is set to a ' + typeof contextType + '.';\r\n                        }\r\n                        else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\r\n                            addendum = ' Did you accidentally pass the Context.Provider instead?';\r\n                        }\r\n                        else if (contextType._context !== undefined) {\r\n                            // <Context.Consumer>\r\n                            addendum = ' Did you accidentally pass the Context.Consumer instead?';\r\n                        }\r\n                        else {\r\n                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\r\n                        }\r\n                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);\r\n                    }\r\n                }\r\n            }\r\n            if (typeof contextType === 'object' && contextType !== null) {\r\n                context = readContext(contextType);\r\n            }\r\n            else {\r\n                unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n                var contextTypes = ctor.contextTypes;\r\n                isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\r\n                context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\r\n            } // Instantiate twice to help detect side-effects.\r\n            {\r\n                if (workInProgress.mode & StrictMode) {\r\n                    disableLogs();\r\n                    try {\r\n                        new ctor(props, context); // eslint-disable-line no-new\r\n                    }\r\n                    finally {\r\n                        reenableLogs();\r\n                    }\r\n                }\r\n            }\r\n            var instance = new ctor(props, context);\r\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\r\n            adoptClassInstance(workInProgress, instance);\r\n            {\r\n                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\r\n                    var componentName = getComponentName(ctor) || 'Component';\r\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\r\n                        didWarnAboutUninitializedState.add(componentName);\r\n                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\r\n                    }\r\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\r\n                // Warn about these lifecycles if they are present.\r\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\r\n                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n                    var foundWillMountName = null;\r\n                    var foundWillReceivePropsName = null;\r\n                    var foundWillUpdateName = null;\r\n                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\r\n                        foundWillMountName = 'componentWillMount';\r\n                    }\r\n                    else if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n                        foundWillMountName = 'UNSAFE_componentWillMount';\r\n                    }\r\n                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\r\n                        foundWillReceivePropsName = 'componentWillReceiveProps';\r\n                    }\r\n                    else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\r\n                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\r\n                    }\r\n                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\r\n                        foundWillUpdateName = 'componentWillUpdate';\r\n                    }\r\n                    else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\r\n                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\r\n                    }\r\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\r\n                        var _componentName = getComponentName(ctor) || 'Component';\r\n                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\r\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\r\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\r\n                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\r\n                        }\r\n                    }\r\n                }\r\n            } // Cache unmasked context so we can avoid recreating masked context unless necessary.\r\n            // ReactFiberContext usually updates this cache but can't for newly-created instances.\r\n            if (isLegacyContextConsumer) {\r\n                cacheContext(workInProgress, unmaskedContext, context);\r\n            }\r\n            return instance;\r\n        }\r\n        function callComponentWillMount(workInProgress, instance) {\r\n            var oldState = instance.state;\r\n            if (typeof instance.componentWillMount === 'function') {\r\n                instance.componentWillMount();\r\n            }\r\n            if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n                instance.UNSAFE_componentWillMount();\r\n            }\r\n            if (oldState !== instance.state) {\r\n                {\r\n                    error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');\r\n                }\r\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\r\n            }\r\n        }\r\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\r\n            var oldState = instance.state;\r\n            if (typeof instance.componentWillReceiveProps === 'function') {\r\n                instance.componentWillReceiveProps(newProps, nextContext);\r\n            }\r\n            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\r\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\r\n            }\r\n            if (instance.state !== oldState) {\r\n                {\r\n                    var componentName = getComponentName(workInProgress.type) || 'Component';\r\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\r\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\r\n                        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\r\n                    }\r\n                }\r\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\r\n            }\r\n        } // Invokes the mount life-cycles on a previously never rendered instance.\r\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\r\n            {\r\n                checkClassInstance(workInProgress, ctor, newProps);\r\n            }\r\n            var instance = workInProgress.stateNode;\r\n            instance.props = newProps;\r\n            instance.state = workInProgress.memoizedState;\r\n            instance.refs = emptyRefsObject;\r\n            initializeUpdateQueue(workInProgress);\r\n            var contextType = ctor.contextType;\r\n            if (typeof contextType === 'object' && contextType !== null) {\r\n                instance.context = readContext(contextType);\r\n            }\r\n            else {\r\n                var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n                instance.context = getMaskedContext(workInProgress, unmaskedContext);\r\n            }\r\n            {\r\n                if (instance.state === newProps) {\r\n                    var componentName = getComponentName(ctor) || 'Component';\r\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\r\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\r\n                        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\r\n                    }\r\n                }\r\n                if (workInProgress.mode & StrictMode) {\r\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\r\n                }\r\n                {\r\n                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\r\n                }\r\n            }\r\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n            instance.state = workInProgress.memoizedState;\r\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n            if (typeof getDerivedStateFromProps === 'function') {\r\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\r\n                instance.state = workInProgress.memoizedState;\r\n            } // In order to support react-lifecycles-compat polyfilled components,\r\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\r\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\r\n                // process them now.\r\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n                instance.state = workInProgress.memoizedState;\r\n            }\r\n            if (typeof instance.componentDidMount === 'function') {\r\n                workInProgress.flags |= Update;\r\n            }\r\n        }\r\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\r\n            var instance = workInProgress.stateNode;\r\n            var oldProps = workInProgress.memoizedProps;\r\n            instance.props = oldProps;\r\n            var oldContext = instance.context;\r\n            var contextType = ctor.contextType;\r\n            var nextContext = emptyContextObject;\r\n            if (typeof contextType === 'object' && contextType !== null) {\r\n                nextContext = readContext(contextType);\r\n            }\r\n            else {\r\n                var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n                nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\r\n            }\r\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\r\n            // ever the previously attempted to render - not the \"current\". However,\r\n            // during componentDidUpdate we pass the \"current\" props.\r\n            // In order to support react-lifecycles-compat polyfilled components,\r\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\r\n                if (oldProps !== newProps || oldContext !== nextContext) {\r\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\r\n                }\r\n            }\r\n            resetHasForceUpdateBeforeProcessing();\r\n            var oldState = workInProgress.memoizedState;\r\n            var newState = instance.state = oldState;\r\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n            newState = workInProgress.memoizedState;\r\n            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\r\n                // If an update was already in progress, we should schedule an Update\r\n                // effect even though we're bailing out, so that cWU/cDU are called.\r\n                if (typeof instance.componentDidMount === 'function') {\r\n                    workInProgress.flags |= Update;\r\n                }\r\n                return false;\r\n            }\r\n            if (typeof getDerivedStateFromProps === 'function') {\r\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\r\n                newState = workInProgress.memoizedState;\r\n            }\r\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\r\n            if (shouldUpdate) {\r\n                // In order to support react-lifecycles-compat polyfilled components,\r\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\r\n                    if (typeof instance.componentWillMount === 'function') {\r\n                        instance.componentWillMount();\r\n                    }\r\n                    if (typeof instance.UNSAFE_componentWillMount === 'function') {\r\n                        instance.UNSAFE_componentWillMount();\r\n                    }\r\n                }\r\n                if (typeof instance.componentDidMount === 'function') {\r\n                    workInProgress.flags |= Update;\r\n                }\r\n            }\r\n            else {\r\n                // If an update was already in progress, we should schedule an Update\r\n                // effect even though we're bailing out, so that cWU/cDU are called.\r\n                if (typeof instance.componentDidMount === 'function') {\r\n                    workInProgress.flags |= Update;\r\n                } // If shouldComponentUpdate returned false, we should still update the\r\n                // memoized state to indicate that this work can be reused.\r\n                workInProgress.memoizedProps = newProps;\r\n                workInProgress.memoizedState = newState;\r\n            } // Update the existing instance's state, props, and context pointers even\r\n            // if shouldComponentUpdate returns false.\r\n            instance.props = newProps;\r\n            instance.state = newState;\r\n            instance.context = nextContext;\r\n            return shouldUpdate;\r\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\r\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\r\n            var instance = workInProgress.stateNode;\r\n            cloneUpdateQueue(current, workInProgress);\r\n            var unresolvedOldProps = workInProgress.memoizedProps;\r\n            var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\r\n            instance.props = oldProps;\r\n            var unresolvedNewProps = workInProgress.pendingProps;\r\n            var oldContext = instance.context;\r\n            var contextType = ctor.contextType;\r\n            var nextContext = emptyContextObject;\r\n            if (typeof contextType === 'object' && contextType !== null) {\r\n                nextContext = readContext(contextType);\r\n            }\r\n            else {\r\n                var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\r\n                nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\r\n            }\r\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\r\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\r\n            // ever the previously attempted to render - not the \"current\". However,\r\n            // during componentDidUpdate we pass the \"current\" props.\r\n            // In order to support react-lifecycles-compat polyfilled components,\r\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\r\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\r\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\r\n                }\r\n            }\r\n            resetHasForceUpdateBeforeProcessing();\r\n            var oldState = workInProgress.memoizedState;\r\n            var newState = instance.state = oldState;\r\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\r\n            newState = workInProgress.memoizedState;\r\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\r\n                // If an update was already in progress, we should schedule an Update\r\n                // effect even though we're bailing out, so that cWU/cDU are called.\r\n                if (typeof instance.componentDidUpdate === 'function') {\r\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\r\n                        workInProgress.flags |= Update;\r\n                    }\r\n                }\r\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\r\n                        workInProgress.flags |= Snapshot;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n            if (typeof getDerivedStateFromProps === 'function') {\r\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\r\n                newState = workInProgress.memoizedState;\r\n            }\r\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\r\n            if (shouldUpdate) {\r\n                // In order to support react-lifecycles-compat polyfilled components,\r\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\r\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\r\n                    if (typeof instance.componentWillUpdate === 'function') {\r\n                        instance.componentWillUpdate(newProps, newState, nextContext);\r\n                    }\r\n                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\r\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\r\n                    }\r\n                }\r\n                if (typeof instance.componentDidUpdate === 'function') {\r\n                    workInProgress.flags |= Update;\r\n                }\r\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n                    workInProgress.flags |= Snapshot;\r\n                }\r\n            }\r\n            else {\r\n                // If an update was already in progress, we should schedule an Update\r\n                // effect even though we're bailing out, so that cWU/cDU are called.\r\n                if (typeof instance.componentDidUpdate === 'function') {\r\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\r\n                        workInProgress.flags |= Update;\r\n                    }\r\n                }\r\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\r\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\r\n                        workInProgress.flags |= Snapshot;\r\n                    }\r\n                } // If shouldComponentUpdate returned false, we should still update the\r\n                // memoized props/state to indicate that this work can be reused.\r\n                workInProgress.memoizedProps = newProps;\r\n                workInProgress.memoizedState = newState;\r\n            } // Update the existing instance's state, props, and context pointers even\r\n            // if shouldComponentUpdate returns false.\r\n            instance.props = newProps;\r\n            instance.state = newState;\r\n            instance.context = nextContext;\r\n            return shouldUpdate;\r\n        }\r\n        var didWarnAboutMaps;\r\n        var didWarnAboutGenerators;\r\n        var didWarnAboutStringRefs;\r\n        var ownerHasKeyUseWarning;\r\n        var ownerHasFunctionTypeWarning;\r\n        var warnForMissingKey = function (child, returnFiber) { };\r\n        {\r\n            didWarnAboutMaps = false;\r\n            didWarnAboutGenerators = false;\r\n            didWarnAboutStringRefs = {};\r\n            /**\r\n             * Warn if there's no key explicitly set on dynamic arrays of children or\r\n             * object keys are not valid. This allows us to keep track of children between\r\n             * updates.\r\n             */\r\n            ownerHasKeyUseWarning = {};\r\n            ownerHasFunctionTypeWarning = {};\r\n            warnForMissingKey = function (child, returnFiber) {\r\n                if (child === null || typeof child !== 'object') {\r\n                    return;\r\n                }\r\n                if (!child._store || child._store.validated || child.key != null) {\r\n                    return;\r\n                }\r\n                if (!(typeof child._store === 'object')) {\r\n                    {\r\n                        throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                child._store.validated = true;\r\n                var componentName = getComponentName(returnFiber.type) || 'Component';\r\n                if (ownerHasKeyUseWarning[componentName]) {\r\n                    return;\r\n                }\r\n                ownerHasKeyUseWarning[componentName] = true;\r\n                error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\r\n            };\r\n        }\r\n        var isArray$1 = Array.isArray;\r\n        function coerceRef(returnFiber, current, element) {\r\n            var mixedRef = element.ref;\r\n            if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\r\n                {\r\n                    // TODO: Clean this up once we turn on the string ref warning for\r\n                    // everyone, because the strict mode case will no longer be relevant\r\n                    if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\r\n                        // because these cannot be automatically converted to an arrow function\r\n                        // using a codemod. Therefore, we don't have to warn about string refs again.\r\n                        !(element._owner && element._self && element._owner.stateNode !== element._self)) {\r\n                        var componentName = getComponentName(returnFiber.type) || 'Component';\r\n                        if (!didWarnAboutStringRefs[componentName]) {\r\n                            {\r\n                                error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\r\n                            }\r\n                            didWarnAboutStringRefs[componentName] = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (element._owner) {\r\n                    var owner = element._owner;\r\n                    var inst;\r\n                    if (owner) {\r\n                        var ownerFiber = owner;\r\n                        if (!(ownerFiber.tag === ClassComponent)) {\r\n                            {\r\n                                throw Error(\"Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\");\r\n                            }\r\n                        }\r\n                        inst = ownerFiber.stateNode;\r\n                    }\r\n                    if (!inst) {\r\n                        {\r\n                            throw Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\r\n                    if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\r\n                        return current.ref;\r\n                    }\r\n                    var ref = function (value) {\r\n                        var refs = inst.refs;\r\n                        if (refs === emptyRefsObject) {\r\n                            // This is a lazy pooled frozen object, so we need to initialize.\r\n                            refs = inst.refs = {};\r\n                        }\r\n                        if (value === null) {\r\n                            delete refs[stringRef];\r\n                        }\r\n                        else {\r\n                            refs[stringRef] = value;\r\n                        }\r\n                    };\r\n                    ref._stringRef = stringRef;\r\n                    return ref;\r\n                }\r\n                else {\r\n                    if (!(typeof mixedRef === 'string')) {\r\n                        {\r\n                            throw Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\r\n                        }\r\n                    }\r\n                    if (!element._owner) {\r\n                        {\r\n                            throw Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a function component\\n2. You may be adding a ref to a component that was not created inside a component's render method\\n3. You have multiple copies of React loaded\\nSee https://reactjs.org/link/refs-must-have-owner for more information.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return mixedRef;\r\n        }\r\n        function throwOnInvalidObjectType(returnFiber, newChild) {\r\n            if (returnFiber.type !== 'textarea') {\r\n                {\r\n                    {\r\n                        throw Error(\"Objects are not valid as a React child (found: \" + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + \"). If you meant to render a collection of children, use an array instead.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function warnOnFunctionType(returnFiber) {\r\n            {\r\n                var componentName = getComponentName(returnFiber.type) || 'Component';\r\n                if (ownerHasFunctionTypeWarning[componentName]) {\r\n                    return;\r\n                }\r\n                ownerHasFunctionTypeWarning[componentName] = true;\r\n                error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\r\n            }\r\n        } // We avoid inlining this to avoid potential deopts from using try/catch.\r\n        // to be able to optimize each path individually by branching early. This needs\r\n        // a compiler or we can do it manually. Helpers that don't need this branching\r\n        // live outside of this function.\r\n        function ChildReconciler(shouldTrackSideEffects) {\r\n            function deleteChild(returnFiber, childToDelete) {\r\n                if (!shouldTrackSideEffects) {\r\n                    // Noop.\r\n                    return;\r\n                } // Deletions are added in reversed order so we add it to the front.\r\n                // At this point, the return fiber's effect list is empty except for\r\n                // deletions, so we can just append the deletion to the list. The remaining\r\n                // effects aren't added until the complete phase. Once we implement\r\n                // resuming, this may not be true.\r\n                var last = returnFiber.lastEffect;\r\n                if (last !== null) {\r\n                    last.nextEffect = childToDelete;\r\n                    returnFiber.lastEffect = childToDelete;\r\n                }\r\n                else {\r\n                    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\r\n                }\r\n                childToDelete.nextEffect = null;\r\n                childToDelete.flags = Deletion;\r\n            }\r\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\r\n                if (!shouldTrackSideEffects) {\r\n                    // Noop.\r\n                    return null;\r\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\r\n                // assuming that after the first child we've already added everything.\r\n                var childToDelete = currentFirstChild;\r\n                while (childToDelete !== null) {\r\n                    deleteChild(returnFiber, childToDelete);\r\n                    childToDelete = childToDelete.sibling;\r\n                }\r\n                return null;\r\n            }\r\n            function mapRemainingChildren(returnFiber, currentFirstChild) {\r\n                // Add the remaining children to a temporary map so that we can find them by\r\n                // keys quickly. Implicit (null) keys get added to this set with their index\r\n                // instead.\r\n                var existingChildren = new Map();\r\n                var existingChild = currentFirstChild;\r\n                while (existingChild !== null) {\r\n                    if (existingChild.key !== null) {\r\n                        existingChildren.set(existingChild.key, existingChild);\r\n                    }\r\n                    else {\r\n                        existingChildren.set(existingChild.index, existingChild);\r\n                    }\r\n                    existingChild = existingChild.sibling;\r\n                }\r\n                return existingChildren;\r\n            }\r\n            function useFiber(fiber, pendingProps) {\r\n                // We currently set sibling to null and index to 0 here because it is easy\r\n                // to forget to do before returning it. E.g. for the single child case.\r\n                var clone = createWorkInProgress(fiber, pendingProps);\r\n                clone.index = 0;\r\n                clone.sibling = null;\r\n                return clone;\r\n            }\r\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\r\n                newFiber.index = newIndex;\r\n                if (!shouldTrackSideEffects) {\r\n                    // Noop.\r\n                    return lastPlacedIndex;\r\n                }\r\n                var current = newFiber.alternate;\r\n                if (current !== null) {\r\n                    var oldIndex = current.index;\r\n                    if (oldIndex < lastPlacedIndex) {\r\n                        // This is a move.\r\n                        newFiber.flags = Placement;\r\n                        return lastPlacedIndex;\r\n                    }\r\n                    else {\r\n                        // This item can stay in place.\r\n                        return oldIndex;\r\n                    }\r\n                }\r\n                else {\r\n                    // This is an insertion.\r\n                    newFiber.flags = Placement;\r\n                    return lastPlacedIndex;\r\n                }\r\n            }\r\n            function placeSingleChild(newFiber) {\r\n                // This is simpler for the single child case. We only need to do a\r\n                // placement for inserting new children.\r\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\r\n                    newFiber.flags = Placement;\r\n                }\r\n                return newFiber;\r\n            }\r\n            function updateTextNode(returnFiber, current, textContent, lanes) {\r\n                if (current === null || current.tag !== HostText) {\r\n                    // Insert\r\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\r\n                    created.return = returnFiber;\r\n                    return created;\r\n                }\r\n                else {\r\n                    // Update\r\n                    var existing = useFiber(current, textContent);\r\n                    existing.return = returnFiber;\r\n                    return existing;\r\n                }\r\n            }\r\n            function updateElement(returnFiber, current, element, lanes) {\r\n                if (current !== null) {\r\n                    if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\r\n                    isCompatibleFamilyForHotReloading(current, element))) {\r\n                        // Move based on index\r\n                        var existing = useFiber(current, element.props);\r\n                        existing.ref = coerceRef(returnFiber, current, element);\r\n                        existing.return = returnFiber;\r\n                        {\r\n                            existing._debugSource = element._source;\r\n                            existing._debugOwner = element._owner;\r\n                        }\r\n                        return existing;\r\n                    }\r\n                } // Insert\r\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\r\n                created.ref = coerceRef(returnFiber, current, element);\r\n                created.return = returnFiber;\r\n                return created;\r\n            }\r\n            function updatePortal(returnFiber, current, portal, lanes) {\r\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\r\n                    // Insert\r\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\r\n                    created.return = returnFiber;\r\n                    return created;\r\n                }\r\n                else {\r\n                    // Update\r\n                    var existing = useFiber(current, portal.children || []);\r\n                    existing.return = returnFiber;\r\n                    return existing;\r\n                }\r\n            }\r\n            function updateFragment(returnFiber, current, fragment, lanes, key) {\r\n                if (current === null || current.tag !== Fragment) {\r\n                    // Insert\r\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\r\n                    created.return = returnFiber;\r\n                    return created;\r\n                }\r\n                else {\r\n                    // Update\r\n                    var existing = useFiber(current, fragment);\r\n                    existing.return = returnFiber;\r\n                    return existing;\r\n                }\r\n            }\r\n            function createChild(returnFiber, newChild, lanes) {\r\n                if (typeof newChild === 'string' || typeof newChild === 'number') {\r\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\r\n                    // we can continue to replace it without aborting even if it is not a text\r\n                    // node.\r\n                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\r\n                    created.return = returnFiber;\r\n                    return created;\r\n                }\r\n                if (typeof newChild === 'object' && newChild !== null) {\r\n                    switch (newChild.$$typeof) {\r\n                        case REACT_ELEMENT_TYPE:\r\n                            {\r\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\r\n                                _created.ref = coerceRef(returnFiber, null, newChild);\r\n                                _created.return = returnFiber;\r\n                                return _created;\r\n                            }\r\n                        case REACT_PORTAL_TYPE:\r\n                            {\r\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\r\n                                _created2.return = returnFiber;\r\n                                return _created2;\r\n                            }\r\n                    }\r\n                    if (isArray$1(newChild) || getIteratorFn(newChild)) {\r\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\r\n                        _created3.return = returnFiber;\r\n                        return _created3;\r\n                    }\r\n                    throwOnInvalidObjectType(returnFiber, newChild);\r\n                }\r\n                {\r\n                    if (typeof newChild === 'function') {\r\n                        warnOnFunctionType(returnFiber);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            function updateSlot(returnFiber, oldFiber, newChild, lanes) {\r\n                // Update the fiber if the keys match, otherwise return null.\r\n                var key = oldFiber !== null ? oldFiber.key : null;\r\n                if (typeof newChild === 'string' || typeof newChild === 'number') {\r\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\r\n                    // we can continue to replace it without aborting even if it is not a text\r\n                    // node.\r\n                    if (key !== null) {\r\n                        return null;\r\n                    }\r\n                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\r\n                }\r\n                if (typeof newChild === 'object' && newChild !== null) {\r\n                    switch (newChild.$$typeof) {\r\n                        case REACT_ELEMENT_TYPE:\r\n                            {\r\n                                if (newChild.key === key) {\r\n                                    if (newChild.type === REACT_FRAGMENT_TYPE) {\r\n                                        return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);\r\n                                    }\r\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes);\r\n                                }\r\n                                else {\r\n                                    return null;\r\n                                }\r\n                            }\r\n                        case REACT_PORTAL_TYPE:\r\n                            {\r\n                                if (newChild.key === key) {\r\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\r\n                                }\r\n                                else {\r\n                                    return null;\r\n                                }\r\n                            }\r\n                    }\r\n                    if (isArray$1(newChild) || getIteratorFn(newChild)) {\r\n                        if (key !== null) {\r\n                            return null;\r\n                        }\r\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\r\n                    }\r\n                    throwOnInvalidObjectType(returnFiber, newChild);\r\n                }\r\n                {\r\n                    if (typeof newChild === 'function') {\r\n                        warnOnFunctionType(returnFiber);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\r\n                if (typeof newChild === 'string' || typeof newChild === 'number') {\r\n                    // Text nodes don't have keys, so we neither have to check the old nor\r\n                    // new node for the key. If both are text nodes, they match.\r\n                    var matchedFiber = existingChildren.get(newIdx) || null;\r\n                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\r\n                }\r\n                if (typeof newChild === 'object' && newChild !== null) {\r\n                    switch (newChild.$$typeof) {\r\n                        case REACT_ELEMENT_TYPE:\r\n                            {\r\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\r\n                                if (newChild.type === REACT_FRAGMENT_TYPE) {\r\n                                    return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);\r\n                                }\r\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes);\r\n                            }\r\n                        case REACT_PORTAL_TYPE:\r\n                            {\r\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\r\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\r\n                            }\r\n                    }\r\n                    if (isArray$1(newChild) || getIteratorFn(newChild)) {\r\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\r\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\r\n                    }\r\n                    throwOnInvalidObjectType(returnFiber, newChild);\r\n                }\r\n                {\r\n                    if (typeof newChild === 'function') {\r\n                        warnOnFunctionType(returnFiber);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            /**\r\n             * Warns if there is a duplicate or missing key\r\n             */\r\n            function warnOnInvalidKey(child, knownKeys, returnFiber) {\r\n                {\r\n                    if (typeof child !== 'object' || child === null) {\r\n                        return knownKeys;\r\n                    }\r\n                    switch (child.$$typeof) {\r\n                        case REACT_ELEMENT_TYPE:\r\n                        case REACT_PORTAL_TYPE:\r\n                            warnForMissingKey(child, returnFiber);\r\n                            var key = child.key;\r\n                            if (typeof key !== 'string') {\r\n                                break;\r\n                            }\r\n                            if (knownKeys === null) {\r\n                                knownKeys = new Set();\r\n                                knownKeys.add(key);\r\n                                break;\r\n                            }\r\n                            if (!knownKeys.has(key)) {\r\n                                knownKeys.add(key);\r\n                                break;\r\n                            }\r\n                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\r\n                            break;\r\n                    }\r\n                }\r\n                return knownKeys;\r\n            }\r\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\r\n                // This algorithm can't optimize by searching from both ends since we\r\n                // don't have backpointers on fibers. I'm trying to see how far we can get\r\n                // with that model. If it ends up not being worth the tradeoffs, we can\r\n                // add it later.\r\n                // Even with a two ended optimization, we'd want to optimize for the case\r\n                // where there are few changes and brute force the comparison instead of\r\n                // going for the Map. It'd like to explore hitting that path first in\r\n                // forward-only mode and only go for the Map once we notice that we need\r\n                // lots of look ahead. This doesn't handle reversal as well as two ended\r\n                // search but that's unusual. Besides, for the two ended optimization to\r\n                // work on Iterables, we'd need to copy the whole set.\r\n                // In this first iteration, we'll just live with hitting the bad case\r\n                // (adding everything to a Map) in for every insert/move.\r\n                // If you change this code, also update reconcileChildrenIterator() which\r\n                // uses the same algorithm.\r\n                {\r\n                    // First, validate keys.\r\n                    var knownKeys = null;\r\n                    for (var i = 0; i < newChildren.length; i++) {\r\n                        var child = newChildren[i];\r\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\r\n                    }\r\n                }\r\n                var resultingFirstChild = null;\r\n                var previousNewFiber = null;\r\n                var oldFiber = currentFirstChild;\r\n                var lastPlacedIndex = 0;\r\n                var newIdx = 0;\r\n                var nextOldFiber = null;\r\n                for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\r\n                    if (oldFiber.index > newIdx) {\r\n                        nextOldFiber = oldFiber;\r\n                        oldFiber = null;\r\n                    }\r\n                    else {\r\n                        nextOldFiber = oldFiber.sibling;\r\n                    }\r\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\r\n                    if (newFiber === null) {\r\n                        // TODO: This breaks on empty slots like null children. That's\r\n                        // unfortunate because it triggers the slow path all the time. We need\r\n                        // a better way to communicate whether this was a miss or null,\r\n                        // boolean, undefined, etc.\r\n                        if (oldFiber === null) {\r\n                            oldFiber = nextOldFiber;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (shouldTrackSideEffects) {\r\n                        if (oldFiber && newFiber.alternate === null) {\r\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\r\n                            // need to delete the existing child.\r\n                            deleteChild(returnFiber, oldFiber);\r\n                        }\r\n                    }\r\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n                    if (previousNewFiber === null) {\r\n                        // TODO: Move out of the loop. This only happens for the first run.\r\n                        resultingFirstChild = newFiber;\r\n                    }\r\n                    else {\r\n                        // TODO: Defer siblings if we're not at the right index for this slot.\r\n                        // I.e. if we had null values before, then we want to defer this\r\n                        // for each null value. However, we also don't want to call updateSlot\r\n                        // with the previous one.\r\n                        previousNewFiber.sibling = newFiber;\r\n                    }\r\n                    previousNewFiber = newFiber;\r\n                    oldFiber = nextOldFiber;\r\n                }\r\n                if (newIdx === newChildren.length) {\r\n                    // We've reached the end of the new children. We can delete the rest.\r\n                    deleteRemainingChildren(returnFiber, oldFiber);\r\n                    return resultingFirstChild;\r\n                }\r\n                if (oldFiber === null) {\r\n                    // If we don't have any more existing children we can choose a fast path\r\n                    // since the rest will all be insertions.\r\n                    for (; newIdx < newChildren.length; newIdx++) {\r\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\r\n                        if (_newFiber === null) {\r\n                            continue;\r\n                        }\r\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\r\n                        if (previousNewFiber === null) {\r\n                            // TODO: Move out of the loop. This only happens for the first run.\r\n                            resultingFirstChild = _newFiber;\r\n                        }\r\n                        else {\r\n                            previousNewFiber.sibling = _newFiber;\r\n                        }\r\n                        previousNewFiber = _newFiber;\r\n                    }\r\n                    return resultingFirstChild;\r\n                } // Add all children to a key map for quick lookups.\r\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\r\n                for (; newIdx < newChildren.length; newIdx++) {\r\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\r\n                    if (_newFiber2 !== null) {\r\n                        if (shouldTrackSideEffects) {\r\n                            if (_newFiber2.alternate !== null) {\r\n                                // The new fiber is a work in progress, but if there exists a\r\n                                // current, that means that we reused the fiber. We need to delete\r\n                                // it from the child list so that we don't add it to the deletion\r\n                                // list.\r\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\r\n                            }\r\n                        }\r\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\r\n                        if (previousNewFiber === null) {\r\n                            resultingFirstChild = _newFiber2;\r\n                        }\r\n                        else {\r\n                            previousNewFiber.sibling = _newFiber2;\r\n                        }\r\n                        previousNewFiber = _newFiber2;\r\n                    }\r\n                }\r\n                if (shouldTrackSideEffects) {\r\n                    // Any existing children that weren't consumed above were deleted. We need\r\n                    // to add them to the deletion list.\r\n                    existingChildren.forEach(function (child) {\r\n                        return deleteChild(returnFiber, child);\r\n                    });\r\n                }\r\n                return resultingFirstChild;\r\n            }\r\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\r\n                // This is the same implementation as reconcileChildrenArray(),\r\n                // but using the iterator instead.\r\n                var iteratorFn = getIteratorFn(newChildrenIterable);\r\n                if (!(typeof iteratorFn === 'function')) {\r\n                    {\r\n                        throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                {\r\n                    // We don't support rendering Generators because it's a mutation.\r\n                    // See https://github.com/facebook/react/issues/12995\r\n                    if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\r\n                        newChildrenIterable[Symbol.toStringTag] === 'Generator') {\r\n                        if (!didWarnAboutGenerators) {\r\n                            error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\r\n                        }\r\n                        didWarnAboutGenerators = true;\r\n                    } // Warn about using Maps as children\r\n                    if (newChildrenIterable.entries === iteratorFn) {\r\n                        if (!didWarnAboutMaps) {\r\n                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\r\n                        }\r\n                        didWarnAboutMaps = true;\r\n                    } // First, validate keys.\r\n                    // We'll get a different iterator later for the main pass.\r\n                    var _newChildren = iteratorFn.call(newChildrenIterable);\r\n                    if (_newChildren) {\r\n                        var knownKeys = null;\r\n                        var _step = _newChildren.next();\r\n                        for (; !_step.done; _step = _newChildren.next()) {\r\n                            var child = _step.value;\r\n                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\r\n                        }\r\n                    }\r\n                }\r\n                var newChildren = iteratorFn.call(newChildrenIterable);\r\n                if (!(newChildren != null)) {\r\n                    {\r\n                        throw Error(\"An iterable object provided no iterator.\");\r\n                    }\r\n                }\r\n                var resultingFirstChild = null;\r\n                var previousNewFiber = null;\r\n                var oldFiber = currentFirstChild;\r\n                var lastPlacedIndex = 0;\r\n                var newIdx = 0;\r\n                var nextOldFiber = null;\r\n                var step = newChildren.next();\r\n                for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\r\n                    if (oldFiber.index > newIdx) {\r\n                        nextOldFiber = oldFiber;\r\n                        oldFiber = null;\r\n                    }\r\n                    else {\r\n                        nextOldFiber = oldFiber.sibling;\r\n                    }\r\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\r\n                    if (newFiber === null) {\r\n                        // TODO: This breaks on empty slots like null children. That's\r\n                        // unfortunate because it triggers the slow path all the time. We need\r\n                        // a better way to communicate whether this was a miss or null,\r\n                        // boolean, undefined, etc.\r\n                        if (oldFiber === null) {\r\n                            oldFiber = nextOldFiber;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (shouldTrackSideEffects) {\r\n                        if (oldFiber && newFiber.alternate === null) {\r\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\r\n                            // need to delete the existing child.\r\n                            deleteChild(returnFiber, oldFiber);\r\n                        }\r\n                    }\r\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\r\n                    if (previousNewFiber === null) {\r\n                        // TODO: Move out of the loop. This only happens for the first run.\r\n                        resultingFirstChild = newFiber;\r\n                    }\r\n                    else {\r\n                        // TODO: Defer siblings if we're not at the right index for this slot.\r\n                        // I.e. if we had null values before, then we want to defer this\r\n                        // for each null value. However, we also don't want to call updateSlot\r\n                        // with the previous one.\r\n                        previousNewFiber.sibling = newFiber;\r\n                    }\r\n                    previousNewFiber = newFiber;\r\n                    oldFiber = nextOldFiber;\r\n                }\r\n                if (step.done) {\r\n                    // We've reached the end of the new children. We can delete the rest.\r\n                    deleteRemainingChildren(returnFiber, oldFiber);\r\n                    return resultingFirstChild;\r\n                }\r\n                if (oldFiber === null) {\r\n                    // If we don't have any more existing children we can choose a fast path\r\n                    // since the rest will all be insertions.\r\n                    for (; !step.done; newIdx++, step = newChildren.next()) {\r\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes);\r\n                        if (_newFiber3 === null) {\r\n                            continue;\r\n                        }\r\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\r\n                        if (previousNewFiber === null) {\r\n                            // TODO: Move out of the loop. This only happens for the first run.\r\n                            resultingFirstChild = _newFiber3;\r\n                        }\r\n                        else {\r\n                            previousNewFiber.sibling = _newFiber3;\r\n                        }\r\n                        previousNewFiber = _newFiber3;\r\n                    }\r\n                    return resultingFirstChild;\r\n                } // Add all children to a key map for quick lookups.\r\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\r\n                for (; !step.done; newIdx++, step = newChildren.next()) {\r\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\r\n                    if (_newFiber4 !== null) {\r\n                        if (shouldTrackSideEffects) {\r\n                            if (_newFiber4.alternate !== null) {\r\n                                // The new fiber is a work in progress, but if there exists a\r\n                                // current, that means that we reused the fiber. We need to delete\r\n                                // it from the child list so that we don't add it to the deletion\r\n                                // list.\r\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\r\n                            }\r\n                        }\r\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\r\n                        if (previousNewFiber === null) {\r\n                            resultingFirstChild = _newFiber4;\r\n                        }\r\n                        else {\r\n                            previousNewFiber.sibling = _newFiber4;\r\n                        }\r\n                        previousNewFiber = _newFiber4;\r\n                    }\r\n                }\r\n                if (shouldTrackSideEffects) {\r\n                    // Any existing children that weren't consumed above were deleted. We need\r\n                    // to add them to the deletion list.\r\n                    existingChildren.forEach(function (child) {\r\n                        return deleteChild(returnFiber, child);\r\n                    });\r\n                }\r\n                return resultingFirstChild;\r\n            }\r\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\r\n                // There's no need to check for keys on text nodes since we don't have a\r\n                // way to define them.\r\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\r\n                    // We already have an existing node so let's just update it and delete\r\n                    // the rest.\r\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\r\n                    var existing = useFiber(currentFirstChild, textContent);\r\n                    existing.return = returnFiber;\r\n                    return existing;\r\n                } // The existing first child is not a text node so we need to create one\r\n                // and delete the existing ones.\r\n                deleteRemainingChildren(returnFiber, currentFirstChild);\r\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\r\n                created.return = returnFiber;\r\n                return created;\r\n            }\r\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\r\n                var key = element.key;\r\n                var child = currentFirstChild;\r\n                while (child !== null) {\r\n                    // TODO: If key === null and child.key === null, then this only applies to\r\n                    // the first item in the list.\r\n                    if (child.key === key) {\r\n                        switch (child.tag) {\r\n                            case Fragment:\r\n                                {\r\n                                    if (element.type === REACT_FRAGMENT_TYPE) {\r\n                                        deleteRemainingChildren(returnFiber, child.sibling);\r\n                                        var existing = useFiber(child, element.props.children);\r\n                                        existing.return = returnFiber;\r\n                                        {\r\n                                            existing._debugSource = element._source;\r\n                                            existing._debugOwner = element._owner;\r\n                                        }\r\n                                        return existing;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            case Block:\r\n                            // We intentionally fallthrough here if enableBlocksAPI is not on.\r\n                            // eslint-disable-next-lined no-fallthrough\r\n                            default:\r\n                                {\r\n                                    if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\r\n                                    isCompatibleFamilyForHotReloading(child, element))) {\r\n                                        deleteRemainingChildren(returnFiber, child.sibling);\r\n                                        var _existing3 = useFiber(child, element.props);\r\n                                        _existing3.ref = coerceRef(returnFiber, child, element);\r\n                                        _existing3.return = returnFiber;\r\n                                        {\r\n                                            _existing3._debugSource = element._source;\r\n                                            _existing3._debugOwner = element._owner;\r\n                                        }\r\n                                        return _existing3;\r\n                                    }\r\n                                    break;\r\n                                }\r\n                        } // Didn't match.\r\n                        deleteRemainingChildren(returnFiber, child);\r\n                        break;\r\n                    }\r\n                    else {\r\n                        deleteChild(returnFiber, child);\r\n                    }\r\n                    child = child.sibling;\r\n                }\r\n                if (element.type === REACT_FRAGMENT_TYPE) {\r\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\r\n                    created.return = returnFiber;\r\n                    return created;\r\n                }\r\n                else {\r\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\r\n                    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\r\n                    _created4.return = returnFiber;\r\n                    return _created4;\r\n                }\r\n            }\r\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\r\n                var key = portal.key;\r\n                var child = currentFirstChild;\r\n                while (child !== null) {\r\n                    // TODO: If key === null and child.key === null, then this only applies to\r\n                    // the first item in the list.\r\n                    if (child.key === key) {\r\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\r\n                            deleteRemainingChildren(returnFiber, child.sibling);\r\n                            var existing = useFiber(child, portal.children || []);\r\n                            existing.return = returnFiber;\r\n                            return existing;\r\n                        }\r\n                        else {\r\n                            deleteRemainingChildren(returnFiber, child);\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        deleteChild(returnFiber, child);\r\n                    }\r\n                    child = child.sibling;\r\n                }\r\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\r\n                created.return = returnFiber;\r\n                return created;\r\n            } // This API will tag the children with the side-effect of the reconciliation\r\n            // itself. They will be added to the side-effect list as we pass through the\r\n            // children and the parent.\r\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\r\n                // This function is not recursive.\r\n                // If the top level item is an array, we treat it as a set of children,\r\n                // not as a fragment. Nested arrays on the other hand will be treated as\r\n                // fragment nodes. Recursion happens at the normal flow.\r\n                // Handle top level unkeyed fragments as if they were arrays.\r\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\r\n                // We treat the ambiguous cases above the same.\r\n                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\r\n                if (isUnkeyedTopLevelFragment) {\r\n                    newChild = newChild.props.children;\r\n                } // Handle object types\r\n                var isObject = typeof newChild === 'object' && newChild !== null;\r\n                if (isObject) {\r\n                    switch (newChild.$$typeof) {\r\n                        case REACT_ELEMENT_TYPE:\r\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\r\n                        case REACT_PORTAL_TYPE:\r\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\r\n                    }\r\n                }\r\n                if (typeof newChild === 'string' || typeof newChild === 'number') {\r\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\r\n                }\r\n                if (isArray$1(newChild)) {\r\n                    return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\r\n                }\r\n                if (getIteratorFn(newChild)) {\r\n                    return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\r\n                }\r\n                if (isObject) {\r\n                    throwOnInvalidObjectType(returnFiber, newChild);\r\n                }\r\n                {\r\n                    if (typeof newChild === 'function') {\r\n                        warnOnFunctionType(returnFiber);\r\n                    }\r\n                }\r\n                if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\r\n                    // If the new child is undefined, and the return fiber is a composite\r\n                    // component, throw an error. If Fiber return types are disabled,\r\n                    // we already threw above.\r\n                    switch (returnFiber.tag) {\r\n                        case ClassComponent:\r\n                            {\r\n                                {\r\n                                    var instance = returnFiber.stateNode;\r\n                                    if (instance.render._isMockFunction) {\r\n                                        // We allow auto-mocks to proceed as if they're returning null.\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        // Intentionally fall through to the next case, which handles both\r\n                        // functions and classes\r\n                        // eslint-disable-next-lined no-fallthrough\r\n                        case Block:\r\n                        case FunctionComponent:\r\n                        case ForwardRef:\r\n                        case SimpleMemoComponent:\r\n                            {\r\n                                {\r\n                                    {\r\n                                        throw Error((getComponentName(returnFiber.type) || 'Component') + \"(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\");\r\n                                    }\r\n                                }\r\n                            }\r\n                    }\r\n                } // Remaining cases are all treated as empty.\r\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\r\n            }\r\n            return reconcileChildFibers;\r\n        }\r\n        var reconcileChildFibers = ChildReconciler(true);\r\n        var mountChildFibers = ChildReconciler(false);\r\n        function cloneChildFibers(current, workInProgress) {\r\n            if (!(current === null || workInProgress.child === current.child)) {\r\n                {\r\n                    throw Error(\"Resuming work not yet implemented.\");\r\n                }\r\n            }\r\n            if (workInProgress.child === null) {\r\n                return;\r\n            }\r\n            var currentChild = workInProgress.child;\r\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\r\n            workInProgress.child = newChild;\r\n            newChild.return = workInProgress;\r\n            while (currentChild.sibling !== null) {\r\n                currentChild = currentChild.sibling;\r\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\r\n                newChild.return = workInProgress;\r\n            }\r\n            newChild.sibling = null;\r\n        } // Reset a workInProgress child set to prepare it for a second pass.\r\n        function resetChildFibers(workInProgress, lanes) {\r\n            var child = workInProgress.child;\r\n            while (child !== null) {\r\n                resetWorkInProgress(child, lanes);\r\n                child = child.sibling;\r\n            }\r\n        }\r\n        var NO_CONTEXT = {};\r\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\r\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\r\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\r\n        function requiredContext(c) {\r\n            if (!(c !== NO_CONTEXT)) {\r\n                {\r\n                    throw Error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            return c;\r\n        }\r\n        function getRootHostContainer() {\r\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\r\n            return rootInstance;\r\n        }\r\n        function pushHostContainer(fiber, nextRootInstance) {\r\n            // Push current root instance onto the stack;\r\n            // This allows us to reset root when portals are popped.\r\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\r\n            // This enables us to pop only Fibers that provide unique contexts.\r\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\r\n            // However, we can't just call getRootHostContext() and push it because\r\n            // we'd have a different number of entries on the stack depending on\r\n            // whether getRootHostContext() throws somewhere in renderer code or not.\r\n            // So we push an empty value first. This lets us safely unwind on errors.\r\n            push(contextStackCursor$1, NO_CONTEXT, fiber);\r\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\r\n            pop(contextStackCursor$1, fiber);\r\n            push(contextStackCursor$1, nextRootContext, fiber);\r\n        }\r\n        function popHostContainer(fiber) {\r\n            pop(contextStackCursor$1, fiber);\r\n            pop(contextFiberStackCursor, fiber);\r\n            pop(rootInstanceStackCursor, fiber);\r\n        }\r\n        function getHostContext() {\r\n            var context = requiredContext(contextStackCursor$1.current);\r\n            return context;\r\n        }\r\n        function pushHostContext(fiber) {\r\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\r\n            var context = requiredContext(contextStackCursor$1.current);\r\n            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\r\n            if (context === nextContext) {\r\n                return;\r\n            } // Track the context and the Fiber that provided it.\r\n            // This enables us to pop only Fibers that provide unique contexts.\r\n            push(contextFiberStackCursor, fiber, fiber);\r\n            push(contextStackCursor$1, nextContext, fiber);\r\n        }\r\n        function popHostContext(fiber) {\r\n            // Do not pop unless this Fiber provided the current context.\r\n            // pushHostContext() only pushes Fibers that provide unique contexts.\r\n            if (contextFiberStackCursor.current !== fiber) {\r\n                return;\r\n            }\r\n            pop(contextStackCursor$1, fiber);\r\n            pop(contextFiberStackCursor, fiber);\r\n        }\r\n        var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\r\n        // inherited deeply down the subtree. The upper bits only affect\r\n        // this immediate suspense boundary and gets reset each new\r\n        // boundary or suspense list.\r\n        var SubtreeSuspenseContextMask = 1; // Subtree Flags:\r\n        // InvisibleParentSuspenseContext indicates that one of our parent Suspense\r\n        // boundaries is not currently showing visible main content.\r\n        // Either because it is already showing a fallback or is not mounted at all.\r\n        // We can use this to determine if it is desirable to trigger a fallback at\r\n        // the parent. If not, then we might need to trigger undesirable boundaries\r\n        // and/or suspend the commit to avoid hiding the parent content.\r\n        var InvisibleParentSuspenseContext = 1; // Shallow Flags:\r\n        // ForceSuspenseFallback can be used by SuspenseList to force newly added\r\n        // items into their fallback state during one of the render passes.\r\n        var ForceSuspenseFallback = 2;\r\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\r\n        function hasSuspenseContext(parentContext, flag) {\r\n            return (parentContext & flag) !== 0;\r\n        }\r\n        function setDefaultShallowSuspenseContext(parentContext) {\r\n            return parentContext & SubtreeSuspenseContextMask;\r\n        }\r\n        function setShallowSuspenseContext(parentContext, shallowContext) {\r\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\r\n        }\r\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\r\n            return parentContext | subtreeContext;\r\n        }\r\n        function pushSuspenseContext(fiber, newContext) {\r\n            push(suspenseStackCursor, newContext, fiber);\r\n        }\r\n        function popSuspenseContext(fiber) {\r\n            pop(suspenseStackCursor, fiber);\r\n        }\r\n        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\r\n            // If it was the primary children that just suspended, capture and render the\r\n            // fallback. Otherwise, don't capture and bubble to the next boundary.\r\n            var nextState = workInProgress.memoizedState;\r\n            if (nextState !== null) {\r\n                if (nextState.dehydrated !== null) {\r\n                    // A dehydrated boundary always captures.\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.\r\n            if (props.fallback === undefined) {\r\n                return false;\r\n            } // Regular boundaries always capture.\r\n            if (props.unstable_avoidThisFallback !== true) {\r\n                return true;\r\n            } // If it's a boundary we should avoid, then we prefer to bubble up to the\r\n            // parent boundary if it is currently invisible.\r\n            if (hasInvisibleParent) {\r\n                return false;\r\n            } // If the parent is not able to handle it, we must handle it.\r\n            return true;\r\n        }\r\n        function findFirstSuspended(row) {\r\n            var node = row;\r\n            while (node !== null) {\r\n                if (node.tag === SuspenseComponent) {\r\n                    var state = node.memoizedState;\r\n                    if (state !== null) {\r\n                        var dehydrated = state.dehydrated;\r\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\r\n                            return node;\r\n                        }\r\n                    }\r\n                }\r\n                else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\r\n                    // keep track of whether it suspended or not.\r\n                    node.memoizedProps.revealOrder !== undefined) {\r\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags;\r\n                    if (didSuspend) {\r\n                        return node;\r\n                    }\r\n                }\r\n                else if (node.child !== null) {\r\n                    node.child.return = node;\r\n                    node = node.child;\r\n                    continue;\r\n                }\r\n                if (node === row) {\r\n                    return null;\r\n                }\r\n                while (node.sibling === null) {\r\n                    if (node.return === null || node.return === row) {\r\n                        return null;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            }\r\n            return null;\r\n        }\r\n        var NoFlags$1 = \r\n        /*  */\r\n        0; // Represents whether effect should fire.\r\n        var HasEffect = \r\n        /* */\r\n        1; // Represents the phase in which the effect (not the clean-up) fires.\r\n        var Layout = \r\n        /*    */\r\n        2;\r\n        var Passive$1 = \r\n        /*   */\r\n        4;\r\n        // This may have been an insertion or a hydration.\r\n        var hydrationParentFiber = null;\r\n        var nextHydratableInstance = null;\r\n        var isHydrating = false;\r\n        function enterHydrationState(fiber) {\r\n            var parentInstance = fiber.stateNode.containerInfo;\r\n            nextHydratableInstance = getFirstHydratableChild(parentInstance);\r\n            hydrationParentFiber = fiber;\r\n            isHydrating = true;\r\n            return true;\r\n        }\r\n        function deleteHydratableInstance(returnFiber, instance) {\r\n            {\r\n                switch (returnFiber.tag) {\r\n                    case HostRoot:\r\n                        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\r\n                        break;\r\n                    case HostComponent:\r\n                        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\r\n                        break;\r\n                }\r\n            }\r\n            var childToDelete = createFiberFromHostInstanceForDeletion();\r\n            childToDelete.stateNode = instance;\r\n            childToDelete.return = returnFiber;\r\n            childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,\r\n            // these children are not part of the reconciliation list of children.\r\n            // Even if we abort and rereconcile the children, that will try to hydrate\r\n            // again and the nodes are still in the host tree so these will be\r\n            // recreated.\r\n            if (returnFiber.lastEffect !== null) {\r\n                returnFiber.lastEffect.nextEffect = childToDelete;\r\n                returnFiber.lastEffect = childToDelete;\r\n            }\r\n            else {\r\n                returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\r\n            }\r\n        }\r\n        function insertNonHydratedInstance(returnFiber, fiber) {\r\n            fiber.flags = fiber.flags & ~Hydrating | Placement;\r\n            {\r\n                switch (returnFiber.tag) {\r\n                    case HostRoot:\r\n                        {\r\n                            var parentContainer = returnFiber.stateNode.containerInfo;\r\n                            switch (fiber.tag) {\r\n                                case HostComponent:\r\n                                    var type = fiber.type;\r\n                                    var props = fiber.pendingProps;\r\n                                    didNotFindHydratableContainerInstance(parentContainer, type);\r\n                                    break;\r\n                                case HostText:\r\n                                    var text = fiber.pendingProps;\r\n                                    didNotFindHydratableContainerTextInstance(parentContainer, text);\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        }\r\n                    case HostComponent:\r\n                        {\r\n                            var parentType = returnFiber.type;\r\n                            var parentProps = returnFiber.memoizedProps;\r\n                            var parentInstance = returnFiber.stateNode;\r\n                            switch (fiber.tag) {\r\n                                case HostComponent:\r\n                                    var _type = fiber.type;\r\n                                    var _props = fiber.pendingProps;\r\n                                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);\r\n                                    break;\r\n                                case HostText:\r\n                                    var _text = fiber.pendingProps;\r\n                                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\r\n                                    break;\r\n                                case SuspenseComponent:\r\n                                    didNotFindHydratableSuspenseInstance(parentType, parentProps);\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        }\r\n                    default:\r\n                        return;\r\n                }\r\n            }\r\n        }\r\n        function tryHydrate(fiber, nextInstance) {\r\n            switch (fiber.tag) {\r\n                case HostComponent:\r\n                    {\r\n                        var type = fiber.type;\r\n                        var props = fiber.pendingProps;\r\n                        var instance = canHydrateInstance(nextInstance, type);\r\n                        if (instance !== null) {\r\n                            fiber.stateNode = instance;\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    }\r\n                case HostText:\r\n                    {\r\n                        var text = fiber.pendingProps;\r\n                        var textInstance = canHydrateTextInstance(nextInstance, text);\r\n                        if (textInstance !== null) {\r\n                            fiber.stateNode = textInstance;\r\n                            return true;\r\n                        }\r\n                        return false;\r\n                    }\r\n                case SuspenseComponent:\r\n                    {\r\n                        return false;\r\n                    }\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n        function tryToClaimNextHydratableInstance(fiber) {\r\n            if (!isHydrating) {\r\n                return;\r\n            }\r\n            var nextInstance = nextHydratableInstance;\r\n            if (!nextInstance) {\r\n                // Nothing to hydrate. Make it an insertion.\r\n                insertNonHydratedInstance(hydrationParentFiber, fiber);\r\n                isHydrating = false;\r\n                hydrationParentFiber = fiber;\r\n                return;\r\n            }\r\n            var firstAttemptedInstance = nextInstance;\r\n            if (!tryHydrate(fiber, nextInstance)) {\r\n                // If we can't hydrate this instance let's try the next one.\r\n                // We use this as a heuristic. It's based on intuition and not data so it\r\n                // might be flawed or unnecessary.\r\n                nextInstance = getNextHydratableSibling(firstAttemptedInstance);\r\n                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\r\n                    // Nothing to hydrate. Make it an insertion.\r\n                    insertNonHydratedInstance(hydrationParentFiber, fiber);\r\n                    isHydrating = false;\r\n                    hydrationParentFiber = fiber;\r\n                    return;\r\n                } // We matched the next one, we'll now assume that the first one was\r\n                // superfluous and we'll delete it. Since we can't eagerly delete it\r\n                // we'll have to schedule a deletion. To do that, this node needs a dummy\r\n                // fiber associated with it.\r\n                deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\r\n            }\r\n            hydrationParentFiber = fiber;\r\n            nextHydratableInstance = getFirstHydratableChild(nextInstance);\r\n        }\r\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\r\n            var instance = fiber.stateNode;\r\n            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\r\n            fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\r\n            // is a new ref we mark this as an update.\r\n            if (updatePayload !== null) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        function prepareToHydrateHostTextInstance(fiber) {\r\n            var textInstance = fiber.stateNode;\r\n            var textContent = fiber.memoizedProps;\r\n            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\r\n            {\r\n                if (shouldUpdate) {\r\n                    // We assume that prepareToHydrateHostTextInstance is called in a context where the\r\n                    // hydration parent is the parent host component of this host text.\r\n                    var returnFiber = hydrationParentFiber;\r\n                    if (returnFiber !== null) {\r\n                        switch (returnFiber.tag) {\r\n                            case HostRoot:\r\n                                {\r\n                                    var parentContainer = returnFiber.stateNode.containerInfo;\r\n                                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\r\n                                    break;\r\n                                }\r\n                            case HostComponent:\r\n                                {\r\n                                    var parentType = returnFiber.type;\r\n                                    var parentProps = returnFiber.memoizedProps;\r\n                                    var parentInstance = returnFiber.stateNode;\r\n                                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\r\n                                    break;\r\n                                }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return shouldUpdate;\r\n        }\r\n        function skipPastDehydratedSuspenseInstance(fiber) {\r\n            var suspenseState = fiber.memoizedState;\r\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\r\n            if (!suspenseInstance) {\r\n                {\r\n                    throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\r\n        }\r\n        function popToNextHostParent(fiber) {\r\n            var parent = fiber.return;\r\n            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\r\n                parent = parent.return;\r\n            }\r\n            hydrationParentFiber = parent;\r\n        }\r\n        function popHydrationState(fiber) {\r\n            if (fiber !== hydrationParentFiber) {\r\n                // We're deeper than the current hydration context, inside an inserted\r\n                // tree.\r\n                return false;\r\n            }\r\n            if (!isHydrating) {\r\n                // If we're not currently hydrating but we're in a hydration context, then\r\n                // we were an insertion and now need to pop up reenter hydration of our\r\n                // siblings.\r\n                popToNextHostParent(fiber);\r\n                isHydrating = true;\r\n                return false;\r\n            }\r\n            var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\r\n            // We only do this deeper than head and body since they tend to have random\r\n            // other nodes in them. We also ignore components with pure text content in\r\n            // side of them.\r\n            // TODO: Better heuristic.\r\n            if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\r\n                var nextInstance = nextHydratableInstance;\r\n                while (nextInstance) {\r\n                    deleteHydratableInstance(fiber, nextInstance);\r\n                    nextInstance = getNextHydratableSibling(nextInstance);\r\n                }\r\n            }\r\n            popToNextHostParent(fiber);\r\n            if (fiber.tag === SuspenseComponent) {\r\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\r\n            }\r\n            else {\r\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\r\n            }\r\n            return true;\r\n        }\r\n        function resetHydrationState() {\r\n            hydrationParentFiber = null;\r\n            nextHydratableInstance = null;\r\n            isHydrating = false;\r\n        }\r\n        function getIsHydrating() {\r\n            return isHydrating;\r\n        }\r\n        // and should be reset before starting a new render.\r\n        // This tracks which mutable sources need to be reset after a render.\r\n        var workInProgressSources = [];\r\n        var rendererSigil$1;\r\n        {\r\n            // Used to detect multiple renderers using the same mutable source.\r\n            rendererSigil$1 = {};\r\n        }\r\n        function markSourceAsDirty(mutableSource) {\r\n            workInProgressSources.push(mutableSource);\r\n        }\r\n        function resetWorkInProgressVersions() {\r\n            for (var i = 0; i < workInProgressSources.length; i++) {\r\n                var mutableSource = workInProgressSources[i];\r\n                {\r\n                    mutableSource._workInProgressVersionPrimary = null;\r\n                }\r\n            }\r\n            workInProgressSources.length = 0;\r\n        }\r\n        function getWorkInProgressVersion(mutableSource) {\r\n            {\r\n                return mutableSource._workInProgressVersionPrimary;\r\n            }\r\n        }\r\n        function setWorkInProgressVersion(mutableSource, version) {\r\n            {\r\n                mutableSource._workInProgressVersionPrimary = version;\r\n            }\r\n            workInProgressSources.push(mutableSource);\r\n        }\r\n        function warnAboutMultipleRenderersDEV(mutableSource) {\r\n            {\r\n                {\r\n                    if (mutableSource._currentPrimaryRenderer == null) {\r\n                        mutableSource._currentPrimaryRenderer = rendererSigil$1;\r\n                    }\r\n                    else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {\r\n                        error('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.');\r\n                    }\r\n                }\r\n            }\r\n        } // Eager reads the version of a mutable source and stores it on the root.\r\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\r\n        var didWarnAboutMismatchedHooksForComponent;\r\n        var didWarnAboutUseOpaqueIdentifier;\r\n        {\r\n            didWarnAboutUseOpaqueIdentifier = {};\r\n            didWarnAboutMismatchedHooksForComponent = new Set();\r\n        }\r\n        // These are set right before calling the component.\r\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\r\n        // the work-in-progress hook.\r\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\r\n        // current hook list is the list that belongs to the current fiber. The\r\n        // work-in-progress hook list is a new list that will be added to the\r\n        // work-in-progress fiber.\r\n        var currentHook = null;\r\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\r\n        // does not get reset if we do another render pass; only when we're completely\r\n        // finished evaluating this component. This is an optimization so we know\r\n        // whether we need to clear render phase updates after a throw.\r\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\r\n        // gets reset after each attempt.\r\n        // TODO: Maybe there's some way to consolidate this with\r\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\r\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\r\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\r\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\r\n        // The list stores the order of hooks used during the initial render (mount).\r\n        // Subsequent renders (updates) reference this list.\r\n        var hookTypesDev = null;\r\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\r\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\r\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\r\n        var ignorePreviousDependencies = false;\r\n        function mountHookTypesDev() {\r\n            {\r\n                var hookName = currentHookNameInDev;\r\n                if (hookTypesDev === null) {\r\n                    hookTypesDev = [hookName];\r\n                }\r\n                else {\r\n                    hookTypesDev.push(hookName);\r\n                }\r\n            }\r\n        }\r\n        function updateHookTypesDev() {\r\n            {\r\n                var hookName = currentHookNameInDev;\r\n                if (hookTypesDev !== null) {\r\n                    hookTypesUpdateIndexDev++;\r\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\r\n                        warnOnHookMismatchInDev(hookName);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function checkDepsAreArrayDev(deps) {\r\n            {\r\n                if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\r\n                    // Verify deps, but only on mount to avoid extra checks.\r\n                    // It's unlikely their type would change as usually you define them inline.\r\n                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\r\n                }\r\n            }\r\n        }\r\n        function warnOnHookMismatchInDev(currentHookName) {\r\n            {\r\n                var componentName = getComponentName(currentlyRenderingFiber$1.type);\r\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\r\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\r\n                    if (hookTypesDev !== null) {\r\n                        var table = '';\r\n                        var secondColumnStart = 30;\r\n                        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\r\n                            var oldHookName = hookTypesDev[i];\r\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\r\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\r\n                            // lol @ IE not supporting String#repeat\r\n                            while (row.length < secondColumnStart) {\r\n                                row += ' ';\r\n                            }\r\n                            row += newHookName + '\\n';\r\n                            table += row;\r\n                        }\r\n                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function throwInvalidHookError() {\r\n            {\r\n                {\r\n                    throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\r\n                }\r\n            }\r\n        }\r\n        function areHookInputsEqual(nextDeps, prevDeps) {\r\n            {\r\n                if (ignorePreviousDependencies) {\r\n                    // Only true when this component is being hot reloaded.\r\n                    return false;\r\n                }\r\n            }\r\n            if (prevDeps === null) {\r\n                {\r\n                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\r\n                }\r\n                return false;\r\n            }\r\n            {\r\n                // Don't bother comparing lengths in prod because these arrays should be\r\n                // passed inline.\r\n                if (nextDeps.length !== prevDeps.length) {\r\n                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\r\n                }\r\n            }\r\n            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\r\n                if (objectIs(nextDeps[i], prevDeps[i])) {\r\n                    continue;\r\n                }\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\r\n            renderLanes = nextRenderLanes;\r\n            currentlyRenderingFiber$1 = workInProgress;\r\n            {\r\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\r\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\r\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\r\n            }\r\n            workInProgress.memoizedState = null;\r\n            workInProgress.updateQueue = null;\r\n            workInProgress.lanes = NoLanes; // The following should have already been reset\r\n            // currentHook = null;\r\n            // workInProgressHook = null;\r\n            // didScheduleRenderPhaseUpdate = false;\r\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\r\n            // Currently we will identify the update render as a mount because memoizedState === null.\r\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\r\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\r\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\r\n            // so memoizedState would be null during updates and mounts.\r\n            {\r\n                if (current !== null && current.memoizedState !== null) {\r\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\r\n                }\r\n                else if (hookTypesDev !== null) {\r\n                    // This dispatcher handles an edge case where a component is updating,\r\n                    // but no stateful hooks have been used.\r\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\r\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\r\n                    // This dispatcher does that.\r\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\r\n                }\r\n                else {\r\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\r\n                }\r\n            }\r\n            var children = Component(props, secondArg); // Check if there was a render phase update\r\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\r\n                // Keep rendering in a loop for as long as render phase updates continue to\r\n                // be scheduled. Use a counter to prevent infinite loops.\r\n                var numberOfReRenders = 0;\r\n                do {\r\n                    didScheduleRenderPhaseUpdateDuringThisPass = false;\r\n                    if (!(numberOfReRenders < RE_RENDER_LIMIT)) {\r\n                        {\r\n                            throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\r\n                        }\r\n                    }\r\n                    numberOfReRenders += 1;\r\n                    {\r\n                        // Even when hot reloading, allow dependencies to stabilize\r\n                        // after first render to prevent infinite render phase updates.\r\n                        ignorePreviousDependencies = false;\r\n                    } // Start over from the beginning of the list\r\n                    currentHook = null;\r\n                    workInProgressHook = null;\r\n                    workInProgress.updateQueue = null;\r\n                    {\r\n                        // Also validate hook order for cascading updates.\r\n                        hookTypesUpdateIndexDev = -1;\r\n                    }\r\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\r\n                    children = Component(props, secondArg);\r\n                } while (didScheduleRenderPhaseUpdateDuringThisPass);\r\n            } // We can assume the previous dispatcher is always this one, since we set it\r\n            // at the beginning of the render phase and there's no re-entrancy.\r\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\r\n            {\r\n                workInProgress._debugHookTypes = hookTypesDev;\r\n            } // This check uses currentHook so that it works the same in DEV and prod bundles.\r\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\r\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\r\n            renderLanes = NoLanes;\r\n            currentlyRenderingFiber$1 = null;\r\n            currentHook = null;\r\n            workInProgressHook = null;\r\n            {\r\n                currentHookNameInDev = null;\r\n                hookTypesDev = null;\r\n                hookTypesUpdateIndexDev = -1;\r\n            }\r\n            didScheduleRenderPhaseUpdate = false;\r\n            if (!!didRenderTooFewHooks) {\r\n                {\r\n                    throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\r\n                }\r\n            }\r\n            return children;\r\n        }\r\n        function bailoutHooks(current, workInProgress, lanes) {\r\n            workInProgress.updateQueue = current.updateQueue;\r\n            workInProgress.flags &= ~(Passive | Update);\r\n            current.lanes = removeLanes(current.lanes, lanes);\r\n        }\r\n        function resetHooksAfterThrow() {\r\n            // We can assume the previous dispatcher is always this one, since we set it\r\n            // at the beginning of the render phase and there's no re-entrancy.\r\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\r\n            if (didScheduleRenderPhaseUpdate) {\r\n                // There were render phase updates. These are only valid for this render\r\n                // phase, which we are now aborting. Remove the updates from the queues so\r\n                // they do not persist to the next render. Do not remove updates from hooks\r\n                // that weren't processed.\r\n                //\r\n                // Only reset the updates from the queue if it has a clone. If it does\r\n                // not have a clone, that means it wasn't processed, and the updates were\r\n                // scheduled before we entered the render phase.\r\n                var hook = currentlyRenderingFiber$1.memoizedState;\r\n                while (hook !== null) {\r\n                    var queue = hook.queue;\r\n                    if (queue !== null) {\r\n                        queue.pending = null;\r\n                    }\r\n                    hook = hook.next;\r\n                }\r\n                didScheduleRenderPhaseUpdate = false;\r\n            }\r\n            renderLanes = NoLanes;\r\n            currentlyRenderingFiber$1 = null;\r\n            currentHook = null;\r\n            workInProgressHook = null;\r\n            {\r\n                hookTypesDev = null;\r\n                hookTypesUpdateIndexDev = -1;\r\n                currentHookNameInDev = null;\r\n                isUpdatingOpaqueValueInRenderPhase = false;\r\n            }\r\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\r\n        }\r\n        function mountWorkInProgressHook() {\r\n            var hook = {\r\n                memoizedState: null,\r\n                baseState: null,\r\n                baseQueue: null,\r\n                queue: null,\r\n                next: null\r\n            };\r\n            if (workInProgressHook === null) {\r\n                // This is the first hook in the list\r\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\r\n            }\r\n            else {\r\n                // Append to the end of the list\r\n                workInProgressHook = workInProgressHook.next = hook;\r\n            }\r\n            return workInProgressHook;\r\n        }\r\n        function updateWorkInProgressHook() {\r\n            // This function is used both for updates and for re-renders triggered by a\r\n            // render phase update. It assumes there is either a current hook we can\r\n            // clone, or a work-in-progress hook from a previous render pass that we can\r\n            // use as a base. When we reach the end of the base list, we must switch to\r\n            // the dispatcher used for mounts.\r\n            var nextCurrentHook;\r\n            if (currentHook === null) {\r\n                var current = currentlyRenderingFiber$1.alternate;\r\n                if (current !== null) {\r\n                    nextCurrentHook = current.memoizedState;\r\n                }\r\n                else {\r\n                    nextCurrentHook = null;\r\n                }\r\n            }\r\n            else {\r\n                nextCurrentHook = currentHook.next;\r\n            }\r\n            var nextWorkInProgressHook;\r\n            if (workInProgressHook === null) {\r\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\r\n            }\r\n            else {\r\n                nextWorkInProgressHook = workInProgressHook.next;\r\n            }\r\n            if (nextWorkInProgressHook !== null) {\r\n                // There's already a work-in-progress. Reuse it.\r\n                workInProgressHook = nextWorkInProgressHook;\r\n                nextWorkInProgressHook = workInProgressHook.next;\r\n                currentHook = nextCurrentHook;\r\n            }\r\n            else {\r\n                // Clone from the current hook.\r\n                if (!(nextCurrentHook !== null)) {\r\n                    {\r\n                        throw Error(\"Rendered more hooks than during the previous render.\");\r\n                    }\r\n                }\r\n                currentHook = nextCurrentHook;\r\n                var newHook = {\r\n                    memoizedState: currentHook.memoizedState,\r\n                    baseState: currentHook.baseState,\r\n                    baseQueue: currentHook.baseQueue,\r\n                    queue: currentHook.queue,\r\n                    next: null\r\n                };\r\n                if (workInProgressHook === null) {\r\n                    // This is the first hook in the list.\r\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\r\n                }\r\n                else {\r\n                    // Append to the end of the list.\r\n                    workInProgressHook = workInProgressHook.next = newHook;\r\n                }\r\n            }\r\n            return workInProgressHook;\r\n        }\r\n        function createFunctionComponentUpdateQueue() {\r\n            return {\r\n                lastEffect: null\r\n            };\r\n        }\r\n        function basicStateReducer(state, action) {\r\n            // $FlowFixMe: Flow doesn't like mixed types\r\n            return typeof action === 'function' ? action(state) : action;\r\n        }\r\n        function mountReducer(reducer, initialArg, init) {\r\n            var hook = mountWorkInProgressHook();\r\n            var initialState;\r\n            if (init !== undefined) {\r\n                initialState = init(initialArg);\r\n            }\r\n            else {\r\n                initialState = initialArg;\r\n            }\r\n            hook.memoizedState = hook.baseState = initialState;\r\n            var queue = hook.queue = {\r\n                pending: null,\r\n                dispatch: null,\r\n                lastRenderedReducer: reducer,\r\n                lastRenderedState: initialState\r\n            };\r\n            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);\r\n            return [hook.memoizedState, dispatch];\r\n        }\r\n        function updateReducer(reducer, initialArg, init) {\r\n            var hook = updateWorkInProgressHook();\r\n            var queue = hook.queue;\r\n            if (!(queue !== null)) {\r\n                {\r\n                    throw Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            queue.lastRenderedReducer = reducer;\r\n            var current = currentHook; // The last rebase update that is NOT part of the base state.\r\n            var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\r\n            var pendingQueue = queue.pending;\r\n            if (pendingQueue !== null) {\r\n                // We have new updates that haven't been processed yet.\r\n                // We'll add them to the base queue.\r\n                if (baseQueue !== null) {\r\n                    // Merge the pending queue and the base queue.\r\n                    var baseFirst = baseQueue.next;\r\n                    var pendingFirst = pendingQueue.next;\r\n                    baseQueue.next = pendingFirst;\r\n                    pendingQueue.next = baseFirst;\r\n                }\r\n                {\r\n                    if (current.baseQueue !== baseQueue) {\r\n                        // Internal invariant that should never happen, but feasibly could in\r\n                        // the future if we implement resuming, or some form of that.\r\n                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\r\n                    }\r\n                }\r\n                current.baseQueue = baseQueue = pendingQueue;\r\n                queue.pending = null;\r\n            }\r\n            if (baseQueue !== null) {\r\n                // We have a queue to process.\r\n                var first = baseQueue.next;\r\n                var newState = current.baseState;\r\n                var newBaseState = null;\r\n                var newBaseQueueFirst = null;\r\n                var newBaseQueueLast = null;\r\n                var update = first;\r\n                do {\r\n                    var updateLane = update.lane;\r\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\r\n                        // Priority is insufficient. Skip this update. If this is the first\r\n                        // skipped update, the previous update/state is the new base\r\n                        // update/state.\r\n                        var clone = {\r\n                            lane: updateLane,\r\n                            action: update.action,\r\n                            eagerReducer: update.eagerReducer,\r\n                            eagerState: update.eagerState,\r\n                            next: null\r\n                        };\r\n                        if (newBaseQueueLast === null) {\r\n                            newBaseQueueFirst = newBaseQueueLast = clone;\r\n                            newBaseState = newState;\r\n                        }\r\n                        else {\r\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\r\n                        } // Update the remaining priority in the queue.\r\n                        // TODO: Don't need to accumulate this. Instead, we can remove\r\n                        // renderLanes from the original lanes.\r\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\r\n                        markSkippedUpdateLanes(updateLane);\r\n                    }\r\n                    else {\r\n                        // This update does have sufficient priority.\r\n                        if (newBaseQueueLast !== null) {\r\n                            var _clone = {\r\n                                // This update is going to be committed so we never want uncommit\r\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\r\n                                // this will never be skipped by the check above.\r\n                                lane: NoLane,\r\n                                action: update.action,\r\n                                eagerReducer: update.eagerReducer,\r\n                                eagerState: update.eagerState,\r\n                                next: null\r\n                            };\r\n                            newBaseQueueLast = newBaseQueueLast.next = _clone;\r\n                        } // Process this update.\r\n                        if (update.eagerReducer === reducer) {\r\n                            // If this update was processed eagerly, and its reducer matches the\r\n                            // current reducer, we can use the eagerly computed state.\r\n                            newState = update.eagerState;\r\n                        }\r\n                        else {\r\n                            var action = update.action;\r\n                            newState = reducer(newState, action);\r\n                        }\r\n                    }\r\n                    update = update.next;\r\n                } while (update !== null && update !== first);\r\n                if (newBaseQueueLast === null) {\r\n                    newBaseState = newState;\r\n                }\r\n                else {\r\n                    newBaseQueueLast.next = newBaseQueueFirst;\r\n                } // Mark that the fiber performed work, but only if the new state is\r\n                // different from the current state.\r\n                if (!objectIs(newState, hook.memoizedState)) {\r\n                    markWorkInProgressReceivedUpdate();\r\n                }\r\n                hook.memoizedState = newState;\r\n                hook.baseState = newBaseState;\r\n                hook.baseQueue = newBaseQueueLast;\r\n                queue.lastRenderedState = newState;\r\n            }\r\n            var dispatch = queue.dispatch;\r\n            return [hook.memoizedState, dispatch];\r\n        }\r\n        function rerenderReducer(reducer, initialArg, init) {\r\n            var hook = updateWorkInProgressHook();\r\n            var queue = hook.queue;\r\n            if (!(queue !== null)) {\r\n                {\r\n                    throw Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\r\n            // work-in-progress hook.\r\n            var dispatch = queue.dispatch;\r\n            var lastRenderPhaseUpdate = queue.pending;\r\n            var newState = hook.memoizedState;\r\n            if (lastRenderPhaseUpdate !== null) {\r\n                // The queue doesn't persist past this render pass.\r\n                queue.pending = null;\r\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\r\n                var update = firstRenderPhaseUpdate;\r\n                do {\r\n                    // Process this render phase update. We don't have to check the\r\n                    // priority because it will always be the same as the current\r\n                    // render's.\r\n                    var action = update.action;\r\n                    newState = reducer(newState, action);\r\n                    update = update.next;\r\n                } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\r\n                // different from the current state.\r\n                if (!objectIs(newState, hook.memoizedState)) {\r\n                    markWorkInProgressReceivedUpdate();\r\n                }\r\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\r\n                // the base state unless the queue is empty.\r\n                // TODO: Not sure if this is the desired semantics, but it's what we\r\n                // do for gDSFP. I can't remember why.\r\n                if (hook.baseQueue === null) {\r\n                    hook.baseState = newState;\r\n                }\r\n                queue.lastRenderedState = newState;\r\n            }\r\n            return [newState, dispatch];\r\n        }\r\n        function readFromUnsubcribedMutableSource(root, source, getSnapshot) {\r\n            {\r\n                warnAboutMultipleRenderersDEV(source);\r\n            }\r\n            var getVersion = source._getVersion;\r\n            var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?\r\n            var isSafeToReadFromSource = false; // Check the version first.\r\n            // If this render has already been started with a specific version,\r\n            // we can use it alone to determine if we can safely read from the source.\r\n            var currentRenderVersion = getWorkInProgressVersion(source);\r\n            if (currentRenderVersion !== null) {\r\n                // It's safe to read if the store hasn't been mutated since the last time\r\n                // we read something.\r\n                isSafeToReadFromSource = currentRenderVersion === version;\r\n            }\r\n            else {\r\n                // If there's no version, then this is the first time we've read from the\r\n                // source during the current render pass, so we need to do a bit more work.\r\n                // What we need to determine is if there are any hooks that already\r\n                // subscribed to the source, and if so, whether there are any pending\r\n                // mutations that haven't been synchronized yet.\r\n                //\r\n                // If there are no pending mutations, then `root.mutableReadLanes` will be\r\n                // empty, and we know we can safely read.\r\n                //\r\n                // If there *are* pending mutations, we may still be able to safely read\r\n                // if the currently rendering lanes are inclusive of the pending mutation\r\n                // lanes, since that guarantees that the value we're about to read from\r\n                // the source is consistent with the values that we read during the most\r\n                // recent mutation.\r\n                isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);\r\n                if (isSafeToReadFromSource) {\r\n                    // If it's safe to read from this source during the current render,\r\n                    // store the version in case other components read from it.\r\n                    // A changed version number will let those components know to throw and restart the render.\r\n                    setWorkInProgressVersion(source, version);\r\n                }\r\n            }\r\n            if (isSafeToReadFromSource) {\r\n                var snapshot = getSnapshot(source._source);\r\n                {\r\n                    if (typeof snapshot === 'function') {\r\n                        error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\r\n                    }\r\n                }\r\n                return snapshot;\r\n            }\r\n            else {\r\n                // This handles the special case of a mutable source being shared between renderers.\r\n                // In that case, if the source is mutated between the first and second renderer,\r\n                // The second renderer don't know that it needs to reset the WIP version during unwind,\r\n                // (because the hook only marks sources as dirty if it's written to their WIP version).\r\n                // That would cause this tear check to throw again and eventually be visible to the user.\r\n                // We can avoid this infinite loop by explicitly marking the source as dirty.\r\n                //\r\n                // This can lead to tearing in the first renderer when it resumes,\r\n                // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\r\n                markSourceAsDirty(source);\r\n                {\r\n                    {\r\n                        throw Error(\"Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function useMutableSource(hook, source, getSnapshot, subscribe) {\r\n            var root = getWorkInProgressRoot();\r\n            if (!(root !== null)) {\r\n                {\r\n                    throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            var getVersion = source._getVersion;\r\n            var version = getVersion(source._source);\r\n            var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const\r\n            var _dispatcher$useState = dispatcher.useState(function () {\r\n                return readFromUnsubcribedMutableSource(root, source, getSnapshot);\r\n            }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];\r\n            var snapshot = currentSnapshot; // Grab a handle to the state hook as well.\r\n            // We use it to clear the pending update queue if we have a new source.\r\n            var stateHook = workInProgressHook;\r\n            var memoizedState = hook.memoizedState;\r\n            var refs = memoizedState.refs;\r\n            var prevGetSnapshot = refs.getSnapshot;\r\n            var prevSource = memoizedState.source;\r\n            var prevSubscribe = memoizedState.subscribe;\r\n            var fiber = currentlyRenderingFiber$1;\r\n            hook.memoizedState = {\r\n                refs: refs,\r\n                source: source,\r\n                subscribe: subscribe\r\n            }; // Sync the values needed by our subscription handler after each commit.\r\n            dispatcher.useEffect(function () {\r\n                refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,\r\n                // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\r\n                // handleChange() below needs to reference the dispatch function without re-subscribing,\r\n                // so we use a ref to ensure that it always has the latest version.\r\n                refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.\r\n                var maybeNewVersion = getVersion(source._source);\r\n                if (!objectIs(version, maybeNewVersion)) {\r\n                    var maybeNewSnapshot = getSnapshot(source._source);\r\n                    {\r\n                        if (typeof maybeNewSnapshot === 'function') {\r\n                            error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\r\n                        }\r\n                    }\r\n                    if (!objectIs(snapshot, maybeNewSnapshot)) {\r\n                        setSnapshot(maybeNewSnapshot);\r\n                        var lane = requestUpdateLane(fiber);\r\n                        markRootMutableRead(root, lane);\r\n                    } // If the source mutated between render and now,\r\n                    // there may be state updates already scheduled from the old source.\r\n                    // Entangle the updates so that they render in the same batch.\r\n                    markRootEntangled(root, root.mutableReadLanes);\r\n                }\r\n            }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.\r\n            dispatcher.useEffect(function () {\r\n                var handleChange = function () {\r\n                    var latestGetSnapshot = refs.getSnapshot;\r\n                    var latestSetSnapshot = refs.setSnapshot;\r\n                    try {\r\n                        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.\r\n                        var lane = requestUpdateLane(fiber);\r\n                        markRootMutableRead(root, lane);\r\n                    }\r\n                    catch (error) {\r\n                        // A selector might throw after a source mutation.\r\n                        // e.g. it might try to read from a part of the store that no longer exists.\r\n                        // In this case we should still schedule an update with React.\r\n                        // Worst case the selector will throw again and then an error boundary will handle it.\r\n                        latestSetSnapshot(function () {\r\n                            throw error;\r\n                        });\r\n                    }\r\n                };\r\n                var unsubscribe = subscribe(source._source, handleChange);\r\n                {\r\n                    if (typeof unsubscribe !== 'function') {\r\n                        error('Mutable source subscribe function must return an unsubscribe function.');\r\n                    }\r\n                }\r\n                return unsubscribe;\r\n            }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.\r\n            //\r\n            // If either the source or the subscription have changed we can't can't trust the update queue.\r\n            // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\r\n            //\r\n            // If the getSnapshot function changed, we also shouldn't rely on the update queue.\r\n            // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\r\n            // and when the current render (with the new getSnapshot function) is processed.\r\n            //\r\n            // In both cases, we need to throw away pending updates (since they are no longer relevant)\r\n            // and treat reading from the source as we do in the mount case.\r\n            if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {\r\n                // Create a new queue and setState method,\r\n                // So if there are interleaved updates, they get pushed to the older queue.\r\n                // When this becomes current, the previous queue and dispatch method will be discarded,\r\n                // including any interleaving updates that occur.\r\n                var newQueue = {\r\n                    pending: null,\r\n                    dispatch: null,\r\n                    lastRenderedReducer: basicStateReducer,\r\n                    lastRenderedState: snapshot\r\n                };\r\n                newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);\r\n                stateHook.queue = newQueue;\r\n                stateHook.baseQueue = null;\r\n                snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);\r\n                stateHook.memoizedState = stateHook.baseState = snapshot;\r\n            }\r\n            return snapshot;\r\n        }\r\n        function mountMutableSource(source, getSnapshot, subscribe) {\r\n            var hook = mountWorkInProgressHook();\r\n            hook.memoizedState = {\r\n                refs: {\r\n                    getSnapshot: getSnapshot,\r\n                    setSnapshot: null\r\n                },\r\n                source: source,\r\n                subscribe: subscribe\r\n            };\r\n            return useMutableSource(hook, source, getSnapshot, subscribe);\r\n        }\r\n        function updateMutableSource(source, getSnapshot, subscribe) {\r\n            var hook = updateWorkInProgressHook();\r\n            return useMutableSource(hook, source, getSnapshot, subscribe);\r\n        }\r\n        function mountState(initialState) {\r\n            var hook = mountWorkInProgressHook();\r\n            if (typeof initialState === 'function') {\r\n                // $FlowFixMe: Flow doesn't like mixed types\r\n                initialState = initialState();\r\n            }\r\n            hook.memoizedState = hook.baseState = initialState;\r\n            var queue = hook.queue = {\r\n                pending: null,\r\n                dispatch: null,\r\n                lastRenderedReducer: basicStateReducer,\r\n                lastRenderedState: initialState\r\n            };\r\n            var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);\r\n            return [hook.memoizedState, dispatch];\r\n        }\r\n        function updateState(initialState) {\r\n            return updateReducer(basicStateReducer);\r\n        }\r\n        function rerenderState(initialState) {\r\n            return rerenderReducer(basicStateReducer);\r\n        }\r\n        function pushEffect(tag, create, destroy, deps) {\r\n            var effect = {\r\n                tag: tag,\r\n                create: create,\r\n                destroy: destroy,\r\n                deps: deps,\r\n                // Circular\r\n                next: null\r\n            };\r\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\r\n            if (componentUpdateQueue === null) {\r\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\r\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\r\n                componentUpdateQueue.lastEffect = effect.next = effect;\r\n            }\r\n            else {\r\n                var lastEffect = componentUpdateQueue.lastEffect;\r\n                if (lastEffect === null) {\r\n                    componentUpdateQueue.lastEffect = effect.next = effect;\r\n                }\r\n                else {\r\n                    var firstEffect = lastEffect.next;\r\n                    lastEffect.next = effect;\r\n                    effect.next = firstEffect;\r\n                    componentUpdateQueue.lastEffect = effect;\r\n                }\r\n            }\r\n            return effect;\r\n        }\r\n        function mountRef(initialValue) {\r\n            var hook = mountWorkInProgressHook();\r\n            var ref = {\r\n                current: initialValue\r\n            };\r\n            {\r\n                Object.seal(ref);\r\n            }\r\n            hook.memoizedState = ref;\r\n            return ref;\r\n        }\r\n        function updateRef(initialValue) {\r\n            var hook = updateWorkInProgressHook();\r\n            return hook.memoizedState;\r\n        }\r\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\r\n            var hook = mountWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            currentlyRenderingFiber$1.flags |= fiberFlags;\r\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\r\n        }\r\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\r\n            var hook = updateWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            var destroy = undefined;\r\n            if (currentHook !== null) {\r\n                var prevEffect = currentHook.memoizedState;\r\n                destroy = prevEffect.destroy;\r\n                if (nextDeps !== null) {\r\n                    var prevDeps = prevEffect.deps;\r\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n                        pushEffect(hookFlags, create, destroy, nextDeps);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            currentlyRenderingFiber$1.flags |= fiberFlags;\r\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\r\n        }\r\n        function mountEffect(create, deps) {\r\n            {\r\n                // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\r\n                if ('undefined' !== typeof jest) {\r\n                    warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);\r\n                }\r\n            }\r\n            return mountEffectImpl(Update | Passive, Passive$1, create, deps);\r\n        }\r\n        function updateEffect(create, deps) {\r\n            {\r\n                // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\r\n                if ('undefined' !== typeof jest) {\r\n                    warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);\r\n                }\r\n            }\r\n            return updateEffectImpl(Update | Passive, Passive$1, create, deps);\r\n        }\r\n        function mountLayoutEffect(create, deps) {\r\n            return mountEffectImpl(Update, Layout, create, deps);\r\n        }\r\n        function updateLayoutEffect(create, deps) {\r\n            return updateEffectImpl(Update, Layout, create, deps);\r\n        }\r\n        function imperativeHandleEffect(create, ref) {\r\n            if (typeof ref === 'function') {\r\n                var refCallback = ref;\r\n                var _inst = create();\r\n                refCallback(_inst);\r\n                return function () {\r\n                    refCallback(null);\r\n                };\r\n            }\r\n            else if (ref !== null && ref !== undefined) {\r\n                var refObject = ref;\r\n                {\r\n                    if (!refObject.hasOwnProperty('current')) {\r\n                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\r\n                    }\r\n                }\r\n                var _inst2 = create();\r\n                refObject.current = _inst2;\r\n                return function () {\r\n                    refObject.current = null;\r\n                };\r\n            }\r\n        }\r\n        function mountImperativeHandle(ref, create, deps) {\r\n            {\r\n                if (typeof create !== 'function') {\r\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\r\n                }\r\n            } // TODO: If deps are provided, should we skip comparing the ref itself?\r\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\r\n            return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\r\n        }\r\n        function updateImperativeHandle(ref, create, deps) {\r\n            {\r\n                if (typeof create !== 'function') {\r\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\r\n                }\r\n            } // TODO: If deps are provided, should we skip comparing the ref itself?\r\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\r\n            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\r\n        }\r\n        function mountDebugValue(value, formatterFn) {\r\n            // The react-debug-hooks package injects its own implementation\r\n            // so that e.g. DevTools can display custom hook values.\r\n        }\r\n        var updateDebugValue = mountDebugValue;\r\n        function mountCallback(callback, deps) {\r\n            var hook = mountWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            hook.memoizedState = [callback, nextDeps];\r\n            return callback;\r\n        }\r\n        function updateCallback(callback, deps) {\r\n            var hook = updateWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            var prevState = hook.memoizedState;\r\n            if (prevState !== null) {\r\n                if (nextDeps !== null) {\r\n                    var prevDeps = prevState[1];\r\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n                        return prevState[0];\r\n                    }\r\n                }\r\n            }\r\n            hook.memoizedState = [callback, nextDeps];\r\n            return callback;\r\n        }\r\n        function mountMemo(nextCreate, deps) {\r\n            var hook = mountWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            var nextValue = nextCreate();\r\n            hook.memoizedState = [nextValue, nextDeps];\r\n            return nextValue;\r\n        }\r\n        function updateMemo(nextCreate, deps) {\r\n            var hook = updateWorkInProgressHook();\r\n            var nextDeps = deps === undefined ? null : deps;\r\n            var prevState = hook.memoizedState;\r\n            if (prevState !== null) {\r\n                // Assume these are defined. If they're not, areHookInputsEqual will warn.\r\n                if (nextDeps !== null) {\r\n                    var prevDeps = prevState[1];\r\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\r\n                        return prevState[0];\r\n                    }\r\n                }\r\n            }\r\n            var nextValue = nextCreate();\r\n            hook.memoizedState = [nextValue, nextDeps];\r\n            return nextValue;\r\n        }\r\n        function mountDeferredValue(value) {\r\n            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];\r\n            mountEffect(function () {\r\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\r\n                ReactCurrentBatchConfig$1.transition = 1;\r\n                try {\r\n                    setValue(value);\r\n                }\r\n                finally {\r\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\r\n                }\r\n            }, [value]);\r\n            return prevValue;\r\n        }\r\n        function updateDeferredValue(value) {\r\n            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];\r\n            updateEffect(function () {\r\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\r\n                ReactCurrentBatchConfig$1.transition = 1;\r\n                try {\r\n                    setValue(value);\r\n                }\r\n                finally {\r\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\r\n                }\r\n            }, [value]);\r\n            return prevValue;\r\n        }\r\n        function rerenderDeferredValue(value) {\r\n            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];\r\n            updateEffect(function () {\r\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\r\n                ReactCurrentBatchConfig$1.transition = 1;\r\n                try {\r\n                    setValue(value);\r\n                }\r\n                finally {\r\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\r\n                }\r\n            }, [value]);\r\n            return prevValue;\r\n        }\r\n        function startTransition(setPending, callback) {\r\n            var priorityLevel = getCurrentPriorityLevel();\r\n            {\r\n                runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function () {\r\n                    setPending(true);\r\n                });\r\n                runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function () {\r\n                    var prevTransition = ReactCurrentBatchConfig$1.transition;\r\n                    ReactCurrentBatchConfig$1.transition = 1;\r\n                    try {\r\n                        setPending(false);\r\n                        callback();\r\n                    }\r\n                    finally {\r\n                        ReactCurrentBatchConfig$1.transition = prevTransition;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        function mountTransition() {\r\n            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`\r\n            // never changes.\r\n            var start = startTransition.bind(null, setPending);\r\n            mountRef(start);\r\n            return [start, isPending];\r\n        }\r\n        function updateTransition() {\r\n            var _updateState2 = updateState(), isPending = _updateState2[0];\r\n            var startRef = updateRef();\r\n            var start = startRef.current;\r\n            return [start, isPending];\r\n        }\r\n        function rerenderTransition() {\r\n            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];\r\n            var startRef = updateRef();\r\n            var start = startRef.current;\r\n            return [start, isPending];\r\n        }\r\n        var isUpdatingOpaqueValueInRenderPhase = false;\r\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\r\n            {\r\n                return isUpdatingOpaqueValueInRenderPhase;\r\n            }\r\n        }\r\n        function warnOnOpaqueIdentifierAccessInDEV(fiber) {\r\n            {\r\n                // TODO: Should warn in effects and callbacks, too\r\n                var name = getComponentName(fiber.type) || 'Unknown';\r\n                if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {\r\n                    error('The object passed back from useOpaqueIdentifier is meant to be ' + 'passed through to attributes only. Do not read the ' + 'value directly.');\r\n                    didWarnAboutUseOpaqueIdentifier[name] = true;\r\n                }\r\n            }\r\n        }\r\n        function mountOpaqueIdentifier() {\r\n            var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));\r\n            if (getIsHydrating()) {\r\n                var didUpgrade = false;\r\n                var fiber = currentlyRenderingFiber$1;\r\n                var readValue = function () {\r\n                    if (!didUpgrade) {\r\n                        // Only upgrade once. This works even inside the render phase because\r\n                        // the update is added to a shared queue, which outlasts the\r\n                        // in-progress render.\r\n                        didUpgrade = true;\r\n                        {\r\n                            isUpdatingOpaqueValueInRenderPhase = true;\r\n                            setId(makeId());\r\n                            isUpdatingOpaqueValueInRenderPhase = false;\r\n                            warnOnOpaqueIdentifierAccessInDEV(fiber);\r\n                        }\r\n                    }\r\n                    {\r\n                        {\r\n                            throw Error(\"The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.\");\r\n                        }\r\n                    }\r\n                };\r\n                var id = makeOpaqueHydratingObject(readValue);\r\n                var setId = mountState(id)[1];\r\n                if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {\r\n                    currentlyRenderingFiber$1.flags |= Update | Passive;\r\n                    pushEffect(HasEffect | Passive$1, function () {\r\n                        setId(makeId());\r\n                    }, undefined, null);\r\n                }\r\n                return id;\r\n            }\r\n            else {\r\n                var _id = makeId();\r\n                mountState(_id);\r\n                return _id;\r\n            }\r\n        }\r\n        function updateOpaqueIdentifier() {\r\n            var id = updateState()[0];\r\n            return id;\r\n        }\r\n        function rerenderOpaqueIdentifier() {\r\n            var id = rerenderState()[0];\r\n            return id;\r\n        }\r\n        function dispatchAction(fiber, queue, action) {\r\n            {\r\n                if (typeof arguments[3] === 'function') {\r\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\r\n                }\r\n            }\r\n            var eventTime = requestEventTime();\r\n            var lane = requestUpdateLane(fiber);\r\n            var update = {\r\n                lane: lane,\r\n                action: action,\r\n                eagerReducer: null,\r\n                eagerState: null,\r\n                next: null\r\n            }; // Append the update to the end of the list.\r\n            var pending = queue.pending;\r\n            if (pending === null) {\r\n                // This is the first update. Create a circular list.\r\n                update.next = update;\r\n            }\r\n            else {\r\n                update.next = pending.next;\r\n                pending.next = update;\r\n            }\r\n            queue.pending = update;\r\n            var alternate = fiber.alternate;\r\n            if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {\r\n                // This is a render phase update. Stash it in a lazily-created map of\r\n                // queue -> linked list of updates. After this render pass, we'll restart\r\n                // and apply the stashed updates on top of the work-in-progress hook.\r\n                didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\r\n            }\r\n            else {\r\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\r\n                    // The queue is currently empty, which means we can eagerly compute the\r\n                    // next state before entering the render phase. If the new state is the\r\n                    // same as the current state, we may be able to bail out entirely.\r\n                    var lastRenderedReducer = queue.lastRenderedReducer;\r\n                    if (lastRenderedReducer !== null) {\r\n                        var prevDispatcher;\r\n                        {\r\n                            prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                        }\r\n                        try {\r\n                            var currentState = queue.lastRenderedState;\r\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\r\n                            // it, on the update object. If the reducer hasn't changed by the\r\n                            // time we enter the render phase, then the eager state can be used\r\n                            // without calling the reducer again.\r\n                            update.eagerReducer = lastRenderedReducer;\r\n                            update.eagerState = eagerState;\r\n                            if (objectIs(eagerState, currentState)) {\r\n                                // Fast path. We can bail out without scheduling React to re-render.\r\n                                // It's still possible that we'll need to rebase this update later,\r\n                                // if the component re-renders for a different reason and by that\r\n                                // time the reducer has changed.\r\n                                return;\r\n                            }\r\n                        }\r\n                        catch (error) { // Suppress the error. It will throw again in the render phase.\r\n                        }\r\n                        finally {\r\n                            {\r\n                                ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                {\r\n                    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\r\n                    if ('undefined' !== typeof jest) {\r\n                        warnIfNotScopedWithMatchingAct(fiber);\r\n                        warnIfNotCurrentlyActingUpdatesInDev(fiber);\r\n                    }\r\n                }\r\n                scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            }\r\n        }\r\n        var ContextOnlyDispatcher = {\r\n            readContext: readContext,\r\n            useCallback: throwInvalidHookError,\r\n            useContext: throwInvalidHookError,\r\n            useEffect: throwInvalidHookError,\r\n            useImperativeHandle: throwInvalidHookError,\r\n            useLayoutEffect: throwInvalidHookError,\r\n            useMemo: throwInvalidHookError,\r\n            useReducer: throwInvalidHookError,\r\n            useRef: throwInvalidHookError,\r\n            useState: throwInvalidHookError,\r\n            useDebugValue: throwInvalidHookError,\r\n            useDeferredValue: throwInvalidHookError,\r\n            useTransition: throwInvalidHookError,\r\n            useMutableSource: throwInvalidHookError,\r\n            useOpaqueIdentifier: throwInvalidHookError,\r\n            unstable_isNewReconciler: enableNewReconciler\r\n        };\r\n        var HooksDispatcherOnMountInDEV = null;\r\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\r\n        var HooksDispatcherOnUpdateInDEV = null;\r\n        var HooksDispatcherOnRerenderInDEV = null;\r\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\r\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\r\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\r\n        {\r\n            var warnInvalidContextAccess = function () {\r\n                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\r\n            };\r\n            var warnInvalidHookAccess = function () {\r\n                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\r\n            };\r\n            HooksDispatcherOnMountInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    mountHookTypesDev();\r\n                    checkDepsAreArrayDev(deps);\r\n                    return mountCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    mountHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    mountHookTypesDev();\r\n                    checkDepsAreArrayDev(deps);\r\n                    return mountEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    mountHookTypesDev();\r\n                    checkDepsAreArrayDev(deps);\r\n                    return mountImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    mountHookTypesDev();\r\n                    checkDepsAreArrayDev(deps);\r\n                    return mountLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    mountHookTypesDev();\r\n                    checkDepsAreArrayDev(deps);\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    mountHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    mountHookTypesDev();\r\n                    return mountRef(initialValue);\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    mountHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    mountHookTypesDev();\r\n                    return mountDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    mountHookTypesDev();\r\n                    return mountDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    mountHookTypesDev();\r\n                    return mountTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    mountHookTypesDev();\r\n                    return mountMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    mountHookTypesDev();\r\n                    return mountOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            HooksDispatcherOnMountWithHookTypesInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    updateHookTypesDev();\r\n                    return mountCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    updateHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    updateHookTypesDev();\r\n                    return mountEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    updateHookTypesDev();\r\n                    return mountImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    updateHookTypesDev();\r\n                    return mountLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    updateHookTypesDev();\r\n                    return mountRef(initialValue);\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    updateHookTypesDev();\r\n                    return mountDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    updateHookTypesDev();\r\n                    return mountDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    updateHookTypesDev();\r\n                    return mountTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    updateHookTypesDev();\r\n                    return mountMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    updateHookTypesDev();\r\n                    return mountOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            HooksDispatcherOnUpdateInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    updateHookTypesDev();\r\n                    return updateCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    updateHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    updateHookTypesDev();\r\n                    return updateEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    updateHookTypesDev();\r\n                    return updateImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    updateHookTypesDev();\r\n                    return updateLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    updateHookTypesDev();\r\n                    return updateRef();\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    updateHookTypesDev();\r\n                    return updateDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    updateHookTypesDev();\r\n                    return updateDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    updateHookTypesDev();\r\n                    return updateTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    updateHookTypesDev();\r\n                    return updateMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    updateHookTypesDev();\r\n                    return updateOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            HooksDispatcherOnRerenderInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    updateHookTypesDev();\r\n                    return updateCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    updateHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    updateHookTypesDev();\r\n                    return updateEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    updateHookTypesDev();\r\n                    return updateImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    updateHookTypesDev();\r\n                    return updateLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n                    try {\r\n                        return updateMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n                    try {\r\n                        return rerenderReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    updateHookTypesDev();\r\n                    return updateRef();\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\r\n                    try {\r\n                        return rerenderState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    updateHookTypesDev();\r\n                    return updateDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    updateHookTypesDev();\r\n                    return rerenderDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    updateHookTypesDev();\r\n                    return rerenderTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    updateHookTypesDev();\r\n                    return updateMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    updateHookTypesDev();\r\n                    return rerenderOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            InvalidNestedHooksDispatcherOnMountInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    warnInvalidContextAccess();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountRef(initialValue);\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\r\n                    try {\r\n                        return mountState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    warnInvalidHookAccess();\r\n                    mountHookTypesDev();\r\n                    return mountOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    warnInvalidContextAccess();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateRef();\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\r\n                readContext: function (context, observedBits) {\r\n                    warnInvalidContextAccess();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useCallback: function (callback, deps) {\r\n                    currentHookNameInDev = 'useCallback';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateCallback(callback, deps);\r\n                },\r\n                useContext: function (context, observedBits) {\r\n                    currentHookNameInDev = 'useContext';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return readContext(context, observedBits);\r\n                },\r\n                useEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useEffect';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateEffect(create, deps);\r\n                },\r\n                useImperativeHandle: function (ref, create, deps) {\r\n                    currentHookNameInDev = 'useImperativeHandle';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateImperativeHandle(ref, create, deps);\r\n                },\r\n                useLayoutEffect: function (create, deps) {\r\n                    currentHookNameInDev = 'useLayoutEffect';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateLayoutEffect(create, deps);\r\n                },\r\n                useMemo: function (create, deps) {\r\n                    currentHookNameInDev = 'useMemo';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return updateMemo(create, deps);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useReducer: function (reducer, initialArg, init) {\r\n                    currentHookNameInDev = 'useReducer';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return rerenderReducer(reducer, initialArg, init);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useRef: function (initialValue) {\r\n                    currentHookNameInDev = 'useRef';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateRef();\r\n                },\r\n                useState: function (initialState) {\r\n                    currentHookNameInDev = 'useState';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\r\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\r\n                    try {\r\n                        return rerenderState(initialState);\r\n                    }\r\n                    finally {\r\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\r\n                    }\r\n                },\r\n                useDebugValue: function (value, formatterFn) {\r\n                    currentHookNameInDev = 'useDebugValue';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateDebugValue();\r\n                },\r\n                useDeferredValue: function (value) {\r\n                    currentHookNameInDev = 'useDeferredValue';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return rerenderDeferredValue(value);\r\n                },\r\n                useTransition: function () {\r\n                    currentHookNameInDev = 'useTransition';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return rerenderTransition();\r\n                },\r\n                useMutableSource: function (source, getSnapshot, subscribe) {\r\n                    currentHookNameInDev = 'useMutableSource';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return updateMutableSource(source, getSnapshot, subscribe);\r\n                },\r\n                useOpaqueIdentifier: function () {\r\n                    currentHookNameInDev = 'useOpaqueIdentifier';\r\n                    warnInvalidHookAccess();\r\n                    updateHookTypesDev();\r\n                    return rerenderOpaqueIdentifier();\r\n                },\r\n                unstable_isNewReconciler: enableNewReconciler\r\n            };\r\n        }\r\n        var now$1 = Scheduler.unstable_now;\r\n        var commitTime = 0;\r\n        var profilerStartTime = -1;\r\n        function getCommitTime() {\r\n            return commitTime;\r\n        }\r\n        function recordCommitTime() {\r\n            commitTime = now$1();\r\n        }\r\n        function startProfilerTimer(fiber) {\r\n            profilerStartTime = now$1();\r\n            if (fiber.actualStartTime < 0) {\r\n                fiber.actualStartTime = now$1();\r\n            }\r\n        }\r\n        function stopProfilerTimerIfRunning(fiber) {\r\n            profilerStartTime = -1;\r\n        }\r\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\r\n            if (profilerStartTime >= 0) {\r\n                var elapsedTime = now$1() - profilerStartTime;\r\n                fiber.actualDuration += elapsedTime;\r\n                if (overrideBaseTime) {\r\n                    fiber.selfBaseDuration = elapsedTime;\r\n                }\r\n                profilerStartTime = -1;\r\n            }\r\n        }\r\n        function transferActualDuration(fiber) {\r\n            // Transfer time spent rendering these children so we don't lose it\r\n            // after we rerender. This is used as a helper in special cases\r\n            // where we should count the work of multiple passes.\r\n            var child = fiber.child;\r\n            while (child) {\r\n                fiber.actualDuration += child.actualDuration;\r\n                child = child.sibling;\r\n            }\r\n        }\r\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\r\n        var didReceiveUpdate = false;\r\n        var didWarnAboutBadClass;\r\n        var didWarnAboutModulePatternComponent;\r\n        var didWarnAboutContextTypeOnFunctionComponent;\r\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\r\n        var didWarnAboutFunctionRefs;\r\n        var didWarnAboutReassigningProps;\r\n        var didWarnAboutRevealOrder;\r\n        var didWarnAboutTailOptions;\r\n        {\r\n            didWarnAboutBadClass = {};\r\n            didWarnAboutModulePatternComponent = {};\r\n            didWarnAboutContextTypeOnFunctionComponent = {};\r\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\r\n            didWarnAboutFunctionRefs = {};\r\n            didWarnAboutReassigningProps = false;\r\n            didWarnAboutRevealOrder = {};\r\n            didWarnAboutTailOptions = {};\r\n        }\r\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\r\n            if (current === null) {\r\n                // If this is a fresh new component that hasn't been rendered yet, we\r\n                // won't update its child set by applying minimal side-effects. Instead,\r\n                // we will add them all to the child before it gets rendered. That means\r\n                // we can optimize this reconciliation pass by not tracking side-effects.\r\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\r\n            }\r\n            else {\r\n                // If the current child is the same as the work in progress, it means that\r\n                // we haven't yet started any work on these children. Therefore, we use\r\n                // the clone algorithm to create a copy of all the current children.\r\n                // If we had any progressed work already, that is invalid at this point so\r\n                // let's throw it out.\r\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\r\n            }\r\n        }\r\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\r\n            // This function is fork of reconcileChildren. It's used in cases where we\r\n            // want to reconcile without matching against the existing set. This has the\r\n            // effect of all current children being unmounted; even if the type and key\r\n            // are the same, the old child is unmounted and a new child is created.\r\n            //\r\n            // To do this, we're going to go through the reconcile algorithm twice. In\r\n            // the first pass, we schedule a deletion for all the current children by\r\n            // passing null.\r\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\r\n            // pass null in place of where we usually pass the current child set. This has\r\n            // the effect of remounting all children regardless of whether their\r\n            // identities match.\r\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\r\n        }\r\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\r\n            // TODO: current can be non-null here even if the component\r\n            // hasn't yet mounted. This happens after the first render suspends.\r\n            // We'll need to figure out if this is fine or can cause issues.\r\n            {\r\n                if (workInProgress.type !== workInProgress.elementType) {\r\n                    // Lazy component props can't be validated in createElement\r\n                    // because they're only guaranteed to be resolved here.\r\n                    var innerPropTypes = Component.propTypes;\r\n                    if (innerPropTypes) {\r\n                        checkPropTypes(innerPropTypes, nextProps, // Resolved props\r\n                        'prop', getComponentName(Component));\r\n                    }\r\n                }\r\n            }\r\n            var render = Component.render;\r\n            var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\r\n            var nextChildren;\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            {\r\n                ReactCurrentOwner$1.current = workInProgress;\r\n                setIsRendering(true);\r\n                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\r\n                if (workInProgress.mode & StrictMode) {\r\n                    disableLogs();\r\n                    try {\r\n                        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\r\n                    }\r\n                    finally {\r\n                        reenableLogs();\r\n                    }\r\n                }\r\n                setIsRendering(false);\r\n            }\r\n            if (current !== null && !didReceiveUpdate) {\r\n                bailoutHooks(current, workInProgress, renderLanes);\r\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {\r\n            if (current === null) {\r\n                var type = Component.type;\r\n                if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\r\n                    Component.defaultProps === undefined) {\r\n                    var resolvedType = type;\r\n                    {\r\n                        resolvedType = resolveFunctionForHotReloading(type);\r\n                    } // If this is a plain function component without default props,\r\n                    // and with only the default shallow comparison, we upgrade it\r\n                    // to a SimpleMemoComponent to allow fast path updates.\r\n                    workInProgress.tag = SimpleMemoComponent;\r\n                    workInProgress.type = resolvedType;\r\n                    {\r\n                        validateFunctionComponentInDev(workInProgress, type);\r\n                    }\r\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);\r\n                }\r\n                {\r\n                    var innerPropTypes = type.propTypes;\r\n                    if (innerPropTypes) {\r\n                        // Inner memo component props aren't currently validated in createElement.\r\n                        // We could move it there, but we'd still need this for lazy code path.\r\n                        checkPropTypes(innerPropTypes, nextProps, // Resolved props\r\n                        'prop', getComponentName(type));\r\n                    }\r\n                }\r\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\r\n                child.ref = workInProgress.ref;\r\n                child.return = workInProgress;\r\n                workInProgress.child = child;\r\n                return child;\r\n            }\r\n            {\r\n                var _type = Component.type;\r\n                var _innerPropTypes = _type.propTypes;\r\n                if (_innerPropTypes) {\r\n                    // Inner memo component props aren't currently validated in createElement.\r\n                    // We could move it there, but we'd still need this for lazy code path.\r\n                    checkPropTypes(_innerPropTypes, nextProps, // Resolved props\r\n                    'prop', getComponentName(_type));\r\n                }\r\n            }\r\n            var currentChild = current.child; // This is always exactly one child\r\n            if (!includesSomeLane(updateLanes, renderLanes)) {\r\n                // This will be the props with resolved defaultProps,\r\n                // unlike current.memoizedProps which will be the unresolved ones.\r\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\r\n                var compare = Component.compare;\r\n                compare = compare !== null ? compare : shallowEqual;\r\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\r\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n                }\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            var newChild = createWorkInProgress(currentChild, nextProps);\r\n            newChild.ref = workInProgress.ref;\r\n            newChild.return = workInProgress;\r\n            workInProgress.child = newChild;\r\n            return newChild;\r\n        }\r\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {\r\n            // TODO: current can be non-null here even if the component\r\n            // hasn't yet mounted. This happens when the inner render suspends.\r\n            // We'll need to figure out if this is fine or can cause issues.\r\n            {\r\n                if (workInProgress.type !== workInProgress.elementType) {\r\n                    // Lazy component props can't be validated in createElement\r\n                    // because they're only guaranteed to be resolved here.\r\n                    var outerMemoType = workInProgress.elementType;\r\n                    if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\r\n                        // We warn when you define propTypes on lazy()\r\n                        // so let's just skip over it to find memo() outer wrapper.\r\n                        // Inner props for memo are validated later.\r\n                        var lazyComponent = outerMemoType;\r\n                        var payload = lazyComponent._payload;\r\n                        var init = lazyComponent._init;\r\n                        try {\r\n                            outerMemoType = init(payload);\r\n                        }\r\n                        catch (x) {\r\n                            outerMemoType = null;\r\n                        } // Inner propTypes will be validated in the function component path.\r\n                        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\r\n                        if (outerPropTypes) {\r\n                            checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\r\n                            'prop', getComponentName(outerMemoType));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (current !== null) {\r\n                var prevProps = current.memoizedProps;\r\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\r\n                workInProgress.type === current.type)) {\r\n                    didReceiveUpdate = false;\r\n                    if (!includesSomeLane(renderLanes, updateLanes)) {\r\n                        // The pending lanes were cleared at the beginning of beginWork. We're\r\n                        // about to bail out, but there might be other lanes that weren't\r\n                        // included in the current render. Usually, the priority level of the\r\n                        // remaining updates is accumlated during the evaluation of the\r\n                        // component (i.e. when processing the update queue). But since since\r\n                        // we're bailing out early *without* evaluating the component, we need\r\n                        // to account for it here, too. Reset to the value of the current fiber.\r\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\r\n                        // because a MemoComponent fiber does not have hooks or an update queue;\r\n                        // rather, it wraps around an inner component, which may or may not\r\n                        // contains hooks.\r\n                        // TODO: Move the reset at in beginWork out of the common path so that\r\n                        // this is no longer necessary.\r\n                        workInProgress.lanes = current.lanes;\r\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n                    }\r\n                    else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n                        // This is a special case that only exists for legacy mode.\r\n                        // See https://github.com/facebook/react/pull/19216.\r\n                        didReceiveUpdate = true;\r\n                    }\r\n                }\r\n            }\r\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\r\n        }\r\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\r\n            var nextProps = workInProgress.pendingProps;\r\n            var nextChildren = nextProps.children;\r\n            var prevState = current !== null ? current.memoizedState : null;\r\n            if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {\r\n                if ((workInProgress.mode & ConcurrentMode) === NoMode) {\r\n                    // In legacy sync mode, don't defer the subtree. Render it now.\r\n                    // TODO: Figure out what we should do in Blocking mode.\r\n                    var nextState = {\r\n                        baseLanes: NoLanes\r\n                    };\r\n                    workInProgress.memoizedState = nextState;\r\n                    pushRenderLanes(workInProgress, renderLanes);\r\n                }\r\n                else if (!includesSomeLane(renderLanes, OffscreenLane)) {\r\n                    var nextBaseLanes;\r\n                    if (prevState !== null) {\r\n                        var prevBaseLanes = prevState.baseLanes;\r\n                        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\r\n                    }\r\n                    else {\r\n                        nextBaseLanes = renderLanes;\r\n                    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\r\n                    {\r\n                        markSpawnedWork(OffscreenLane);\r\n                    }\r\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\r\n                    var _nextState = {\r\n                        baseLanes: nextBaseLanes\r\n                    };\r\n                    workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway\r\n                    // to avoid a push/pop misalignment.\r\n                    pushRenderLanes(workInProgress, nextBaseLanes);\r\n                    return null;\r\n                }\r\n                else {\r\n                    // Rendering at offscreen, so we can clear the base lanes.\r\n                    var _nextState2 = {\r\n                        baseLanes: NoLanes\r\n                    };\r\n                    workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\r\n                    var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\r\n                    pushRenderLanes(workInProgress, subtreeRenderLanes);\r\n                }\r\n            }\r\n            else {\r\n                var _subtreeRenderLanes;\r\n                if (prevState !== null) {\r\n                    _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state\r\n                    workInProgress.memoizedState = null;\r\n                }\r\n                else {\r\n                    // We weren't previously hidden, and we still aren't, so there's nothing\r\n                    // special to do. Need to push to the stack regardless, though, to avoid\r\n                    // a push/pop misalignment.\r\n                    _subtreeRenderLanes = renderLanes;\r\n                }\r\n                pushRenderLanes(workInProgress, _subtreeRenderLanes);\r\n            }\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        } // Note: These happen to have identical begin phases, for now. We shouldn't hold\r\n        // ourselves to this constraint, though. If the behavior diverges, we should\r\n        // fork the function.\r\n        var updateLegacyHiddenComponent = updateOffscreenComponent;\r\n        function updateFragment(current, workInProgress, renderLanes) {\r\n            var nextChildren = workInProgress.pendingProps;\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function updateMode(current, workInProgress, renderLanes) {\r\n            var nextChildren = workInProgress.pendingProps.children;\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function updateProfiler(current, workInProgress, renderLanes) {\r\n            {\r\n                workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.\r\n                // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n                var stateNode = workInProgress.stateNode;\r\n                stateNode.effectDuration = 0;\r\n                stateNode.passiveEffectDuration = 0;\r\n            }\r\n            var nextProps = workInProgress.pendingProps;\r\n            var nextChildren = nextProps.children;\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function markRef(current, workInProgress) {\r\n            var ref = workInProgress.ref;\r\n            if (current === null && ref !== null || current !== null && current.ref !== ref) {\r\n                // Schedule a Ref effect\r\n                workInProgress.flags |= Ref;\r\n            }\r\n        }\r\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\r\n            {\r\n                if (workInProgress.type !== workInProgress.elementType) {\r\n                    // Lazy component props can't be validated in createElement\r\n                    // because they're only guaranteed to be resolved here.\r\n                    var innerPropTypes = Component.propTypes;\r\n                    if (innerPropTypes) {\r\n                        checkPropTypes(innerPropTypes, nextProps, // Resolved props\r\n                        'prop', getComponentName(Component));\r\n                    }\r\n                }\r\n            }\r\n            var context;\r\n            {\r\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\r\n                context = getMaskedContext(workInProgress, unmaskedContext);\r\n            }\r\n            var nextChildren;\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            {\r\n                ReactCurrentOwner$1.current = workInProgress;\r\n                setIsRendering(true);\r\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\r\n                if (workInProgress.mode & StrictMode) {\r\n                    disableLogs();\r\n                    try {\r\n                        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\r\n                    }\r\n                    finally {\r\n                        reenableLogs();\r\n                    }\r\n                }\r\n                setIsRendering(false);\r\n            }\r\n            if (current !== null && !didReceiveUpdate) {\r\n                bailoutHooks(current, workInProgress, renderLanes);\r\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\r\n            {\r\n                if (workInProgress.type !== workInProgress.elementType) {\r\n                    // Lazy component props can't be validated in createElement\r\n                    // because they're only guaranteed to be resolved here.\r\n                    var innerPropTypes = Component.propTypes;\r\n                    if (innerPropTypes) {\r\n                        checkPropTypes(innerPropTypes, nextProps, // Resolved props\r\n                        'prop', getComponentName(Component));\r\n                    }\r\n                }\r\n            } // Push context providers early to prevent context stack mismatches.\r\n            // During mounting we don't know the child context yet as the instance doesn't exist.\r\n            // We will invalidate the child context in finishClassComponent() right after rendering.\r\n            var hasContext;\r\n            if (isContextProvider(Component)) {\r\n                hasContext = true;\r\n                pushContextProvider(workInProgress);\r\n            }\r\n            else {\r\n                hasContext = false;\r\n            }\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            var instance = workInProgress.stateNode;\r\n            var shouldUpdate;\r\n            if (instance === null) {\r\n                if (current !== null) {\r\n                    // A class component without an instance only mounts if it suspended\r\n                    // inside a non-concurrent tree, in an inconsistent state. We want to\r\n                    // treat it like a new mount, even though an empty version of it already\r\n                    // committed. Disconnect the alternate pointers.\r\n                    current.alternate = null;\r\n                    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\r\n                    workInProgress.flags |= Placement;\r\n                } // In the initial pass we might need to construct the instance.\r\n                constructClassInstance(workInProgress, Component, nextProps);\r\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n                shouldUpdate = true;\r\n            }\r\n            else if (current === null) {\r\n                // In a resume, we'll already have an instance we can reuse.\r\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n            }\r\n            else {\r\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\r\n            }\r\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\r\n            {\r\n                var inst = workInProgress.stateNode;\r\n                if (shouldUpdate && inst.props !== nextProps) {\r\n                    if (!didWarnAboutReassigningProps) {\r\n                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');\r\n                    }\r\n                    didWarnAboutReassigningProps = true;\r\n                }\r\n            }\r\n            return nextUnitOfWork;\r\n        }\r\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\r\n            // Refs should update even if shouldComponentUpdate returns false\r\n            markRef(current, workInProgress);\r\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\r\n            if (!shouldUpdate && !didCaptureError) {\r\n                // Context providers should defer to sCU for rendering\r\n                if (hasContext) {\r\n                    invalidateContextProvider(workInProgress, Component, false);\r\n                }\r\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n            }\r\n            var instance = workInProgress.stateNode; // Rerender\r\n            ReactCurrentOwner$1.current = workInProgress;\r\n            var nextChildren;\r\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\r\n                // If we captured an error, but getDerivedStateFromError is not defined,\r\n                // unmount all the children. componentDidCatch will schedule an update to\r\n                // re-render a fallback. This is temporary until we migrate everyone to\r\n                // the new API.\r\n                // TODO: Warn in a future release.\r\n                nextChildren = null;\r\n                {\r\n                    stopProfilerTimerIfRunning();\r\n                }\r\n            }\r\n            else {\r\n                {\r\n                    setIsRendering(true);\r\n                    nextChildren = instance.render();\r\n                    if (workInProgress.mode & StrictMode) {\r\n                        disableLogs();\r\n                        try {\r\n                            instance.render();\r\n                        }\r\n                        finally {\r\n                            reenableLogs();\r\n                        }\r\n                    }\r\n                    setIsRendering(false);\r\n                }\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            if (current !== null && didCaptureError) {\r\n                // If we're recovering from an error, reconcile without reusing any of\r\n                // the existing children. Conceptually, the normal children and the children\r\n                // that are shown on error are two different sets, so we shouldn't reuse\r\n                // normal children even if their identities match.\r\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\r\n            }\r\n            else {\r\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            } // Memoize state using the values we just used to render.\r\n            // TODO: Restructure so we never read values from the instance.\r\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\r\n            if (hasContext) {\r\n                invalidateContextProvider(workInProgress, Component, true);\r\n            }\r\n            return workInProgress.child;\r\n        }\r\n        function pushHostRootContext(workInProgress) {\r\n            var root = workInProgress.stateNode;\r\n            if (root.pendingContext) {\r\n                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\r\n            }\r\n            else if (root.context) {\r\n                // Should always be set\r\n                pushTopLevelContextObject(workInProgress, root.context, false);\r\n            }\r\n            pushHostContainer(workInProgress, root.containerInfo);\r\n        }\r\n        function updateHostRoot(current, workInProgress, renderLanes) {\r\n            pushHostRootContext(workInProgress);\r\n            var updateQueue = workInProgress.updateQueue;\r\n            if (!(current !== null && updateQueue !== null)) {\r\n                {\r\n                    throw Error(\"If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n            var nextProps = workInProgress.pendingProps;\r\n            var prevState = workInProgress.memoizedState;\r\n            var prevChildren = prevState !== null ? prevState.element : null;\r\n            cloneUpdateQueue(current, workInProgress);\r\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\r\n            var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property\r\n            // being called \"element\".\r\n            var nextChildren = nextState.element;\r\n            if (nextChildren === prevChildren) {\r\n                resetHydrationState();\r\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n            }\r\n            var root = workInProgress.stateNode;\r\n            if (root.hydrate && enterHydrationState(workInProgress)) {\r\n                // If we don't have any current children this might be the first pass.\r\n                // We always try to hydrate. If this isn't a hydration pass there won't\r\n                // be any children to hydrate which is effectively the same thing as\r\n                // not hydrating.\r\n                {\r\n                    var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;\r\n                    if (mutableSourceEagerHydrationData != null) {\r\n                        for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\r\n                            var mutableSource = mutableSourceEagerHydrationData[i];\r\n                            var version = mutableSourceEagerHydrationData[i + 1];\r\n                            setWorkInProgressVersion(mutableSource, version);\r\n                        }\r\n                    }\r\n                }\r\n                var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\r\n                workInProgress.child = child;\r\n                var node = child;\r\n                while (node) {\r\n                    // Mark each child as hydrating. This is a fast path to know whether this\r\n                    // tree is part of a hydrating tree. This is used to determine if a child\r\n                    // node has fully mounted yet, and for scheduling event replaying.\r\n                    // Conceptually this is similar to Placement in that a new subtree is\r\n                    // inserted into the React tree here. It just happens to not need DOM\r\n                    // mutations because it already exists.\r\n                    node.flags = node.flags & ~Placement | Hydrating;\r\n                    node = node.sibling;\r\n                }\r\n            }\r\n            else {\r\n                // Otherwise reset hydration state in case we aborted and resumed another\r\n                // root.\r\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n                resetHydrationState();\r\n            }\r\n            return workInProgress.child;\r\n        }\r\n        function updateHostComponent(current, workInProgress, renderLanes) {\r\n            pushHostContext(workInProgress);\r\n            if (current === null) {\r\n                tryToClaimNextHydratableInstance(workInProgress);\r\n            }\r\n            var type = workInProgress.type;\r\n            var nextProps = workInProgress.pendingProps;\r\n            var prevProps = current !== null ? current.memoizedProps : null;\r\n            var nextChildren = nextProps.children;\r\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\r\n            if (isDirectTextChild) {\r\n                // We special case a direct text child of a host node. This is a common\r\n                // case. We won't handle it as a reified child. We will instead handle\r\n                // this in the host environment that also has access to this prop. That\r\n                // avoids allocating another HostText fiber and traversing it.\r\n                nextChildren = null;\r\n            }\r\n            else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\r\n                // If we're switching from a direct text child to a normal child, or to\r\n                // empty, we need to schedule the text content to be reset.\r\n                workInProgress.flags |= ContentReset;\r\n            }\r\n            markRef(current, workInProgress);\r\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function updateHostText(current, workInProgress) {\r\n            if (current === null) {\r\n                tryToClaimNextHydratableInstance(workInProgress);\r\n            } // Nothing to do here. This is terminal. We'll do the completion step\r\n            // immediately after.\r\n            return null;\r\n        }\r\n        function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {\r\n            if (_current !== null) {\r\n                // A lazy component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\r\n                workInProgress.flags |= Placement;\r\n            }\r\n            var props = workInProgress.pendingProps;\r\n            var lazyComponent = elementType;\r\n            var payload = lazyComponent._payload;\r\n            var init = lazyComponent._init;\r\n            var Component = init(payload); // Store the unwrapped component in the type.\r\n            workInProgress.type = Component;\r\n            var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\r\n            var resolvedProps = resolveDefaultProps(Component, props);\r\n            var child;\r\n            switch (resolvedTag) {\r\n                case FunctionComponent:\r\n                    {\r\n                        {\r\n                            validateFunctionComponentInDev(workInProgress, Component);\r\n                            workInProgress.type = Component = resolveFunctionForHotReloading(Component);\r\n                        }\r\n                        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\r\n                        return child;\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        {\r\n                            workInProgress.type = Component = resolveClassForHotReloading(Component);\r\n                        }\r\n                        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\r\n                        return child;\r\n                    }\r\n                case ForwardRef:\r\n                    {\r\n                        {\r\n                            workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\r\n                        }\r\n                        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\r\n                        return child;\r\n                    }\r\n                case MemoComponent:\r\n                    {\r\n                        {\r\n                            if (workInProgress.type !== workInProgress.elementType) {\r\n                                var outerPropTypes = Component.propTypes;\r\n                                if (outerPropTypes) {\r\n                                    checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\r\n                                    'prop', getComponentName(Component));\r\n                                }\r\n                            }\r\n                        }\r\n                        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\r\n                        updateLanes, renderLanes);\r\n                        return child;\r\n                    }\r\n            }\r\n            var hint = '';\r\n            {\r\n                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\r\n                    hint = ' Did you wrap a component in React.lazy() more than once?';\r\n                }\r\n            } // This message intentionally doesn't mention ForwardRef or MemoComponent\r\n            // because the fact that it's a separate type of work is an\r\n            // implementation detail.\r\n            {\r\n                {\r\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". Lazy element type must resolve to a class or function.\" + hint);\r\n                }\r\n            }\r\n        }\r\n        function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\r\n            if (_current !== null) {\r\n                // An incomplete component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\r\n                workInProgress.flags |= Placement;\r\n            } // Promote the fiber to a class and try rendering again.\r\n            workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\r\n            // Push context providers early to prevent context stack mismatches.\r\n            // During mounting we don't know the child context yet as the instance doesn't exist.\r\n            // We will invalidate the child context in finishClassComponent() right after rendering.\r\n            var hasContext;\r\n            if (isContextProvider(Component)) {\r\n                hasContext = true;\r\n                pushContextProvider(workInProgress);\r\n            }\r\n            else {\r\n                hasContext = false;\r\n            }\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            constructClassInstance(workInProgress, Component, nextProps);\r\n            mountClassInstance(workInProgress, Component, nextProps, renderLanes);\r\n            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\r\n        }\r\n        function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\r\n            if (_current !== null) {\r\n                // An indeterminate component only mounts if it suspended inside a non-\r\n                // concurrent tree, in an inconsistent state. We want to treat it like\r\n                // a new mount, even though an empty version of it already committed.\r\n                // Disconnect the alternate pointers.\r\n                _current.alternate = null;\r\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\r\n                workInProgress.flags |= Placement;\r\n            }\r\n            var props = workInProgress.pendingProps;\r\n            var context;\r\n            {\r\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\r\n                context = getMaskedContext(workInProgress, unmaskedContext);\r\n            }\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            var value;\r\n            {\r\n                if (Component.prototype && typeof Component.prototype.render === 'function') {\r\n                    var componentName = getComponentName(Component) || 'Unknown';\r\n                    if (!didWarnAboutBadClass[componentName]) {\r\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\r\n                        didWarnAboutBadClass[componentName] = true;\r\n                    }\r\n                }\r\n                if (workInProgress.mode & StrictMode) {\r\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\r\n                }\r\n                setIsRendering(true);\r\n                ReactCurrentOwner$1.current = workInProgress;\r\n                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\r\n                setIsRendering(false);\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            {\r\n                // Support for module components is deprecated and is removed behind a flag.\r\n                // Whether or not it would crash later, we want to show a good message in DEV first.\r\n                if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\r\n                    var _componentName = getComponentName(Component) || 'Unknown';\r\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\r\n                        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);\r\n                        didWarnAboutModulePatternComponent[_componentName] = true;\r\n                    }\r\n                }\r\n            }\r\n            if ( // Run these checks in production only if the flag is off.\r\n            // Eventually we'll delete this branch altogether.\r\n            typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\r\n                {\r\n                    var _componentName2 = getComponentName(Component) || 'Unknown';\r\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\r\n                        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);\r\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\r\n                    }\r\n                } // Proceed under the assumption that this is a class instance\r\n                workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\r\n                workInProgress.memoizedState = null;\r\n                workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\r\n                // During mounting we don't know the child context yet as the instance doesn't exist.\r\n                // We will invalidate the child context in finishClassComponent() right after rendering.\r\n                var hasContext = false;\r\n                if (isContextProvider(Component)) {\r\n                    hasContext = true;\r\n                    pushContextProvider(workInProgress);\r\n                }\r\n                else {\r\n                    hasContext = false;\r\n                }\r\n                workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\r\n                initializeUpdateQueue(workInProgress);\r\n                var getDerivedStateFromProps = Component.getDerivedStateFromProps;\r\n                if (typeof getDerivedStateFromProps === 'function') {\r\n                    applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\r\n                }\r\n                adoptClassInstance(workInProgress, value);\r\n                mountClassInstance(workInProgress, Component, props, renderLanes);\r\n                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\r\n            }\r\n            else {\r\n                // Proceed under the assumption that this is a function component\r\n                workInProgress.tag = FunctionComponent;\r\n                {\r\n                    if (workInProgress.mode & StrictMode) {\r\n                        disableLogs();\r\n                        try {\r\n                            value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\r\n                        }\r\n                        finally {\r\n                            reenableLogs();\r\n                        }\r\n                    }\r\n                }\r\n                reconcileChildren(null, workInProgress, value, renderLanes);\r\n                {\r\n                    validateFunctionComponentInDev(workInProgress, Component);\r\n                }\r\n                return workInProgress.child;\r\n            }\r\n        }\r\n        function validateFunctionComponentInDev(workInProgress, Component) {\r\n            {\r\n                if (Component) {\r\n                    if (Component.childContextTypes) {\r\n                        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\r\n                    }\r\n                }\r\n                if (workInProgress.ref !== null) {\r\n                    var info = '';\r\n                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();\r\n                    if (ownerName) {\r\n                        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\r\n                    }\r\n                    var warningKey = ownerName || workInProgress._debugID || '';\r\n                    var debugSource = workInProgress._debugSource;\r\n                    if (debugSource) {\r\n                        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\r\n                    }\r\n                    if (!didWarnAboutFunctionRefs[warningKey]) {\r\n                        didWarnAboutFunctionRefs[warningKey] = true;\r\n                        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\r\n                    }\r\n                }\r\n                if (typeof Component.getDerivedStateFromProps === 'function') {\r\n                    var _componentName3 = getComponentName(Component) || 'Unknown';\r\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\r\n                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);\r\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\r\n                    }\r\n                }\r\n                if (typeof Component.contextType === 'object' && Component.contextType !== null) {\r\n                    var _componentName4 = getComponentName(Component) || 'Unknown';\r\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\r\n                        error('%s: Function components do not support contextType.', _componentName4);\r\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var SUSPENDED_MARKER = {\r\n            dehydrated: null,\r\n            retryLane: NoLane\r\n        };\r\n        function mountSuspenseOffscreenState(renderLanes) {\r\n            return {\r\n                baseLanes: renderLanes\r\n            };\r\n        }\r\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\r\n            return {\r\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)\r\n            };\r\n        } // TODO: Probably should inline this back\r\n        function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\r\n            // If we're already showing a fallback, there are cases where we need to\r\n            // remain on that fallback regardless of whether the content has resolved.\r\n            // For example, SuspenseList coordinates when nested content appears.\r\n            if (current !== null) {\r\n                var suspenseState = current.memoizedState;\r\n                if (suspenseState === null) {\r\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallack\r\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\r\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\r\n                    // no fallback to remain on.\r\n                    return false;\r\n                }\r\n            } // Not currently showing content. Consult the Suspense context.\r\n            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\r\n        }\r\n        function getRemainingWorkInPrimaryTree(current, renderLanes) {\r\n            // TODO: Should not remove render lanes that were pinged during this render\r\n            return removeLanes(current.childLanes, renderLanes);\r\n        }\r\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\r\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\r\n            {\r\n                if (shouldSuspend(workInProgress)) {\r\n                    workInProgress.flags |= DidCapture;\r\n                }\r\n            }\r\n            var suspenseContext = suspenseStackCursor.current;\r\n            var showFallback = false;\r\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\r\n            if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\r\n                // Something in this boundary's subtree already suspended. Switch to\r\n                // rendering the fallback children.\r\n                showFallback = true;\r\n                workInProgress.flags &= ~DidCapture;\r\n            }\r\n            else {\r\n                // Attempting the main content\r\n                if (current === null || current.memoizedState !== null) {\r\n                    // This is a new mount or this boundary is already showing a fallback state.\r\n                    // Mark this subtree context as having at least one invisible parent that could\r\n                    // handle the fallback state.\r\n                    // Boundaries without fallbacks or should be avoided are not considered since\r\n                    // they cannot handle preferred fallback states.\r\n                    if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {\r\n                        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\r\n                    }\r\n                }\r\n            }\r\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n            pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\r\n            // boundary's children. This involves some custom reconcilation logic. Two\r\n            // main reasons this is so complicated.\r\n            //\r\n            // First, Legacy Mode has different semantics for backwards compatibility. The\r\n            // primary tree will commit in an inconsistent state, so when we do the\r\n            // second pass to render the fallback, we do some exceedingly, uh, clever\r\n            // hacks to make that not totally break. Like transferring effects and\r\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\r\n            // because we bailout on the primary tree completely and leave it in its old\r\n            // state, no effects. Same as what we do for Offscreen (except that\r\n            // Offscreen doesn't have the first render pass).\r\n            //\r\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\r\n            // different layout, where the child points to a dehydrated fragment, which\r\n            // contains the DOM rendered by the server.\r\n            //\r\n            // Third, even if you set all that aside, Suspense is like error boundaries in\r\n            // that we first we try to render one tree, and if that fails, we render again\r\n            // and switch to a different tree. Like a try/catch block. So we have to track\r\n            // which branch we're currently rendering. Ideally we would model this using\r\n            // a stack.\r\n            if (current === null) {\r\n                // Initial mount\r\n                // If we're currently hydrating, try to hydrate this boundary.\r\n                // But only if this has a fallback.\r\n                if (nextProps.fallback !== undefined) {\r\n                    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\r\n                }\r\n                var nextPrimaryChildren = nextProps.children;\r\n                var nextFallbackChildren = nextProps.fallback;\r\n                if (showFallback) {\r\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\r\n                    var primaryChildFragment = workInProgress.child;\r\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\r\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\r\n                    return fallbackFragment;\r\n                }\r\n                else if (typeof nextProps.unstable_expectedLoadTime === 'number') {\r\n                    // This is a CPU-bound tree. Skip this tree and show a placeholder to\r\n                    // unblock the surrounding content. Then immediately retry after the\r\n                    // initial commit.\r\n                    var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\r\n                    var _primaryChildFragment = workInProgress.child;\r\n                    _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\r\n                    workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to\r\n                    // get it started back up to attempt the next item. While in terms of\r\n                    // priority this work has the same priority as this current render, it's\r\n                    // not part of the same transition once the transition has committed. If\r\n                    // it's sync, we still want to yield so that it can be painted.\r\n                    // Conceptually, this is really the same as pinging. We can use any\r\n                    // RetryLane even if it's the one currently rendering since we're leaving\r\n                    // it behind on this node.\r\n                    workInProgress.lanes = SomeRetryLane;\r\n                    {\r\n                        markSpawnedWork(SomeRetryLane);\r\n                    }\r\n                    return _fallbackFragment;\r\n                }\r\n                else {\r\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);\r\n                }\r\n            }\r\n            else {\r\n                // This is an update.\r\n                // If the current fiber has a SuspenseState, that means it's already showing\r\n                // a fallback.\r\n                var prevState = current.memoizedState;\r\n                if (prevState !== null) {\r\n                    if (showFallback) {\r\n                        var _nextFallbackChildren2 = nextProps.fallback;\r\n                        var _nextPrimaryChildren2 = nextProps.children;\r\n                        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);\r\n                        var _primaryChildFragment3 = workInProgress.child;\r\n                        var prevOffscreenState = current.child.memoizedState;\r\n                        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\r\n                        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\r\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\r\n                        return _fallbackChildFragment;\r\n                    }\r\n                    else {\r\n                        var _nextPrimaryChildren3 = nextProps.children;\r\n                        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);\r\n                        workInProgress.memoizedState = null;\r\n                        return _primaryChildFragment4;\r\n                    }\r\n                }\r\n                else {\r\n                    // The current tree is not already showing a fallback.\r\n                    if (showFallback) {\r\n                        // Timed out.\r\n                        var _nextFallbackChildren3 = nextProps.fallback;\r\n                        var _nextPrimaryChildren4 = nextProps.children;\r\n                        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);\r\n                        var _primaryChildFragment5 = workInProgress.child;\r\n                        var _prevOffscreenState = current.child.memoizedState;\r\n                        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);\r\n                        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\r\n                        // fallback children.\r\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\r\n                        return _fallbackChildFragment2;\r\n                    }\r\n                    else {\r\n                        // Still haven't timed out. Continue rendering the children, like we\r\n                        // normally do.\r\n                        var _nextPrimaryChildren5 = nextProps.children;\r\n                        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);\r\n                        workInProgress.memoizedState = null;\r\n                        return _primaryChildFragment6;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\r\n            var mode = workInProgress.mode;\r\n            var primaryChildProps = {\r\n                mode: 'visible',\r\n                children: primaryChildren\r\n            };\r\n            var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);\r\n            primaryChildFragment.return = workInProgress;\r\n            workInProgress.child = primaryChildFragment;\r\n            return primaryChildFragment;\r\n        }\r\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\r\n            var mode = workInProgress.mode;\r\n            var progressedPrimaryFragment = workInProgress.child;\r\n            var primaryChildProps = {\r\n                mode: 'hidden',\r\n                children: primaryChildren\r\n            };\r\n            var primaryChildFragment;\r\n            var fallbackChildFragment;\r\n            if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {\r\n                // In legacy mode, we commit the primary tree as if it successfully\r\n                // completed, even though it's in an inconsistent state.\r\n                primaryChildFragment = progressedPrimaryFragment;\r\n                primaryChildFragment.childLanes = NoLanes;\r\n                primaryChildFragment.pendingProps = primaryChildProps;\r\n                if (workInProgress.mode & ProfileMode) {\r\n                    // Reset the durations from the first pass so they aren't included in the\r\n                    // final amounts. This seems counterintuitive, since we're intentionally\r\n                    // not measuring part of the render phase, but this makes it match what we\r\n                    // do in Concurrent Mode.\r\n                    primaryChildFragment.actualDuration = 0;\r\n                    primaryChildFragment.actualStartTime = -1;\r\n                    primaryChildFragment.selfBaseDuration = 0;\r\n                    primaryChildFragment.treeBaseDuration = 0;\r\n                }\r\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\r\n            }\r\n            else {\r\n                primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);\r\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\r\n            }\r\n            primaryChildFragment.return = workInProgress;\r\n            fallbackChildFragment.return = workInProgress;\r\n            primaryChildFragment.sibling = fallbackChildFragment;\r\n            workInProgress.child = primaryChildFragment;\r\n            return fallbackChildFragment;\r\n        }\r\n        function createWorkInProgressOffscreenFiber(current, offscreenProps) {\r\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\r\n            // wrapper function to constrain it.\r\n            return createWorkInProgress(current, offscreenProps);\r\n        }\r\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\r\n            var currentPrimaryChildFragment = current.child;\r\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\r\n            var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\r\n                mode: 'visible',\r\n                children: primaryChildren\r\n            });\r\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n                primaryChildFragment.lanes = renderLanes;\r\n            }\r\n            primaryChildFragment.return = workInProgress;\r\n            primaryChildFragment.sibling = null;\r\n            if (currentFallbackChildFragment !== null) {\r\n                // Delete the fallback child fragment\r\n                currentFallbackChildFragment.nextEffect = null;\r\n                currentFallbackChildFragment.flags = Deletion;\r\n                workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;\r\n            }\r\n            workInProgress.child = primaryChildFragment;\r\n            return primaryChildFragment;\r\n        }\r\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\r\n            var mode = workInProgress.mode;\r\n            var currentPrimaryChildFragment = current.child;\r\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\r\n            var primaryChildProps = {\r\n                mode: 'hidden',\r\n                children: primaryChildren\r\n            };\r\n            var primaryChildFragment;\r\n            if ( // In legacy mode, we commit the primary tree as if it successfully\r\n            // completed, even though it's in an inconsistent state.\r\n            (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\r\n                // already cloned. In legacy mode, the only case where this isn't true is\r\n                // when DevTools forces us to display a fallback; we skip the first render\r\n                // pass entirely and go straight to rendering the fallback. (In Concurrent\r\n                // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\r\n                // only codepath.)\r\n                workInProgress.child !== currentPrimaryChildFragment) {\r\n                var progressedPrimaryFragment = workInProgress.child;\r\n                primaryChildFragment = progressedPrimaryFragment;\r\n                primaryChildFragment.childLanes = NoLanes;\r\n                primaryChildFragment.pendingProps = primaryChildProps;\r\n                if (workInProgress.mode & ProfileMode) {\r\n                    // Reset the durations from the first pass so they aren't included in the\r\n                    // final amounts. This seems counterintuitive, since we're intentionally\r\n                    // not measuring part of the render phase, but this makes it match what we\r\n                    // do in Concurrent Mode.\r\n                    primaryChildFragment.actualDuration = 0;\r\n                    primaryChildFragment.actualStartTime = -1;\r\n                    primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\r\n                    primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\r\n                } // The fallback fiber was added as a deletion effect during the first pass.\r\n                // However, since we're going to remain on the fallback, we no longer want\r\n                // to delete it. So we need to remove it from the list. Deletions are stored\r\n                // on the same list as effects. We want to keep the effects from the primary\r\n                // tree. So we copy the primary child fragment's effect list, which does not\r\n                // include the fallback deletion effect.\r\n                var progressedLastEffect = primaryChildFragment.lastEffect;\r\n                if (progressedLastEffect !== null) {\r\n                    workInProgress.firstEffect = primaryChildFragment.firstEffect;\r\n                    workInProgress.lastEffect = progressedLastEffect;\r\n                    progressedLastEffect.nextEffect = null;\r\n                }\r\n                else {\r\n                    // TODO: Reset this somewhere else? Lol legacy mode is so weird.\r\n                    workInProgress.firstEffect = workInProgress.lastEffect = null;\r\n                }\r\n            }\r\n            else {\r\n                primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\r\n            }\r\n            var fallbackChildFragment;\r\n            if (currentFallbackChildFragment !== null) {\r\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\r\n            }\r\n            else {\r\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\r\n                // mounted but this is a new fiber.\r\n                fallbackChildFragment.flags |= Placement;\r\n            }\r\n            fallbackChildFragment.return = workInProgress;\r\n            primaryChildFragment.return = workInProgress;\r\n            primaryChildFragment.sibling = fallbackChildFragment;\r\n            workInProgress.child = primaryChildFragment;\r\n            return fallbackChildFragment;\r\n        }\r\n        function scheduleWorkOnFiber(fiber, renderLanes) {\r\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\r\n            var alternate = fiber.alternate;\r\n            if (alternate !== null) {\r\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\r\n            }\r\n            scheduleWorkOnParentPath(fiber.return, renderLanes);\r\n        }\r\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\r\n            // Mark any Suspense boundaries with fallbacks as having work to do.\r\n            // If they were previously forced into fallbacks, they may now be able\r\n            // to unblock.\r\n            var node = firstChild;\r\n            while (node !== null) {\r\n                if (node.tag === SuspenseComponent) {\r\n                    var state = node.memoizedState;\r\n                    if (state !== null) {\r\n                        scheduleWorkOnFiber(node, renderLanes);\r\n                    }\r\n                }\r\n                else if (node.tag === SuspenseListComponent) {\r\n                    // If the tail is hidden there might not be an Suspense boundaries\r\n                    // to schedule work on. In this case we have to schedule it on the\r\n                    // list itself.\r\n                    // We don't have to traverse to the children of the list since\r\n                    // the list will propagate the change when it rerenders.\r\n                    scheduleWorkOnFiber(node, renderLanes);\r\n                }\r\n                else if (node.child !== null) {\r\n                    node.child.return = node;\r\n                    node = node.child;\r\n                    continue;\r\n                }\r\n                if (node === workInProgress) {\r\n                    return;\r\n                }\r\n                while (node.sibling === null) {\r\n                    if (node.return === null || node.return === workInProgress) {\r\n                        return;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            }\r\n        }\r\n        function findLastContentRow(firstChild) {\r\n            // This is going to find the last row among these children that is already\r\n            // showing content on the screen, as opposed to being in fallback state or\r\n            // new. If a row has multiple Suspense boundaries, any of them being in the\r\n            // fallback state, counts as the whole row being in a fallback state.\r\n            // Note that the \"rows\" will be workInProgress, but any nested children\r\n            // will still be current since we haven't rendered them yet. The mounted\r\n            // order may not be the same as the new order. We use the new order.\r\n            var row = firstChild;\r\n            var lastContentRow = null;\r\n            while (row !== null) {\r\n                var currentRow = row.alternate; // New rows can't be content rows.\r\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n                    lastContentRow = row;\r\n                }\r\n                row = row.sibling;\r\n            }\r\n            return lastContentRow;\r\n        }\r\n        function validateRevealOrder(revealOrder) {\r\n            {\r\n                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\r\n                    didWarnAboutRevealOrder[revealOrder] = true;\r\n                    if (typeof revealOrder === 'string') {\r\n                        switch (revealOrder.toLowerCase()) {\r\n                            case 'together':\r\n                            case 'forwards':\r\n                            case 'backwards':\r\n                                {\r\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\r\n                                    break;\r\n                                }\r\n                            case 'forward':\r\n                            case 'backward':\r\n                                {\r\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\r\n                                    break;\r\n                                }\r\n                            default:\r\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\r\n                                break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function validateTailOptions(tailMode, revealOrder) {\r\n            {\r\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\r\n                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\r\n                        didWarnAboutTailOptions[tailMode] = true;\r\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\r\n                    }\r\n                    else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\r\n                        didWarnAboutTailOptions[tailMode] = true;\r\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function validateSuspenseListNestedChild(childSlot, index) {\r\n            {\r\n                var isArray = Array.isArray(childSlot);\r\n                var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';\r\n                if (isArray || isIterable) {\r\n                    var type = isArray ? 'array' : 'iterable';\r\n                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        function validateSuspenseListChildren(children, revealOrder) {\r\n            {\r\n                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\r\n                    if (Array.isArray(children)) {\r\n                        for (var i = 0; i < children.length; i++) {\r\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        var iteratorFn = getIteratorFn(children);\r\n                        if (typeof iteratorFn === 'function') {\r\n                            var childrenIterator = iteratorFn.call(children);\r\n                            if (childrenIterator) {\r\n                                var step = childrenIterator.next();\r\n                                var _i = 0;\r\n                                for (; !step.done; step = childrenIterator.next()) {\r\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\r\n                                        return;\r\n                                    }\r\n                                    _i++;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {\r\n            var renderState = workInProgress.memoizedState;\r\n            if (renderState === null) {\r\n                workInProgress.memoizedState = {\r\n                    isBackwards: isBackwards,\r\n                    rendering: null,\r\n                    renderingStartTime: 0,\r\n                    last: lastContentRow,\r\n                    tail: tail,\r\n                    tailMode: tailMode,\r\n                    lastEffect: lastEffectBeforeRendering\r\n                };\r\n            }\r\n            else {\r\n                // We can reuse the existing object from previous renders.\r\n                renderState.isBackwards = isBackwards;\r\n                renderState.rendering = null;\r\n                renderState.renderingStartTime = 0;\r\n                renderState.last = lastContentRow;\r\n                renderState.tail = tail;\r\n                renderState.tailMode = tailMode;\r\n                renderState.lastEffect = lastEffectBeforeRendering;\r\n            }\r\n        } // This can end up rendering this component multiple passes.\r\n        // The first pass splits the children fibers into two sets. A head and tail.\r\n        // We first render the head. If anything is in fallback state, we do another\r\n        // pass through beginWork to rerender all children (including the tail) with\r\n        // the force suspend context. If the first render didn't have anything in\r\n        // in fallback state. Then we render each row in the tail one-by-one.\r\n        // That happens in the completeWork phase without going back to beginWork.\r\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\r\n            var nextProps = workInProgress.pendingProps;\r\n            var revealOrder = nextProps.revealOrder;\r\n            var tailMode = nextProps.tail;\r\n            var newChildren = nextProps.children;\r\n            validateRevealOrder(revealOrder);\r\n            validateTailOptions(tailMode, revealOrder);\r\n            validateSuspenseListChildren(newChildren, revealOrder);\r\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n            var suspenseContext = suspenseStackCursor.current;\r\n            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\r\n            if (shouldForceFallback) {\r\n                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\r\n                workInProgress.flags |= DidCapture;\r\n            }\r\n            else {\r\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\r\n                if (didSuspendBefore) {\r\n                    // If we previously forced a fallback, we need to schedule work\r\n                    // on any nested boundaries to let them know to try to render\r\n                    // again. This is the same as context updating.\r\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\r\n                }\r\n                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n            }\r\n            pushSuspenseContext(workInProgress, suspenseContext);\r\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\r\n                // In legacy mode, SuspenseList doesn't work so we just\r\n                // use make it a noop by treating it as the default revealOrder.\r\n                workInProgress.memoizedState = null;\r\n            }\r\n            else {\r\n                switch (revealOrder) {\r\n                    case 'forwards':\r\n                        {\r\n                            var lastContentRow = findLastContentRow(workInProgress.child);\r\n                            var tail;\r\n                            if (lastContentRow === null) {\r\n                                // The whole list is part of the tail.\r\n                                // TODO: We could fast path by just rendering the tail now.\r\n                                tail = workInProgress.child;\r\n                                workInProgress.child = null;\r\n                            }\r\n                            else {\r\n                                // Disconnect the tail rows after the content row.\r\n                                // We're going to render them separately later.\r\n                                tail = lastContentRow.sibling;\r\n                                lastContentRow.sibling = null;\r\n                            }\r\n                            initSuspenseListRenderState(workInProgress, false, // isBackwards\r\n                            tail, lastContentRow, tailMode, workInProgress.lastEffect);\r\n                            break;\r\n                        }\r\n                    case 'backwards':\r\n                        {\r\n                            // We're going to find the first row that has existing content.\r\n                            // At the same time we're going to reverse the list of everything\r\n                            // we pass in the meantime. That's going to be our tail in reverse\r\n                            // order.\r\n                            var _tail = null;\r\n                            var row = workInProgress.child;\r\n                            workInProgress.child = null;\r\n                            while (row !== null) {\r\n                                var currentRow = row.alternate; // New rows can't be content rows.\r\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\r\n                                    // This is the beginning of the main content.\r\n                                    workInProgress.child = row;\r\n                                    break;\r\n                                }\r\n                                var nextRow = row.sibling;\r\n                                row.sibling = _tail;\r\n                                _tail = row;\r\n                                row = nextRow;\r\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\r\n                            initSuspenseListRenderState(workInProgress, true, // isBackwards\r\n                            _tail, null, // last\r\n                            tailMode, workInProgress.lastEffect);\r\n                            break;\r\n                        }\r\n                    case 'together':\r\n                        {\r\n                            initSuspenseListRenderState(workInProgress, false, // isBackwards\r\n                            null, // tail\r\n                            null, // last\r\n                            undefined, workInProgress.lastEffect);\r\n                            break;\r\n                        }\r\n                    default:\r\n                        {\r\n                            // The default reveal order is the same as not having\r\n                            // a boundary.\r\n                            workInProgress.memoizedState = null;\r\n                        }\r\n                }\r\n            }\r\n            return workInProgress.child;\r\n        }\r\n        function updatePortalComponent(current, workInProgress, renderLanes) {\r\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\r\n            var nextChildren = workInProgress.pendingProps;\r\n            if (current === null) {\r\n                // Portals are special because we don't append the children during mount\r\n                // but at commit. Therefore we need to track insertions which the normal\r\n                // flow doesn't do during mount. This doesn't happen at the root because\r\n                // the root always starts with a \"current\" with a null child.\r\n                // TODO: Consider unifying this with how the root works.\r\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\r\n            }\r\n            else {\r\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\r\n            }\r\n            return workInProgress.child;\r\n        }\r\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\r\n        function updateContextProvider(current, workInProgress, renderLanes) {\r\n            var providerType = workInProgress.type;\r\n            var context = providerType._context;\r\n            var newProps = workInProgress.pendingProps;\r\n            var oldProps = workInProgress.memoizedProps;\r\n            var newValue = newProps.value;\r\n            {\r\n                if (!('value' in newProps)) {\r\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\r\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\r\n                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\r\n                    }\r\n                }\r\n                var providerPropTypes = workInProgress.type.propTypes;\r\n                if (providerPropTypes) {\r\n                    checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\r\n                }\r\n            }\r\n            pushProvider(workInProgress, newValue);\r\n            if (oldProps !== null) {\r\n                var oldValue = oldProps.value;\r\n                var changedBits = calculateChangedBits(context, newValue, oldValue);\r\n                if (changedBits === 0) {\r\n                    // No change. Bailout early if children are the same.\r\n                    if (oldProps.children === newProps.children && !hasContextChanged()) {\r\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n                    }\r\n                }\r\n                else {\r\n                    // The context value changed. Search for matching consumers and schedule\r\n                    // them to update.\r\n                    propagateContextChange(workInProgress, context, changedBits, renderLanes);\r\n                }\r\n            }\r\n            var newChildren = newProps.children;\r\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        var hasWarnedAboutUsingContextAsConsumer = false;\r\n        function updateContextConsumer(current, workInProgress, renderLanes) {\r\n            var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\r\n            // DEV mode, we create a separate object for Context.Consumer that acts\r\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\r\n            // so we use the old behaviour (Context.Consumer references Context) to\r\n            // reduce size and overhead. The separate object references context via\r\n            // a property called \"_context\", which also gives us the ability to check\r\n            // in DEV mode if this property exists or not and warn if it does not.\r\n            {\r\n                if (context._context === undefined) {\r\n                    // This may be because it's a Context (rather than a Consumer).\r\n                    // Or it may be because it's older React where they're the same thing.\r\n                    // We only want to warn if we're sure it's a new React.\r\n                    if (context !== context.Consumer) {\r\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\r\n                            hasWarnedAboutUsingContextAsConsumer = true;\r\n                            error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    context = context._context;\r\n                }\r\n            }\r\n            var newProps = workInProgress.pendingProps;\r\n            var render = newProps.children;\r\n            {\r\n                if (typeof render !== 'function') {\r\n                    error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\r\n                }\r\n            }\r\n            prepareToReadContext(workInProgress, renderLanes);\r\n            var newValue = readContext(context, newProps.unstable_observedBits);\r\n            var newChildren;\r\n            {\r\n                ReactCurrentOwner$1.current = workInProgress;\r\n                setIsRendering(true);\r\n                newChildren = render(newValue);\r\n                setIsRendering(false);\r\n            } // React DevTools reads this flag.\r\n            workInProgress.flags |= PerformedWork;\r\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\r\n            return workInProgress.child;\r\n        }\r\n        function markWorkInProgressReceivedUpdate() {\r\n            didReceiveUpdate = true;\r\n        }\r\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\r\n            if (current !== null) {\r\n                // Reuse previous dependencies\r\n                workInProgress.dependencies = current.dependencies;\r\n            }\r\n            {\r\n                // Don't update \"base\" render times for bailouts.\r\n                stopProfilerTimerIfRunning();\r\n            }\r\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\r\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\r\n                // The children don't have any work either. We can skip them.\r\n                // TODO: Once we add back resuming, we should check if the children are\r\n                // a work-in-progress set. If so, we need to transfer their effects.\r\n                return null;\r\n            }\r\n            else {\r\n                // This fiber doesn't have work, but its subtree does. Clone the child\r\n                // fibers and continue.\r\n                cloneChildFibers(current, workInProgress);\r\n                return workInProgress.child;\r\n            }\r\n        }\r\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\r\n            {\r\n                var returnFiber = oldWorkInProgress.return;\r\n                if (returnFiber === null) {\r\n                    throw new Error('Cannot swap the root fiber.');\r\n                } // Disconnect from the old current.\r\n                // It will get deleted.\r\n                current.alternate = null;\r\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\r\n                newWorkInProgress.index = oldWorkInProgress.index;\r\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\r\n                newWorkInProgress.return = oldWorkInProgress.return;\r\n                newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\r\n                if (oldWorkInProgress === returnFiber.child) {\r\n                    returnFiber.child = newWorkInProgress;\r\n                }\r\n                else {\r\n                    var prevSibling = returnFiber.child;\r\n                    if (prevSibling === null) {\r\n                        throw new Error('Expected parent to have a child.');\r\n                    }\r\n                    while (prevSibling.sibling !== oldWorkInProgress) {\r\n                        prevSibling = prevSibling.sibling;\r\n                        if (prevSibling === null) {\r\n                            throw new Error('Expected to find the previous sibling.');\r\n                        }\r\n                    }\r\n                    prevSibling.sibling = newWorkInProgress;\r\n                } // Delete the old fiber and place the new one.\r\n                // Since the old fiber is disconnected, we have to schedule it manually.\r\n                var last = returnFiber.lastEffect;\r\n                if (last !== null) {\r\n                    last.nextEffect = current;\r\n                    returnFiber.lastEffect = current;\r\n                }\r\n                else {\r\n                    returnFiber.firstEffect = returnFiber.lastEffect = current;\r\n                }\r\n                current.nextEffect = null;\r\n                current.flags = Deletion;\r\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\r\n                return newWorkInProgress;\r\n            }\r\n        }\r\n        function beginWork(current, workInProgress, renderLanes) {\r\n            var updateLanes = workInProgress.lanes;\r\n            {\r\n                if (workInProgress._debugNeedsRemount && current !== null) {\r\n                    // This will restart the begin phase with a new fiber.\r\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\r\n                }\r\n            }\r\n            if (current !== null) {\r\n                var oldProps = current.memoizedProps;\r\n                var newProps = workInProgress.pendingProps;\r\n                if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\r\n                workInProgress.type !== current.type)) {\r\n                    // If props or context changed, mark the fiber as having performed work.\r\n                    // This may be unset if the props are determined to be equal later (memo).\r\n                    didReceiveUpdate = true;\r\n                }\r\n                else if (!includesSomeLane(renderLanes, updateLanes)) {\r\n                    didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering\r\n                    // the begin phase. There's still some bookkeeping we that needs to be done\r\n                    // in this optimized path, mostly pushing stuff onto the stack.\r\n                    switch (workInProgress.tag) {\r\n                        case HostRoot:\r\n                            pushHostRootContext(workInProgress);\r\n                            resetHydrationState();\r\n                            break;\r\n                        case HostComponent:\r\n                            pushHostContext(workInProgress);\r\n                            break;\r\n                        case ClassComponent:\r\n                            {\r\n                                var Component = workInProgress.type;\r\n                                if (isContextProvider(Component)) {\r\n                                    pushContextProvider(workInProgress);\r\n                                }\r\n                                break;\r\n                            }\r\n                        case HostPortal:\r\n                            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\r\n                            break;\r\n                        case ContextProvider:\r\n                            {\r\n                                var newValue = workInProgress.memoizedProps.value;\r\n                                pushProvider(workInProgress, newValue);\r\n                                break;\r\n                            }\r\n                        case Profiler:\r\n                            {\r\n                                // Profiler should only call onRender when one of its descendants actually rendered.\r\n                                var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\r\n                                if (hasChildWork) {\r\n                                    workInProgress.flags |= Update;\r\n                                } // Reset effect durations for the next eventual effect phase.\r\n                                // These are reset during render to allow the DevTools commit hook a chance to read them,\r\n                                var stateNode = workInProgress.stateNode;\r\n                                stateNode.effectDuration = 0;\r\n                                stateNode.passiveEffectDuration = 0;\r\n                            }\r\n                            break;\r\n                        case SuspenseComponent:\r\n                            {\r\n                                var state = workInProgress.memoizedState;\r\n                                if (state !== null) {\r\n                                    // whether to retry the primary children, or to skip over it and\r\n                                    // go straight to the fallback. Check the priority of the primary\r\n                                    // child fragment.\r\n                                    var primaryChildFragment = workInProgress.child;\r\n                                    var primaryChildLanes = primaryChildFragment.childLanes;\r\n                                    if (includesSomeLane(renderLanes, primaryChildLanes)) {\r\n                                        // The primary children have pending work. Use the normal path\r\n                                        // to attempt to render the primary children again.\r\n                                        return updateSuspenseComponent(current, workInProgress, renderLanes);\r\n                                    }\r\n                                    else {\r\n                                        // The primary child fragment does not have pending work marked\r\n                                        // on it\r\n                                        pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\r\n                                        // priority. Bailout.\r\n                                        var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n                                        if (child !== null) {\r\n                                            // The fallback children have pending work. Skip over the\r\n                                            // primary children and work on the fallback.\r\n                                            return child.sibling;\r\n                                        }\r\n                                        else {\r\n                                            return null;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\r\n                                }\r\n                                break;\r\n                            }\r\n                        case SuspenseListComponent:\r\n                            {\r\n                                var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\r\n                                var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\r\n                                if (didSuspendBefore) {\r\n                                    if (_hasChildWork) {\r\n                                        // If something was in fallback state last time, and we have all the\r\n                                        // same children then we're still in progressive loading state.\r\n                                        // Something might get unblocked by state updates or retries in the\r\n                                        // tree which will affect the tail. So we need to use the normal\r\n                                        // path to compute the correct tail.\r\n                                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\r\n                                    } // If none of the children had any work, that means that none of\r\n                                    // them got retried so they'll still be blocked in the same way\r\n                                    // as before. We can fast bail out.\r\n                                    workInProgress.flags |= DidCapture;\r\n                                } // If nothing suspended before and we're rendering the same children,\r\n                                // then the tail doesn't matter. Anything new that suspends will work\r\n                                // in the \"together\" mode, so we can continue from the state we had.\r\n                                var renderState = workInProgress.memoizedState;\r\n                                if (renderState !== null) {\r\n                                    // Reset to the \"together\" mode in case we've started a different\r\n                                    // update in the past but didn't complete it.\r\n                                    renderState.rendering = null;\r\n                                    renderState.tail = null;\r\n                                    renderState.lastEffect = null;\r\n                                }\r\n                                pushSuspenseContext(workInProgress, suspenseStackCursor.current);\r\n                                if (_hasChildWork) {\r\n                                    break;\r\n                                }\r\n                                else {\r\n                                    // If none of the children had any work, that means that none of\r\n                                    // them got retried so they'll still be blocked in the same way\r\n                                    // as before. We can fast bail out.\r\n                                    return null;\r\n                                }\r\n                            }\r\n                        case OffscreenComponent:\r\n                        case LegacyHiddenComponent:\r\n                            {\r\n                                // Need to check if the tree still needs to be deferred. This is\r\n                                // almost identical to the logic used in the normal update path,\r\n                                // so we'll just enter that. The only difference is we'll bail out\r\n                                // at the next level instead of this one, because the child props\r\n                                // have not changed. Which is fine.\r\n                                // TODO: Probably should refactor `beginWork` to split the bailout\r\n                                // path from the normal path. I'm tempted to do a labeled break here\r\n                                // but I won't :)\r\n                                workInProgress.lanes = NoLanes;\r\n                                return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n                            }\r\n                    }\r\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\r\n                }\r\n                else {\r\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\r\n                        // This is a special case that only exists for legacy mode.\r\n                        // See https://github.com/facebook/react/pull/19216.\r\n                        didReceiveUpdate = true;\r\n                    }\r\n                    else {\r\n                        // An update was scheduled on this fiber, but there are no new props\r\n                        // nor legacy context. Set this to false. If an update queue or context\r\n                        // consumer produces a changed value, it will set this to true. Otherwise,\r\n                        // the component will assume the children have not changed and bail out.\r\n                        didReceiveUpdate = false;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                didReceiveUpdate = false;\r\n            } // Before entering the begin phase, clear pending update priority.\r\n            // TODO: This assumes that we're about to evaluate the component and process\r\n            // the update queue. However, there's an exception: SimpleMemoComponent\r\n            // sometimes bails out later in the begin phase. This indicates that we should\r\n            // move this assignment out of the common path and into each branch.\r\n            workInProgress.lanes = NoLanes;\r\n            switch (workInProgress.tag) {\r\n                case IndeterminateComponent:\r\n                    {\r\n                        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\r\n                    }\r\n                case LazyComponent:\r\n                    {\r\n                        var elementType = workInProgress.elementType;\r\n                        return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);\r\n                    }\r\n                case FunctionComponent:\r\n                    {\r\n                        var _Component = workInProgress.type;\r\n                        var unresolvedProps = workInProgress.pendingProps;\r\n                        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);\r\n                        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        var _Component2 = workInProgress.type;\r\n                        var _unresolvedProps = workInProgress.pendingProps;\r\n                        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);\r\n                        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);\r\n                    }\r\n                case HostRoot:\r\n                    return updateHostRoot(current, workInProgress, renderLanes);\r\n                case HostComponent:\r\n                    return updateHostComponent(current, workInProgress, renderLanes);\r\n                case HostText:\r\n                    return updateHostText(current, workInProgress);\r\n                case SuspenseComponent:\r\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\r\n                case HostPortal:\r\n                    return updatePortalComponent(current, workInProgress, renderLanes);\r\n                case ForwardRef:\r\n                    {\r\n                        var type = workInProgress.type;\r\n                        var _unresolvedProps2 = workInProgress.pendingProps;\r\n                        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\r\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\r\n                    }\r\n                case Fragment:\r\n                    return updateFragment(current, workInProgress, renderLanes);\r\n                case Mode:\r\n                    return updateMode(current, workInProgress, renderLanes);\r\n                case Profiler:\r\n                    return updateProfiler(current, workInProgress, renderLanes);\r\n                case ContextProvider:\r\n                    return updateContextProvider(current, workInProgress, renderLanes);\r\n                case ContextConsumer:\r\n                    return updateContextConsumer(current, workInProgress, renderLanes);\r\n                case MemoComponent:\r\n                    {\r\n                        var _type2 = workInProgress.type;\r\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\r\n                        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\r\n                        {\r\n                            if (workInProgress.type !== workInProgress.elementType) {\r\n                                var outerPropTypes = _type2.propTypes;\r\n                                if (outerPropTypes) {\r\n                                    checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only\r\n                                    'prop', getComponentName(_type2));\r\n                                }\r\n                            }\r\n                        }\r\n                        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\r\n                        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);\r\n                    }\r\n                case SimpleMemoComponent:\r\n                    {\r\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);\r\n                    }\r\n                case IncompleteClassComponent:\r\n                    {\r\n                        var _Component3 = workInProgress.type;\r\n                        var _unresolvedProps4 = workInProgress.pendingProps;\r\n                        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);\r\n                        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);\r\n                    }\r\n                case SuspenseListComponent:\r\n                    {\r\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\r\n                    }\r\n                case FundamentalComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case ScopeComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case Block:\r\n                    {\r\n                        break;\r\n                    }\r\n                case OffscreenComponent:\r\n                    {\r\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\r\n                    }\r\n                case LegacyHiddenComponent:\r\n                    {\r\n                        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\r\n                    }\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function markUpdate(workInProgress) {\r\n            // Tag the fiber with an update effect. This turns a Placement into\r\n            // a PlacementAndUpdate.\r\n            workInProgress.flags |= Update;\r\n        }\r\n        function markRef$1(workInProgress) {\r\n            workInProgress.flags |= Ref;\r\n        }\r\n        var appendAllChildren;\r\n        var updateHostContainer;\r\n        var updateHostComponent$1;\r\n        var updateHostText$1;\r\n        {\r\n            // Mutation mode\r\n            appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\r\n                // We only have the top Fiber that was created but we need recurse down its\r\n                // children to find all the terminal nodes.\r\n                var node = workInProgress.child;\r\n                while (node !== null) {\r\n                    if (node.tag === HostComponent || node.tag === HostText) {\r\n                        appendInitialChild(parent, node.stateNode);\r\n                    }\r\n                    else if (node.tag === HostPortal)\r\n                        ;\r\n                    else if (node.child !== null) {\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                        continue;\r\n                    }\r\n                    if (node === workInProgress) {\r\n                        return;\r\n                    }\r\n                    while (node.sibling === null) {\r\n                        if (node.return === null || node.return === workInProgress) {\r\n                            return;\r\n                        }\r\n                        node = node.return;\r\n                    }\r\n                    node.sibling.return = node.return;\r\n                    node = node.sibling;\r\n                }\r\n            };\r\n            updateHostContainer = function (workInProgress) {\r\n            };\r\n            updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\r\n                // If we have an alternate, that means this is an update and we need to\r\n                // schedule a side-effect to do the updates.\r\n                var oldProps = current.memoizedProps;\r\n                if (oldProps === newProps) {\r\n                    // In mutation mode, this is sufficient for a bailout because\r\n                    // we won't touch this node even if children changed.\r\n                    return;\r\n                } // If we get updated because one of our children updated, we don't\r\n                // have newProps so we'll have to reuse them.\r\n                // TODO: Split the update API as separate for the props vs. children.\r\n                // Even better would be if children weren't special cased at all tho.\r\n                var instance = workInProgress.stateNode;\r\n                var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\r\n                // component is hitting the resume path. Figure out why. Possibly\r\n                // related to `hidden`.\r\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\r\n                workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\r\n                // is a new ref we mark this as an update. All the work is done in commitWork.\r\n                if (updatePayload) {\r\n                    markUpdate(workInProgress);\r\n                }\r\n            };\r\n            updateHostText$1 = function (current, workInProgress, oldText, newText) {\r\n                // If the text differs, mark it as an update. All the work in done in commitWork.\r\n                if (oldText !== newText) {\r\n                    markUpdate(workInProgress);\r\n                }\r\n            };\r\n        }\r\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\r\n            if (getIsHydrating()) {\r\n                // If we're hydrating, we should consume as many items as we can\r\n                // so we don't leave any behind.\r\n                return;\r\n            }\r\n            switch (renderState.tailMode) {\r\n                case 'hidden':\r\n                    {\r\n                        // Any insertions at the end of the tail list after this point\r\n                        // should be invisible. If there are already mounted boundaries\r\n                        // anything before them are not considered for collapsing.\r\n                        // Therefore we need to go through the whole tail to find if\r\n                        // there are any.\r\n                        var tailNode = renderState.tail;\r\n                        var lastTailNode = null;\r\n                        while (tailNode !== null) {\r\n                            if (tailNode.alternate !== null) {\r\n                                lastTailNode = tailNode;\r\n                            }\r\n                            tailNode = tailNode.sibling;\r\n                        } // Next we're simply going to delete all insertions after the\r\n                        // last rendered item.\r\n                        if (lastTailNode === null) {\r\n                            // All remaining items in the tail are insertions.\r\n                            renderState.tail = null;\r\n                        }\r\n                        else {\r\n                            // Detach the insertion after the last node that was already\r\n                            // inserted.\r\n                            lastTailNode.sibling = null;\r\n                        }\r\n                        break;\r\n                    }\r\n                case 'collapsed':\r\n                    {\r\n                        // Any insertions at the end of the tail list after this point\r\n                        // should be invisible. If there are already mounted boundaries\r\n                        // anything before them are not considered for collapsing.\r\n                        // Therefore we need to go through the whole tail to find if\r\n                        // there are any.\r\n                        var _tailNode = renderState.tail;\r\n                        var _lastTailNode = null;\r\n                        while (_tailNode !== null) {\r\n                            if (_tailNode.alternate !== null) {\r\n                                _lastTailNode = _tailNode;\r\n                            }\r\n                            _tailNode = _tailNode.sibling;\r\n                        } // Next we're simply going to delete all insertions after the\r\n                        // last rendered item.\r\n                        if (_lastTailNode === null) {\r\n                            // All remaining items in the tail are insertions.\r\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\r\n                                // We suspended during the head. We want to show at least one\r\n                                // row at the tail. So we'll keep on and cut off the rest.\r\n                                renderState.tail.sibling = null;\r\n                            }\r\n                            else {\r\n                                renderState.tail = null;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Detach the insertion after the last node that was already\r\n                            // inserted.\r\n                            _lastTailNode.sibling = null;\r\n                        }\r\n                        break;\r\n                    }\r\n            }\r\n        }\r\n        function completeWork(current, workInProgress, renderLanes) {\r\n            var newProps = workInProgress.pendingProps;\r\n            switch (workInProgress.tag) {\r\n                case IndeterminateComponent:\r\n                case LazyComponent:\r\n                case SimpleMemoComponent:\r\n                case FunctionComponent:\r\n                case ForwardRef:\r\n                case Fragment:\r\n                case Mode:\r\n                case Profiler:\r\n                case ContextConsumer:\r\n                case MemoComponent:\r\n                    return null;\r\n                case ClassComponent:\r\n                    {\r\n                        var Component = workInProgress.type;\r\n                        if (isContextProvider(Component)) {\r\n                            popContext(workInProgress);\r\n                        }\r\n                        return null;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        popHostContainer(workInProgress);\r\n                        popTopLevelContextObject(workInProgress);\r\n                        resetWorkInProgressVersions();\r\n                        var fiberRoot = workInProgress.stateNode;\r\n                        if (fiberRoot.pendingContext) {\r\n                            fiberRoot.context = fiberRoot.pendingContext;\r\n                            fiberRoot.pendingContext = null;\r\n                        }\r\n                        if (current === null || current.child === null) {\r\n                            // If we hydrated, pop so that we can delete any remaining children\r\n                            // that weren't hydrated.\r\n                            var wasHydrated = popHydrationState(workInProgress);\r\n                            if (wasHydrated) {\r\n                                // If we hydrated, then we'll need to schedule an update for\r\n                                // the commit side-effects on the root.\r\n                                markUpdate(workInProgress);\r\n                            }\r\n                            else if (!fiberRoot.hydrate) {\r\n                                // Schedule an effect to clear this container at the start of the next commit.\r\n                                // This handles the case of React rendering into a container with previous children.\r\n                                // It's also safe to do for updates too, because current.child would only be null\r\n                                // if the previous render was null (so the the container would already be empty).\r\n                                workInProgress.flags |= Snapshot;\r\n                            }\r\n                        }\r\n                        updateHostContainer(workInProgress);\r\n                        return null;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        popHostContext(workInProgress);\r\n                        var rootContainerInstance = getRootHostContainer();\r\n                        var type = workInProgress.type;\r\n                        if (current !== null && workInProgress.stateNode != null) {\r\n                            updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\r\n                            if (current.ref !== workInProgress.ref) {\r\n                                markRef$1(workInProgress);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (!newProps) {\r\n                                if (!(workInProgress.stateNode !== null)) {\r\n                                    {\r\n                                        throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\r\n                                    }\r\n                                } // This can happen when we abort work.\r\n                                return null;\r\n                            }\r\n                            var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\r\n                            // \"stack\" as the parent. Then append children as we go in beginWork\r\n                            // or completeWork depending on whether we want to add them top->down or\r\n                            // bottom->up. Top->down is faster in IE11.\r\n                            var _wasHydrated = popHydrationState(workInProgress);\r\n                            if (_wasHydrated) {\r\n                                // TODO: Move this and createInstance step into the beginPhase\r\n                                // to consolidate.\r\n                                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\r\n                                    // If changes to the hydrated node need to be applied at the\r\n                                    // commit-phase we mark this as such.\r\n                                    markUpdate(workInProgress);\r\n                                }\r\n                            }\r\n                            else {\r\n                                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\r\n                                appendAllChildren(instance, workInProgress, false, false);\r\n                                workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\r\n                                // (eg DOM renderer supports auto-focus for certain elements).\r\n                                // Make sure such renderers get scheduled for later work.\r\n                                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\r\n                                    markUpdate(workInProgress);\r\n                                }\r\n                            }\r\n                            if (workInProgress.ref !== null) {\r\n                                // If there is a ref on a host node we need to schedule a callback\r\n                                markRef$1(workInProgress);\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n                case HostText:\r\n                    {\r\n                        var newText = newProps;\r\n                        if (current && workInProgress.stateNode != null) {\r\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\r\n                            // to schedule a side-effect to do the updates.\r\n                            updateHostText$1(current, workInProgress, oldText, newText);\r\n                        }\r\n                        else {\r\n                            if (typeof newText !== 'string') {\r\n                                if (!(workInProgress.stateNode !== null)) {\r\n                                    {\r\n                                        throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\r\n                                    }\r\n                                } // This can happen when we abort work.\r\n                            }\r\n                            var _rootContainerInstance = getRootHostContainer();\r\n                            var _currentHostContext = getHostContext();\r\n                            var _wasHydrated2 = popHydrationState(workInProgress);\r\n                            if (_wasHydrated2) {\r\n                                if (prepareToHydrateHostTextInstance(workInProgress)) {\r\n                                    markUpdate(workInProgress);\r\n                                }\r\n                            }\r\n                            else {\r\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n                case SuspenseComponent:\r\n                    {\r\n                        popSuspenseContext(workInProgress);\r\n                        var nextState = workInProgress.memoizedState;\r\n                        if ((workInProgress.flags & DidCapture) !== NoFlags) {\r\n                            // Something suspended. Re-render with the fallback children.\r\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\r\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n                                transferActualDuration(workInProgress);\r\n                            }\r\n                            return workInProgress;\r\n                        }\r\n                        var nextDidTimeout = nextState !== null;\r\n                        var prevDidTimeout = false;\r\n                        if (current === null) {\r\n                            if (workInProgress.memoizedProps.fallback !== undefined) {\r\n                                popHydrationState(workInProgress);\r\n                            }\r\n                        }\r\n                        else {\r\n                            var prevState = current.memoizedState;\r\n                            prevDidTimeout = prevState !== null;\r\n                        }\r\n                        if (nextDidTimeout && !prevDidTimeout) {\r\n                            // If this subtreee is running in blocking mode we can suspend,\r\n                            // otherwise we won't suspend.\r\n                            // TODO: This will still suspend a synchronous tree if anything\r\n                            // in the concurrent tree already suspended during this render.\r\n                            // This is a known bug.\r\n                            if ((workInProgress.mode & BlockingMode) !== NoMode) {\r\n                                // TODO: Move this back to throwException because this is too late\r\n                                // if this is a large tree which is common for initial loads. We\r\n                                // don't know if we should restart a render or not until we get\r\n                                // this marker, and this is too late.\r\n                                // If this render already had a ping or lower pri updates,\r\n                                // and this is the first time we know we're going to suspend we\r\n                                // should be able to immediately restart from within throwException.\r\n                                var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;\r\n                                if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\r\n                                    // If this was in an invisible tree or a new render, then showing\r\n                                    // this boundary is ok.\r\n                                    renderDidSuspend();\r\n                                }\r\n                                else {\r\n                                    // Otherwise, we're going to have to hide content so we should\r\n                                    // suspend for longer if possible.\r\n                                    renderDidSuspendDelayIfPossible();\r\n                                }\r\n                            }\r\n                        }\r\n                        {\r\n                            // TODO: Only schedule updates if these values are non equal, i.e. it changed.\r\n                            if (nextDidTimeout || prevDidTimeout) {\r\n                                // If this boundary just timed out, schedule an effect to attach a\r\n                                // retry listener to the promise. This flag is also used to hide the\r\n                                // primary children. In mutation mode, we also need the flag to\r\n                                // *unhide* children that were previously hidden, so check if this\r\n                                // is currently timed out, too.\r\n                                workInProgress.flags |= Update;\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n                case HostPortal:\r\n                    popHostContainer(workInProgress);\r\n                    updateHostContainer(workInProgress);\r\n                    if (current === null) {\r\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\r\n                    }\r\n                    return null;\r\n                case ContextProvider:\r\n                    // Pop provider fiber\r\n                    popProvider(workInProgress);\r\n                    return null;\r\n                case IncompleteClassComponent:\r\n                    {\r\n                        // Same as class component case. I put it down here so that the tags are\r\n                        // sequential to ensure this switch is compiled to a jump table.\r\n                        var _Component = workInProgress.type;\r\n                        if (isContextProvider(_Component)) {\r\n                            popContext(workInProgress);\r\n                        }\r\n                        return null;\r\n                    }\r\n                case SuspenseListComponent:\r\n                    {\r\n                        popSuspenseContext(workInProgress);\r\n                        var renderState = workInProgress.memoizedState;\r\n                        if (renderState === null) {\r\n                            // We're running in the default, \"independent\" mode.\r\n                            // We don't do anything in this mode.\r\n                            return null;\r\n                        }\r\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\r\n                        var renderedTail = renderState.rendering;\r\n                        if (renderedTail === null) {\r\n                            // We just rendered the head.\r\n                            if (!didSuspendAlready) {\r\n                                // This is the first pass. We need to figure out if anything is still\r\n                                // suspended in the rendered set.\r\n                                // If new content unsuspended, but there's still some content that\r\n                                // didn't. Then we need to do a second pass that forces everything\r\n                                // to keep showing their fallbacks.\r\n                                // We might be suspended if something in this render pass suspended, or\r\n                                // something in the previous committed pass suspended. Otherwise,\r\n                                // there's no chance so we can skip the expensive call to\r\n                                // findFirstSuspended.\r\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\r\n                                if (!cannotBeSuspended) {\r\n                                    var row = workInProgress.child;\r\n                                    while (row !== null) {\r\n                                        var suspended = findFirstSuspended(row);\r\n                                        if (suspended !== null) {\r\n                                            didSuspendAlready = true;\r\n                                            workInProgress.flags |= DidCapture;\r\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\r\n                                            // part of the second pass. In that case nothing will subscribe to\r\n                                            // its thennables. Instead, we'll transfer its thennables to the\r\n                                            // SuspenseList so that it can retry if they resolve.\r\n                                            // There might be multiple of these in the list but since we're\r\n                                            // going to wait for all of them anyway, it doesn't really matter\r\n                                            // which ones gets to ping. In theory we could get clever and keep\r\n                                            // track of how many dependencies remain but it gets tricky because\r\n                                            // in the meantime, we can add/remove/change items and dependencies.\r\n                                            // We might bail out of the loop before finding any but that\r\n                                            // doesn't matter since that means that the other boundaries that\r\n                                            // we did find already has their listeners attached.\r\n                                            var newThennables = suspended.updateQueue;\r\n                                            if (newThennables !== null) {\r\n                                                workInProgress.updateQueue = newThennables;\r\n                                                workInProgress.flags |= Update;\r\n                                            } // Rerender the whole list, but this time, we'll force fallbacks\r\n                                            // to stay in place.\r\n                                            // Reset the effect list before doing the second pass since that's now invalid.\r\n                                            if (renderState.lastEffect === null) {\r\n                                                workInProgress.firstEffect = null;\r\n                                            }\r\n                                            workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.\r\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\r\n                                            // rerender the children.\r\n                                            pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));\r\n                                            return workInProgress.child;\r\n                                        }\r\n                                        row = row.sibling;\r\n                                    }\r\n                                }\r\n                                if (renderState.tail !== null && now() > getRenderTargetTime()) {\r\n                                    // We have already passed our CPU deadline but we still have rows\r\n                                    // left in the tail. We'll just give up further attempts to render\r\n                                    // the main content and only render fallbacks.\r\n                                    workInProgress.flags |= DidCapture;\r\n                                    didSuspendAlready = true;\r\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\r\n                                    // to get it started back up to attempt the next item. While in terms\r\n                                    // of priority this work has the same priority as this current render,\r\n                                    // it's not part of the same transition once the transition has\r\n                                    // committed. If it's sync, we still want to yield so that it can be\r\n                                    // painted. Conceptually, this is really the same as pinging.\r\n                                    // We can use any RetryLane even if it's the one currently rendering\r\n                                    // since we're leaving it behind on this node.\r\n                                    workInProgress.lanes = SomeRetryLane;\r\n                                    {\r\n                                        markSpawnedWork(SomeRetryLane);\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                cutOffTailIfNeeded(renderState, false);\r\n                            } // Next we're going to render the tail.\r\n                        }\r\n                        else {\r\n                            // Append the rendered row to the child list.\r\n                            if (!didSuspendAlready) {\r\n                                var _suspended = findFirstSuspended(renderedTail);\r\n                                if (_suspended !== null) {\r\n                                    workInProgress.flags |= DidCapture;\r\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\r\n                                    // get lost if this row ends up dropped during a second pass.\r\n                                    var _newThennables = _suspended.updateQueue;\r\n                                    if (_newThennables !== null) {\r\n                                        workInProgress.updateQueue = _newThennables;\r\n                                        workInProgress.flags |= Update;\r\n                                    }\r\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\r\n                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\r\n                                    ) {\r\n                                        // We need to delete the row we just rendered.\r\n                                        // Reset the effect list to what it was before we rendered this\r\n                                        // child. The nested children have already appended themselves.\r\n                                        var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.\r\n                                        if (lastEffect !== null) {\r\n                                            lastEffect.nextEffect = null;\r\n                                        } // We're done.\r\n                                        return null;\r\n                                    }\r\n                                }\r\n                                else if ( // The time it took to render last row is greater than the remaining\r\n                                // time we have to render. So rendering one more row would likely\r\n                                // exceed it.\r\n                                now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\r\n                                    // We have now passed our CPU deadline and we'll just give up further\r\n                                    // attempts to render the main content and only render fallbacks.\r\n                                    // The assumption is that this is usually faster.\r\n                                    workInProgress.flags |= DidCapture;\r\n                                    didSuspendAlready = true;\r\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\r\n                                    // to get it started back up to attempt the next item. While in terms\r\n                                    // of priority this work has the same priority as this current render,\r\n                                    // it's not part of the same transition once the transition has\r\n                                    // committed. If it's sync, we still want to yield so that it can be\r\n                                    // painted. Conceptually, this is really the same as pinging.\r\n                                    // We can use any RetryLane even if it's the one currently rendering\r\n                                    // since we're leaving it behind on this node.\r\n                                    workInProgress.lanes = SomeRetryLane;\r\n                                    {\r\n                                        markSpawnedWork(SomeRetryLane);\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (renderState.isBackwards) {\r\n                                // The effect list of the backwards tail will have been added\r\n                                // to the end. This breaks the guarantee that life-cycles fire in\r\n                                // sibling order but that isn't a strong guarantee promised by React.\r\n                                // Especially since these might also just pop in during future commits.\r\n                                // Append to the beginning of the list.\r\n                                renderedTail.sibling = workInProgress.child;\r\n                                workInProgress.child = renderedTail;\r\n                            }\r\n                            else {\r\n                                var previousSibling = renderState.last;\r\n                                if (previousSibling !== null) {\r\n                                    previousSibling.sibling = renderedTail;\r\n                                }\r\n                                else {\r\n                                    workInProgress.child = renderedTail;\r\n                                }\r\n                                renderState.last = renderedTail;\r\n                            }\r\n                        }\r\n                        if (renderState.tail !== null) {\r\n                            // We still have tail rows to render.\r\n                            // Pop a row.\r\n                            var next = renderState.tail;\r\n                            renderState.rendering = next;\r\n                            renderState.tail = next.sibling;\r\n                            renderState.lastEffect = workInProgress.lastEffect;\r\n                            renderState.renderingStartTime = now();\r\n                            next.sibling = null; // Restore the context.\r\n                            // TODO: We can probably just avoid popping it instead and only\r\n                            // setting it the first time we go from not suspended to suspended.\r\n                            var suspenseContext = suspenseStackCursor.current;\r\n                            if (didSuspendAlready) {\r\n                                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\r\n                            }\r\n                            else {\r\n                                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\r\n                            }\r\n                            pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\r\n                            return next;\r\n                        }\r\n                        return null;\r\n                    }\r\n                case FundamentalComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case ScopeComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case Block:\r\n                    break;\r\n                case OffscreenComponent:\r\n                case LegacyHiddenComponent:\r\n                    {\r\n                        popRenderLanes(workInProgress);\r\n                        if (current !== null) {\r\n                            var _nextState = workInProgress.memoizedState;\r\n                            var _prevState = current.memoizedState;\r\n                            var prevIsHidden = _prevState !== null;\r\n                            var nextIsHidden = _nextState !== null;\r\n                            if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') {\r\n                                workInProgress.flags |= Update;\r\n                            }\r\n                        }\r\n                        return null;\r\n                    }\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function unwindWork(workInProgress, renderLanes) {\r\n            switch (workInProgress.tag) {\r\n                case ClassComponent:\r\n                    {\r\n                        var Component = workInProgress.type;\r\n                        if (isContextProvider(Component)) {\r\n                            popContext(workInProgress);\r\n                        }\r\n                        var flags = workInProgress.flags;\r\n                        if (flags & ShouldCapture) {\r\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\r\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n                                transferActualDuration(workInProgress);\r\n                            }\r\n                            return workInProgress;\r\n                        }\r\n                        return null;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        popHostContainer(workInProgress);\r\n                        popTopLevelContextObject(workInProgress);\r\n                        resetWorkInProgressVersions();\r\n                        var _flags = workInProgress.flags;\r\n                        if (!((_flags & DidCapture) === NoFlags)) {\r\n                            {\r\n                                throw Error(\"The root failed to unmount after an error. This is likely a bug in React. Please file an issue.\");\r\n                            }\r\n                        }\r\n                        workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\r\n                        return workInProgress;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        // TODO: popHydrationState\r\n                        popHostContext(workInProgress);\r\n                        return null;\r\n                    }\r\n                case SuspenseComponent:\r\n                    {\r\n                        popSuspenseContext(workInProgress);\r\n                        var _flags2 = workInProgress.flags;\r\n                        if (_flags2 & ShouldCapture) {\r\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\r\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\r\n                                transferActualDuration(workInProgress);\r\n                            }\r\n                            return workInProgress;\r\n                        }\r\n                        return null;\r\n                    }\r\n                case SuspenseListComponent:\r\n                    {\r\n                        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\r\n                        // caught by a nested boundary. If not, it should bubble through.\r\n                        return null;\r\n                    }\r\n                case HostPortal:\r\n                    popHostContainer(workInProgress);\r\n                    return null;\r\n                case ContextProvider:\r\n                    popProvider(workInProgress);\r\n                    return null;\r\n                case OffscreenComponent:\r\n                case LegacyHiddenComponent:\r\n                    popRenderLanes(workInProgress);\r\n                    return null;\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n        function unwindInterruptedWork(interruptedWork) {\r\n            switch (interruptedWork.tag) {\r\n                case ClassComponent:\r\n                    {\r\n                        var childContextTypes = interruptedWork.type.childContextTypes;\r\n                        if (childContextTypes !== null && childContextTypes !== undefined) {\r\n                            popContext(interruptedWork);\r\n                        }\r\n                        break;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        popHostContainer(interruptedWork);\r\n                        popTopLevelContextObject(interruptedWork);\r\n                        resetWorkInProgressVersions();\r\n                        break;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        popHostContext(interruptedWork);\r\n                        break;\r\n                    }\r\n                case HostPortal:\r\n                    popHostContainer(interruptedWork);\r\n                    break;\r\n                case SuspenseComponent:\r\n                    popSuspenseContext(interruptedWork);\r\n                    break;\r\n                case SuspenseListComponent:\r\n                    popSuspenseContext(interruptedWork);\r\n                    break;\r\n                case ContextProvider:\r\n                    popProvider(interruptedWork);\r\n                    break;\r\n                case OffscreenComponent:\r\n                case LegacyHiddenComponent:\r\n                    popRenderLanes(interruptedWork);\r\n                    break;\r\n            }\r\n        }\r\n        function createCapturedValue(value, source) {\r\n            // If the value is an error, call this function immediately after it is thrown\r\n            // so the stack is accurate.\r\n            return {\r\n                value: value,\r\n                source: source,\r\n                stack: getStackByFiberInDevAndProd(source)\r\n            };\r\n        }\r\n        // This module is forked in different environments.\r\n        // By default, return `true` to log errors to the console.\r\n        // Forks can return `false` if this isn't desirable.\r\n        function showErrorDialog(boundary, errorInfo) {\r\n            return true;\r\n        }\r\n        function logCapturedError(boundary, errorInfo) {\r\n            try {\r\n                var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\r\n                // This enables renderers like ReactNative to better manage redbox behavior.\r\n                if (logError === false) {\r\n                    return;\r\n                }\r\n                var error = errorInfo.value;\r\n                if (true) {\r\n                    var source = errorInfo.source;\r\n                    var stack = errorInfo.stack;\r\n                    var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling\r\n                    // `preventDefault()` in window `error` handler.\r\n                    // We record this information as an expando on the error.\r\n                    if (error != null && error._suppressLogging) {\r\n                        if (boundary.tag === ClassComponent) {\r\n                            // The error is recoverable and was silenced.\r\n                            // Ignore it and don't print the stack addendum.\r\n                            // This is handy for testing error boundaries without noise.\r\n                            return;\r\n                        } // The error is fatal. Since the silencing might have\r\n                        // been accidental, we'll surface it anyway.\r\n                        // However, the browser would have silenced the original error\r\n                        // so we'll print it first, and then print the stack addendum.\r\n                        console['error'](error); // Don't transform to our wrapper\r\n                        // For a more detailed description of this block, see:\r\n                        // https://github.com/facebook/react/pull/13384\r\n                    }\r\n                    var componentName = source ? getComponentName(source.type) : null;\r\n                    var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : 'The above error occurred in one of your React components:';\r\n                    var errorBoundaryMessage;\r\n                    var errorBoundaryName = getComponentName(boundary.type);\r\n                    if (errorBoundaryName) {\r\n                        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\r\n                    }\r\n                    else {\r\n                        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';\r\n                    }\r\n                    var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\r\n                    // We don't include the original error message and JS stack because the browser\r\n                    // has already printed it. Even if the application swallows the error, it is still\r\n                    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\r\n                    console['error'](combinedMessage); // Don't transform to our wrapper\r\n                }\r\n                else {}\r\n            }\r\n            catch (e) {\r\n                // This method must not throw, or React internal state will get messed up.\r\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\r\n                // we want to report this error outside of the normal stack as a last resort.\r\n                // https://github.com/facebook/react/issues/13188\r\n                setTimeout(function () {\r\n                    throw e;\r\n                });\r\n            }\r\n        }\r\n        var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\r\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\r\n            var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\r\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\r\n            // being called \"element\".\r\n            update.payload = {\r\n                element: null\r\n            };\r\n            var error = errorInfo.value;\r\n            update.callback = function () {\r\n                onUncaughtError(error);\r\n                logCapturedError(fiber, errorInfo);\r\n            };\r\n            return update;\r\n        }\r\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\r\n            var update = createUpdate(NoTimestamp, lane);\r\n            update.tag = CaptureUpdate;\r\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\r\n            if (typeof getDerivedStateFromError === 'function') {\r\n                var error$1 = errorInfo.value;\r\n                update.payload = function () {\r\n                    logCapturedError(fiber, errorInfo);\r\n                    return getDerivedStateFromError(error$1);\r\n                };\r\n            }\r\n            var inst = fiber.stateNode;\r\n            if (inst !== null && typeof inst.componentDidCatch === 'function') {\r\n                update.callback = function callback() {\r\n                    {\r\n                        markFailedErrorBoundaryForHotReloading(fiber);\r\n                    }\r\n                    if (typeof getDerivedStateFromError !== 'function') {\r\n                        // To preserve the preexisting retry behavior of error boundaries,\r\n                        // we keep track of which ones already failed during this batch.\r\n                        // This gets reset before we yield back to the browser.\r\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\r\n                        // not defined.\r\n                        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined\r\n                        logCapturedError(fiber, errorInfo);\r\n                    }\r\n                    var error$1 = errorInfo.value;\r\n                    var stack = errorInfo.stack;\r\n                    this.componentDidCatch(error$1, {\r\n                        componentStack: stack !== null ? stack : ''\r\n                    });\r\n                    {\r\n                        if (typeof getDerivedStateFromError !== 'function') {\r\n                            // If componentDidCatch is the only error boundary method defined,\r\n                            // then it needs to call setState to recover from errors.\r\n                            // If no state update is scheduled then the boundary will swallow the error.\r\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\r\n                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n            else {\r\n                update.callback = function () {\r\n                    markFailedErrorBoundaryForHotReloading(fiber);\r\n                };\r\n            }\r\n            return update;\r\n        }\r\n        function attachPingListener(root, wakeable, lanes) {\r\n            // Attach a listener to the promise to \"ping\" the root and retry. But only if\r\n            // one does not already exist for the lanes we're currently rendering (which\r\n            // acts like a \"thread ID\" here).\r\n            var pingCache = root.pingCache;\r\n            var threadIDs;\r\n            if (pingCache === null) {\r\n                pingCache = root.pingCache = new PossiblyWeakMap$1();\r\n                threadIDs = new Set();\r\n                pingCache.set(wakeable, threadIDs);\r\n            }\r\n            else {\r\n                threadIDs = pingCache.get(wakeable);\r\n                if (threadIDs === undefined) {\r\n                    threadIDs = new Set();\r\n                    pingCache.set(wakeable, threadIDs);\r\n                }\r\n            }\r\n            if (!threadIDs.has(lanes)) {\r\n                // Memoize using the thread ID to prevent redundant listeners.\r\n                threadIDs.add(lanes);\r\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\r\n                wakeable.then(ping, ping);\r\n            }\r\n        }\r\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\r\n            // The source fiber did not complete.\r\n            sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.\r\n            sourceFiber.firstEffect = sourceFiber.lastEffect = null;\r\n            if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\r\n                // This is a wakeable.\r\n                var wakeable = value;\r\n                if ((sourceFiber.mode & BlockingMode) === NoMode) {\r\n                    // Reset the memoizedState to what it was before we attempted\r\n                    // to render it.\r\n                    var currentSource = sourceFiber.alternate;\r\n                    if (currentSource) {\r\n                        sourceFiber.updateQueue = currentSource.updateQueue;\r\n                        sourceFiber.memoizedState = currentSource.memoizedState;\r\n                        sourceFiber.lanes = currentSource.lanes;\r\n                    }\r\n                    else {\r\n                        sourceFiber.updateQueue = null;\r\n                        sourceFiber.memoizedState = null;\r\n                    }\r\n                }\r\n                var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.\r\n                var _workInProgress = returnFiber;\r\n                do {\r\n                    if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {\r\n                        // Found the nearest boundary.\r\n                        // Stash the promise on the boundary fiber. If the boundary times out, we'll\r\n                        // attach another listener to flip the boundary back to its normal state.\r\n                        var wakeables = _workInProgress.updateQueue;\r\n                        if (wakeables === null) {\r\n                            var updateQueue = new Set();\r\n                            updateQueue.add(wakeable);\r\n                            _workInProgress.updateQueue = updateQueue;\r\n                        }\r\n                        else {\r\n                            wakeables.add(wakeable);\r\n                        } // If the boundary is outside of blocking mode, we should *not*\r\n                        // suspend the commit. Pretend as if the suspended component rendered\r\n                        // null and keep rendering. In the commit phase, we'll schedule a\r\n                        // subsequent synchronous update to re-render the Suspense.\r\n                        //\r\n                        // Note: It doesn't matter whether the component that suspended was\r\n                        // inside a blocking mode tree. If the Suspense is outside of it, we\r\n                        // should *not* suspend the commit.\r\n                        if ((_workInProgress.mode & BlockingMode) === NoMode) {\r\n                            _workInProgress.flags |= DidCapture;\r\n                            sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\r\n                            // But we shouldn't call any lifecycle methods or callbacks. Remove\r\n                            // all lifecycle effect tags.\r\n                            sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\r\n                            if (sourceFiber.tag === ClassComponent) {\r\n                                var currentSourceFiber = sourceFiber.alternate;\r\n                                if (currentSourceFiber === null) {\r\n                                    // This is a new mount. Change the tag so it's not mistaken for a\r\n                                    // completed class component. For example, we should not call\r\n                                    // componentWillUnmount if it is deleted.\r\n                                    sourceFiber.tag = IncompleteClassComponent;\r\n                                }\r\n                                else {\r\n                                    // When we try rendering again, we should not reuse the current fiber,\r\n                                    // since it's known to be in an inconsistent state. Use a force update to\r\n                                    // prevent a bail out.\r\n                                    var update = createUpdate(NoTimestamp, SyncLane);\r\n                                    update.tag = ForceUpdate;\r\n                                    enqueueUpdate(sourceFiber, update);\r\n                                }\r\n                            } // The source fiber did not complete. Mark it with Sync priority to\r\n                            // indicate that it still has pending work.\r\n                            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.\r\n                            return;\r\n                        } // Confirmed that the boundary is in a concurrent mode tree. Continue\r\n                        // with the normal suspend path.\r\n                        //\r\n                        // After this we'll use a set of heuristics to determine whether this\r\n                        // render pass will run to completion or restart or \"suspend\" the commit.\r\n                        // The actual logic for this is spread out in different places.\r\n                        //\r\n                        // This first principle is that if we're going to suspend when we complete\r\n                        // a root, then we should also restart if we get an update or ping that\r\n                        // might unsuspend it, and vice versa. The only reason to suspend is\r\n                        // because you think you might want to restart before committing. However,\r\n                        // it doesn't make sense to restart only while in the period we're suspended.\r\n                        //\r\n                        // Restarting too aggressively is also not good because it starves out any\r\n                        // intermediate loading state. So we use heuristics to determine when.\r\n                        // Suspense Heuristics\r\n                        //\r\n                        // If nothing threw a Promise or all the same fallbacks are already showing,\r\n                        // then don't suspend/restart.\r\n                        //\r\n                        // If this is an initial render of a new tree of Suspense boundaries and\r\n                        // those trigger a fallback, then don't suspend/restart. We want to ensure\r\n                        // that we can show the initial loading state as quickly as possible.\r\n                        //\r\n                        // If we hit a \"Delayed\" case, such as when we'd switch from content back into\r\n                        // a fallback, then we should always suspend/restart. Transitions apply\r\n                        // to this case. If none is defined, JND is used instead.\r\n                        //\r\n                        // If we're already showing a fallback and it gets \"retried\", allowing us to show\r\n                        // another level, but there's still an inner boundary that would show a fallback,\r\n                        // then we suspend/restart for 500ms since the last time we showed a fallback\r\n                        // anywhere in the tree. This effectively throttles progressive loading into a\r\n                        // consistent train of commits. This also gives us an opportunity to restart to\r\n                        // get to the completed state slightly earlier.\r\n                        //\r\n                        // If there's ambiguity due to batching it's resolved in preference of:\r\n                        // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\r\n                        //\r\n                        // We want to ensure that a \"busy\" state doesn't get force committed. We want to\r\n                        // ensure that new initial loading states can commit as soon as possible.\r\n                        attachPingListener(root, wakeable, rootRenderLanes);\r\n                        _workInProgress.flags |= ShouldCapture;\r\n                        _workInProgress.lanes = rootRenderLanes;\r\n                        return;\r\n                    } // This boundary already captured during this render. Continue to the next\r\n                    // boundary.\r\n                    _workInProgress = _workInProgress.return;\r\n                } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.\r\n                // TODO: Use invariant so the message is stripped in prod?\r\n                value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\\n' + '\\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');\r\n            } // We didn't find a boundary that could handle this type of exception. Start\r\n            // over and traverse parent path again, this time treating the exception\r\n            // as an error.\r\n            renderDidError();\r\n            value = createCapturedValue(value, sourceFiber);\r\n            var workInProgress = returnFiber;\r\n            do {\r\n                switch (workInProgress.tag) {\r\n                    case HostRoot:\r\n                        {\r\n                            var _errorInfo = value;\r\n                            workInProgress.flags |= ShouldCapture;\r\n                            var lane = pickArbitraryLane(rootRenderLanes);\r\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\r\n                            var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\r\n                            enqueueCapturedUpdate(workInProgress, _update);\r\n                            return;\r\n                        }\r\n                    case ClassComponent:\r\n                        // Capture and retry\r\n                        var errorInfo = value;\r\n                        var ctor = workInProgress.type;\r\n                        var instance = workInProgress.stateNode;\r\n                        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\r\n                            workInProgress.flags |= ShouldCapture;\r\n                            var _lane = pickArbitraryLane(rootRenderLanes);\r\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\r\n                            var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);\r\n                            enqueueCapturedUpdate(workInProgress, _update2);\r\n                            return;\r\n                        }\r\n                        break;\r\n                }\r\n                workInProgress = workInProgress.return;\r\n            } while (workInProgress !== null);\r\n        }\r\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\r\n        {\r\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\r\n        }\r\n        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\r\n        var callComponentWillUnmountWithTimer = function (current, instance) {\r\n            instance.props = current.memoizedProps;\r\n            instance.state = current.memoizedState;\r\n            {\r\n                instance.componentWillUnmount();\r\n            }\r\n        }; // Capture errors so they don't interrupt unmounting.\r\n        function safelyCallComponentWillUnmount(current, instance) {\r\n            {\r\n                invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);\r\n                if (hasCaughtError()) {\r\n                    var unmountError = clearCaughtError();\r\n                    captureCommitPhaseError(current, unmountError);\r\n                }\r\n            }\r\n        }\r\n        function safelyDetachRef(current) {\r\n            var ref = current.ref;\r\n            if (ref !== null) {\r\n                if (typeof ref === 'function') {\r\n                    {\r\n                        invokeGuardedCallback(null, ref, null, null);\r\n                        if (hasCaughtError()) {\r\n                            var refError = clearCaughtError();\r\n                            captureCommitPhaseError(current, refError);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    ref.current = null;\r\n                }\r\n            }\r\n        }\r\n        function safelyCallDestroy(current, destroy) {\r\n            {\r\n                invokeGuardedCallback(null, destroy, null);\r\n                if (hasCaughtError()) {\r\n                    var error = clearCaughtError();\r\n                    captureCommitPhaseError(current, error);\r\n                }\r\n            }\r\n        }\r\n        function commitBeforeMutationLifeCycles(current, finishedWork) {\r\n            switch (finishedWork.tag) {\r\n                case FunctionComponent:\r\n                case ForwardRef:\r\n                case SimpleMemoComponent:\r\n                case Block:\r\n                    {\r\n                        return;\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        if (finishedWork.flags & Snapshot) {\r\n                            if (current !== null) {\r\n                                var prevProps = current.memoizedProps;\r\n                                var prevState = current.memoizedState;\r\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\r\n                                // but instead we rely on them being set during last render.\r\n                                // TODO: revisit this when we implement resuming.\r\n                                {\r\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\r\n                                        if (instance.props !== finishedWork.memoizedProps) {\r\n                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                        if (instance.state !== finishedWork.memoizedState) {\r\n                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                    }\r\n                                }\r\n                                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\r\n                                {\r\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\r\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\r\n                                        didWarnSet.add(finishedWork.type);\r\n                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));\r\n                                    }\r\n                                }\r\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        {\r\n                            if (finishedWork.flags & Snapshot) {\r\n                                var root = finishedWork.stateNode;\r\n                                clearContainer(root.containerInfo);\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostComponent:\r\n                case HostText:\r\n                case HostPortal:\r\n                case IncompleteClassComponent:\r\n                    // Nothing to do for these component types\r\n                    return;\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function commitHookEffectListUnmount(tag, finishedWork) {\r\n            var updateQueue = finishedWork.updateQueue;\r\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\r\n            if (lastEffect !== null) {\r\n                var firstEffect = lastEffect.next;\r\n                var effect = firstEffect;\r\n                do {\r\n                    if ((effect.tag & tag) === tag) {\r\n                        // Unmount\r\n                        var destroy = effect.destroy;\r\n                        effect.destroy = undefined;\r\n                        if (destroy !== undefined) {\r\n                            destroy();\r\n                        }\r\n                    }\r\n                    effect = effect.next;\r\n                } while (effect !== firstEffect);\r\n            }\r\n        }\r\n        function commitHookEffectListMount(tag, finishedWork) {\r\n            var updateQueue = finishedWork.updateQueue;\r\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\r\n            if (lastEffect !== null) {\r\n                var firstEffect = lastEffect.next;\r\n                var effect = firstEffect;\r\n                do {\r\n                    if ((effect.tag & tag) === tag) {\r\n                        // Mount\r\n                        var create = effect.create;\r\n                        effect.destroy = create();\r\n                        {\r\n                            var destroy = effect.destroy;\r\n                            if (destroy !== undefined && typeof destroy !== 'function') {\r\n                                var addendum = void 0;\r\n                                if (destroy === null) {\r\n                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\r\n                                }\r\n                                else if (typeof destroy.then === 'function') {\r\n                                    addendum = '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\r\n                                }\r\n                                else {\r\n                                    addendum = ' You returned: ' + destroy;\r\n                                }\r\n                                error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s', addendum);\r\n                            }\r\n                        }\r\n                    }\r\n                    effect = effect.next;\r\n                } while (effect !== firstEffect);\r\n            }\r\n        }\r\n        function schedulePassiveEffects(finishedWork) {\r\n            var updateQueue = finishedWork.updateQueue;\r\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\r\n            if (lastEffect !== null) {\r\n                var firstEffect = lastEffect.next;\r\n                var effect = firstEffect;\r\n                do {\r\n                    var _effect = effect, next = _effect.next, tag = _effect.tag;\r\n                    if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {\r\n                        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);\r\n                        enqueuePendingPassiveHookEffectMount(finishedWork, effect);\r\n                    }\r\n                    effect = next;\r\n                } while (effect !== firstEffect);\r\n            }\r\n        }\r\n        function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {\r\n            switch (finishedWork.tag) {\r\n                case FunctionComponent:\r\n                case ForwardRef:\r\n                case SimpleMemoComponent:\r\n                case Block:\r\n                    {\r\n                        // At this point layout effects have already been destroyed (during mutation phase).\r\n                        // This is done to prevent sibling component effects from interfering with each other,\r\n                        // e.g. a destroy function in one component should never override a ref set\r\n                        // by a create function in another component during the same commit.\r\n                        {\r\n                            commitHookEffectListMount(Layout | HasEffect, finishedWork);\r\n                        }\r\n                        schedulePassiveEffects(finishedWork);\r\n                        return;\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        var instance = finishedWork.stateNode;\r\n                        if (finishedWork.flags & Update) {\r\n                            if (current === null) {\r\n                                // We could update instance props and state here,\r\n                                // but instead we rely on them being set during last render.\r\n                                // TODO: revisit this when we implement resuming.\r\n                                {\r\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\r\n                                        if (instance.props !== finishedWork.memoizedProps) {\r\n                                            error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                        if (instance.state !== finishedWork.memoizedState) {\r\n                                            error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                    }\r\n                                }\r\n                                {\r\n                                    instance.componentDidMount();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\r\n                                var prevState = current.memoizedState; // We could update instance props and state here,\r\n                                // but instead we rely on them being set during last render.\r\n                                // TODO: revisit this when we implement resuming.\r\n                                {\r\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\r\n                                        if (instance.props !== finishedWork.memoizedProps) {\r\n                                            error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                        if (instance.state !== finishedWork.memoizedState) {\r\n                                            error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                        }\r\n                                    }\r\n                                }\r\n                                {\r\n                                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\r\n                                }\r\n                            }\r\n                        } // TODO: I think this is now always non-null by the time it reaches the\r\n                        // commit phase. Consider removing the type check.\r\n                        var updateQueue = finishedWork.updateQueue;\r\n                        if (updateQueue !== null) {\r\n                            {\r\n                                if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\r\n                                    if (instance.props !== finishedWork.memoizedProps) {\r\n                                        error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                    }\r\n                                    if (instance.state !== finishedWork.memoizedState) {\r\n                                        error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\r\n                                    }\r\n                                }\r\n                            } // We could update instance props and state here,\r\n                            // but instead we rely on them being set during last render.\r\n                            // TODO: revisit this when we implement resuming.\r\n                            commitUpdateQueue(finishedWork, updateQueue, instance);\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        // TODO: I think this is now always non-null by the time it reaches the\r\n                        // commit phase. Consider removing the type check.\r\n                        var _updateQueue = finishedWork.updateQueue;\r\n                        if (_updateQueue !== null) {\r\n                            var _instance = null;\r\n                            if (finishedWork.child !== null) {\r\n                                switch (finishedWork.child.tag) {\r\n                                    case HostComponent:\r\n                                        _instance = getPublicInstance(finishedWork.child.stateNode);\r\n                                        break;\r\n                                    case ClassComponent:\r\n                                        _instance = finishedWork.child.stateNode;\r\n                                        break;\r\n                                }\r\n                            }\r\n                            commitUpdateQueue(finishedWork, _updateQueue, _instance);\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\r\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\r\n                        // These effects should only be committed when components are first mounted,\r\n                        // aka when there is no current/alternate.\r\n                        if (current === null && finishedWork.flags & Update) {\r\n                            var type = finishedWork.type;\r\n                            var props = finishedWork.memoizedProps;\r\n                            commitMount(_instance2, type, props);\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostText:\r\n                    {\r\n                        // We have no life-cycles associated with text.\r\n                        return;\r\n                    }\r\n                case HostPortal:\r\n                    {\r\n                        // We have no life-cycles associated with portals.\r\n                        return;\r\n                    }\r\n                case Profiler:\r\n                    {\r\n                        {\r\n                            var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\r\n                            var effectDuration = finishedWork.stateNode.effectDuration;\r\n                            var commitTime = getCommitTime();\r\n                            if (typeof onRender === 'function') {\r\n                                {\r\n                                    onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);\r\n                                }\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case SuspenseComponent:\r\n                    {\r\n                        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\r\n                        return;\r\n                    }\r\n                case SuspenseListComponent:\r\n                case IncompleteClassComponent:\r\n                case FundamentalComponent:\r\n                case ScopeComponent:\r\n                case OffscreenComponent:\r\n                case LegacyHiddenComponent:\r\n                    return;\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\r\n            {\r\n                // We only have the top Fiber that was inserted but we need to recurse down its\r\n                // children to find all the terminal nodes.\r\n                var node = finishedWork;\r\n                while (true) {\r\n                    if (node.tag === HostComponent) {\r\n                        var instance = node.stateNode;\r\n                        if (isHidden) {\r\n                            hideInstance(instance);\r\n                        }\r\n                        else {\r\n                            unhideInstance(node.stateNode, node.memoizedProps);\r\n                        }\r\n                    }\r\n                    else if (node.tag === HostText) {\r\n                        var _instance3 = node.stateNode;\r\n                        if (isHidden) {\r\n                            hideTextInstance(_instance3);\r\n                        }\r\n                        else {\r\n                            unhideTextInstance(_instance3, node.memoizedProps);\r\n                        }\r\n                    }\r\n                    else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)\r\n                        ;\r\n                    else if (node.child !== null) {\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                        continue;\r\n                    }\r\n                    if (node === finishedWork) {\r\n                        return;\r\n                    }\r\n                    while (node.sibling === null) {\r\n                        if (node.return === null || node.return === finishedWork) {\r\n                            return;\r\n                        }\r\n                        node = node.return;\r\n                    }\r\n                    node.sibling.return = node.return;\r\n                    node = node.sibling;\r\n                }\r\n            }\r\n        }\r\n        function commitAttachRef(finishedWork) {\r\n            var ref = finishedWork.ref;\r\n            if (ref !== null) {\r\n                var instance = finishedWork.stateNode;\r\n                var instanceToUse;\r\n                switch (finishedWork.tag) {\r\n                    case HostComponent:\r\n                        instanceToUse = getPublicInstance(instance);\r\n                        break;\r\n                    default:\r\n                        instanceToUse = instance;\r\n                } // Moved outside to ensure DCE works with this flag\r\n                if (typeof ref === 'function') {\r\n                    ref(instanceToUse);\r\n                }\r\n                else {\r\n                    {\r\n                        if (!ref.hasOwnProperty('current')) {\r\n                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentName(finishedWork.type));\r\n                        }\r\n                    }\r\n                    ref.current = instanceToUse;\r\n                }\r\n            }\r\n        }\r\n        function commitDetachRef(current) {\r\n            var currentRef = current.ref;\r\n            if (currentRef !== null) {\r\n                if (typeof currentRef === 'function') {\r\n                    currentRef(null);\r\n                }\r\n                else {\r\n                    currentRef.current = null;\r\n                }\r\n            }\r\n        } // User-originating errors (lifecycles and refs) should not interrupt\r\n        // deletion, so don't let them throw. Host-originating errors should\r\n        // interrupt deletion, so it's okay\r\n        function commitUnmount(finishedRoot, current, renderPriorityLevel) {\r\n            onCommitUnmount(current);\r\n            switch (current.tag) {\r\n                case FunctionComponent:\r\n                case ForwardRef:\r\n                case MemoComponent:\r\n                case SimpleMemoComponent:\r\n                case Block:\r\n                    {\r\n                        var updateQueue = current.updateQueue;\r\n                        if (updateQueue !== null) {\r\n                            var lastEffect = updateQueue.lastEffect;\r\n                            if (lastEffect !== null) {\r\n                                var firstEffect = lastEffect.next;\r\n                                var effect = firstEffect;\r\n                                do {\r\n                                    var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;\r\n                                    if (destroy !== undefined) {\r\n                                        if ((tag & Passive$1) !== NoFlags$1) {\r\n                                            enqueuePendingPassiveHookEffectUnmount(current, effect);\r\n                                        }\r\n                                        else {\r\n                                            {\r\n                                                safelyCallDestroy(current, destroy);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    effect = effect.next;\r\n                                } while (effect !== firstEffect);\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        safelyDetachRef(current);\r\n                        var instance = current.stateNode;\r\n                        if (typeof instance.componentWillUnmount === 'function') {\r\n                            safelyCallComponentWillUnmount(current, instance);\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        safelyDetachRef(current);\r\n                        return;\r\n                    }\r\n                case HostPortal:\r\n                    {\r\n                        // TODO: this is recursive.\r\n                        // We are also not using this parent because\r\n                        // the portal will get pushed immediately.\r\n                        {\r\n                            unmountHostComponents(finishedRoot, current);\r\n                        }\r\n                        return;\r\n                    }\r\n                case FundamentalComponent:\r\n                    {\r\n                        return;\r\n                    }\r\n                case DehydratedFragment:\r\n                    {\r\n                        return;\r\n                    }\r\n                case ScopeComponent:\r\n                    {\r\n                        return;\r\n                    }\r\n            }\r\n        }\r\n        function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {\r\n            // While we're inside a removed host node we don't want to call\r\n            // removeChild on the inner nodes because they're removed by the top\r\n            // call anyway. We also want to call componentWillUnmount on all\r\n            // composites before this host node is removed from the tree. Therefore\r\n            // we do an inner loop while we're still inside the host node.\r\n            var node = root;\r\n            while (true) {\r\n                commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.\r\n                // Skip portals because commitUnmount() currently visits them recursively.\r\n                if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\r\n                // If we don't use mutation we drill down into portals here instead.\r\n                node.tag !== HostPortal)) {\r\n                    node.child.return = node;\r\n                    node = node.child;\r\n                    continue;\r\n                }\r\n                if (node === root) {\r\n                    return;\r\n                }\r\n                while (node.sibling === null) {\r\n                    if (node.return === null || node.return === root) {\r\n                        return;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            }\r\n        }\r\n        function detachFiberMutation(fiber) {\r\n            // Cut off the return pointers to disconnect it from the tree. Ideally, we\r\n            // should clear the child pointer of the parent alternate to let this\r\n            // get GC:ed but we don't know which for sure which parent is the current\r\n            // one so we'll settle for GC:ing the subtree of this child. This child\r\n            // itself will be GC:ed when the parent updates the next time.\r\n            // Note: we cannot null out sibling here, otherwise it can cause issues\r\n            // with findDOMNode and how it requires the sibling field to carry out\r\n            // traversal in a later effect. See PR #16820. We now clear the sibling\r\n            // field after effects, see: detachFiberAfterEffects.\r\n            //\r\n            // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.\r\n            // It may be required if the current component is an error boundary,\r\n            // and one of its descendants throws while unmounting a passive effect.\r\n            fiber.alternate = null;\r\n            fiber.child = null;\r\n            fiber.dependencies = null;\r\n            fiber.firstEffect = null;\r\n            fiber.lastEffect = null;\r\n            fiber.memoizedProps = null;\r\n            fiber.memoizedState = null;\r\n            fiber.pendingProps = null;\r\n            fiber.return = null;\r\n            fiber.updateQueue = null;\r\n            {\r\n                fiber._debugOwner = null;\r\n            }\r\n        }\r\n        function getHostParentFiber(fiber) {\r\n            var parent = fiber.return;\r\n            while (parent !== null) {\r\n                if (isHostParent(parent)) {\r\n                    return parent;\r\n                }\r\n                parent = parent.return;\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function isHostParent(fiber) {\r\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\r\n        }\r\n        function getHostSibling(fiber) {\r\n            // We're going to search forward into the tree until we find a sibling host\r\n            // node. Unfortunately, if multiple insertions are done in a row we have to\r\n            // search past them. This leads to exponential search for the next sibling.\r\n            // TODO: Find a more efficient way to do this.\r\n            var node = fiber;\r\n            siblings: while (true) {\r\n                // If we didn't find anything, let's try the next sibling.\r\n                while (node.sibling === null) {\r\n                    if (node.return === null || isHostParent(node.return)) {\r\n                        // If we pop out of the root or hit the parent the fiber we are the\r\n                        // last sibling.\r\n                        return null;\r\n                    }\r\n                    node = node.return;\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\r\n                    // If it is not host node and, we might have a host node inside it.\r\n                    // Try to search down until we find one.\r\n                    if (node.flags & Placement) {\r\n                        // If we don't have a child, try the siblings instead.\r\n                        continue siblings;\r\n                    } // If we don't have a child, try the siblings instead.\r\n                    // We also skip portals because they are not part of this host tree.\r\n                    if (node.child === null || node.tag === HostPortal) {\r\n                        continue siblings;\r\n                    }\r\n                    else {\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                    }\r\n                } // Check if this host node is stable or about to be placed.\r\n                if (!(node.flags & Placement)) {\r\n                    // Found it!\r\n                    return node.stateNode;\r\n                }\r\n            }\r\n        }\r\n        function commitPlacement(finishedWork) {\r\n            var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\r\n            var parent;\r\n            var isContainer;\r\n            var parentStateNode = parentFiber.stateNode;\r\n            switch (parentFiber.tag) {\r\n                case HostComponent:\r\n                    parent = parentStateNode;\r\n                    isContainer = false;\r\n                    break;\r\n                case HostRoot:\r\n                    parent = parentStateNode.containerInfo;\r\n                    isContainer = true;\r\n                    break;\r\n                case HostPortal:\r\n                    parent = parentStateNode.containerInfo;\r\n                    isContainer = true;\r\n                    break;\r\n                case FundamentalComponent:\r\n                // eslint-disable-next-line-no-fallthrough\r\n                default:\r\n                    {\r\n                        {\r\n                            throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n            }\r\n            if (parentFiber.flags & ContentReset) {\r\n                // Reset the text content of the parent before doing any insertions\r\n                resetTextContent(parent); // Clear ContentReset from the effect tag\r\n                parentFiber.flags &= ~ContentReset;\r\n            }\r\n            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\r\n            // children to find all the terminal nodes.\r\n            if (isContainer) {\r\n                insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\r\n            }\r\n            else {\r\n                insertOrAppendPlacementNode(finishedWork, before, parent);\r\n            }\r\n        }\r\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\r\n            var tag = node.tag;\r\n            var isHost = tag === HostComponent || tag === HostText;\r\n            if (isHost || enableFundamentalAPI) {\r\n                var stateNode = isHost ? node.stateNode : node.stateNode.instance;\r\n                if (before) {\r\n                    insertInContainerBefore(parent, stateNode, before);\r\n                }\r\n                else {\r\n                    appendChildToContainer(parent, stateNode);\r\n                }\r\n            }\r\n            else if (tag === HostPortal)\r\n                ;\r\n            else {\r\n                var child = node.child;\r\n                if (child !== null) {\r\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\r\n                    var sibling = child.sibling;\r\n                    while (sibling !== null) {\r\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\r\n                        sibling = sibling.sibling;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function insertOrAppendPlacementNode(node, before, parent) {\r\n            var tag = node.tag;\r\n            var isHost = tag === HostComponent || tag === HostText;\r\n            if (isHost || enableFundamentalAPI) {\r\n                var stateNode = isHost ? node.stateNode : node.stateNode.instance;\r\n                if (before) {\r\n                    insertBefore(parent, stateNode, before);\r\n                }\r\n                else {\r\n                    appendChild(parent, stateNode);\r\n                }\r\n            }\r\n            else if (tag === HostPortal)\r\n                ;\r\n            else {\r\n                var child = node.child;\r\n                if (child !== null) {\r\n                    insertOrAppendPlacementNode(child, before, parent);\r\n                    var sibling = child.sibling;\r\n                    while (sibling !== null) {\r\n                        insertOrAppendPlacementNode(sibling, before, parent);\r\n                        sibling = sibling.sibling;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {\r\n            // We only have the top Fiber that was deleted but we need to recurse down its\r\n            // children to find all the terminal nodes.\r\n            var node = current; // Each iteration, currentParent is populated with node's host parent if not\r\n            // currentParentIsValid.\r\n            var currentParentIsValid = false; // Note: these two variables *must* always be updated together.\r\n            var currentParent;\r\n            var currentParentIsContainer;\r\n            while (true) {\r\n                if (!currentParentIsValid) {\r\n                    var parent = node.return;\r\n                    findParent: while (true) {\r\n                        if (!(parent !== null)) {\r\n                            {\r\n                                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\r\n                            }\r\n                        }\r\n                        var parentStateNode = parent.stateNode;\r\n                        switch (parent.tag) {\r\n                            case HostComponent:\r\n                                currentParent = parentStateNode;\r\n                                currentParentIsContainer = false;\r\n                                break findParent;\r\n                            case HostRoot:\r\n                                currentParent = parentStateNode.containerInfo;\r\n                                currentParentIsContainer = true;\r\n                                break findParent;\r\n                            case HostPortal:\r\n                                currentParent = parentStateNode.containerInfo;\r\n                                currentParentIsContainer = true;\r\n                                break findParent;\r\n                        }\r\n                        parent = parent.return;\r\n                    }\r\n                    currentParentIsValid = true;\r\n                }\r\n                if (node.tag === HostComponent || node.tag === HostText) {\r\n                    commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the\r\n                    // node from the tree.\r\n                    if (currentParentIsContainer) {\r\n                        removeChildFromContainer(currentParent, node.stateNode);\r\n                    }\r\n                    else {\r\n                        removeChild(currentParent, node.stateNode);\r\n                    } // Don't visit children because we already visited them.\r\n                }\r\n                else if (node.tag === HostPortal) {\r\n                    if (node.child !== null) {\r\n                        // When we go into a portal, it becomes the parent to remove from.\r\n                        // We will reassign it back when we pop the portal on the way up.\r\n                        currentParent = node.stateNode.containerInfo;\r\n                        currentParentIsContainer = true; // Visit children because portals might contain host components.\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.\r\n                    if (node.child !== null) {\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (node === current) {\r\n                    return;\r\n                }\r\n                while (node.sibling === null) {\r\n                    if (node.return === null || node.return === current) {\r\n                        return;\r\n                    }\r\n                    node = node.return;\r\n                    if (node.tag === HostPortal) {\r\n                        // When we go out of the portal, we need to restore the parent.\r\n                        // Since we don't keep a stack of them, we will search for it.\r\n                        currentParentIsValid = false;\r\n                    }\r\n                }\r\n                node.sibling.return = node.return;\r\n                node = node.sibling;\r\n            }\r\n        }\r\n        function commitDeletion(finishedRoot, current, renderPriorityLevel) {\r\n            {\r\n                // Recursively delete all host nodes from the parent.\r\n                // Detach refs and call componentWillUnmount() on the whole subtree.\r\n                unmountHostComponents(finishedRoot, current);\r\n            }\r\n            var alternate = current.alternate;\r\n            detachFiberMutation(current);\r\n            if (alternate !== null) {\r\n                detachFiberMutation(alternate);\r\n            }\r\n        }\r\n        function commitWork(current, finishedWork) {\r\n            switch (finishedWork.tag) {\r\n                case FunctionComponent:\r\n                case ForwardRef:\r\n                case MemoComponent:\r\n                case SimpleMemoComponent:\r\n                case Block:\r\n                    {\r\n                        // Layout effects are destroyed during the mutation phase so that all\r\n                        // destroy functions for all fibers are called before any create functions.\r\n                        // This prevents sibling component effects from interfering with each other,\r\n                        // e.g. a destroy function in one component should never override a ref set\r\n                        // by a create function in another component during the same commit.\r\n                        {\r\n                            commitHookEffectListUnmount(Layout | HasEffect, finishedWork);\r\n                        }\r\n                        return;\r\n                    }\r\n                case ClassComponent:\r\n                    {\r\n                        return;\r\n                    }\r\n                case HostComponent:\r\n                    {\r\n                        var instance = finishedWork.stateNode;\r\n                        if (instance != null) {\r\n                            // Commit the work prepared earlier.\r\n                            var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\r\n                            // as the newProps. The updatePayload will contain the real change in\r\n                            // this case.\r\n                            var oldProps = current !== null ? current.memoizedProps : newProps;\r\n                            var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\r\n                            var updatePayload = finishedWork.updateQueue;\r\n                            finishedWork.updateQueue = null;\r\n                            if (updatePayload !== null) {\r\n                                commitUpdate(instance, updatePayload, type, oldProps, newProps);\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case HostText:\r\n                    {\r\n                        if (!(finishedWork.stateNode !== null)) {\r\n                            {\r\n                                throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\r\n                            }\r\n                        }\r\n                        var textInstance = finishedWork.stateNode;\r\n                        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\r\n                        // as the newProps. The updatePayload will contain the real change in\r\n                        // this case.\r\n                        var oldText = current !== null ? current.memoizedProps : newText;\r\n                        commitTextUpdate(textInstance, oldText, newText);\r\n                        return;\r\n                    }\r\n                case HostRoot:\r\n                    {\r\n                        {\r\n                            var _root = finishedWork.stateNode;\r\n                            if (_root.hydrate) {\r\n                                // We've just hydrated. No need to hydrate again.\r\n                                _root.hydrate = false;\r\n                                commitHydratedContainer(_root.containerInfo);\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                case Profiler:\r\n                    {\r\n                        return;\r\n                    }\r\n                case SuspenseComponent:\r\n                    {\r\n                        commitSuspenseComponent(finishedWork);\r\n                        attachSuspenseRetryListeners(finishedWork);\r\n                        return;\r\n                    }\r\n                case SuspenseListComponent:\r\n                    {\r\n                        attachSuspenseRetryListeners(finishedWork);\r\n                        return;\r\n                    }\r\n                case IncompleteClassComponent:\r\n                    {\r\n                        return;\r\n                    }\r\n                case FundamentalComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case ScopeComponent:\r\n                    {\r\n                        break;\r\n                    }\r\n                case OffscreenComponent:\r\n                case LegacyHiddenComponent:\r\n                    {\r\n                        var newState = finishedWork.memoizedState;\r\n                        var isHidden = newState !== null;\r\n                        hideOrUnhideAllChildren(finishedWork, isHidden);\r\n                        return;\r\n                    }\r\n            }\r\n            {\r\n                {\r\n                    throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            }\r\n        }\r\n        function commitSuspenseComponent(finishedWork) {\r\n            var newState = finishedWork.memoizedState;\r\n            if (newState !== null) {\r\n                markCommitTimeOfFallback();\r\n                {\r\n                    // Hide the Offscreen component that contains the primary children. TODO:\r\n                    // Ideally, this effect would have been scheduled on the Offscreen fiber\r\n                    // itself. That's how unhiding works: the Offscreen component schedules an\r\n                    // effect on itself. However, in this case, the component didn't complete,\r\n                    // so the fiber was never added to the effect list in the normal path. We\r\n                    // could have appended it to the effect list in the Suspense component's\r\n                    // second pass, but doing it this way is less complicated. This would be\r\n                    // simpler if we got rid of the effect list and traversed the tree, like\r\n                    // we're planning to do.\r\n                    var primaryChildParent = finishedWork.child;\r\n                    hideOrUnhideAllChildren(primaryChildParent, true);\r\n                }\r\n            }\r\n        }\r\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\r\n            var newState = finishedWork.memoizedState;\r\n            if (newState === null) {\r\n                var current = finishedWork.alternate;\r\n                if (current !== null) {\r\n                    var prevState = current.memoizedState;\r\n                    if (prevState !== null) {\r\n                        var suspenseInstance = prevState.dehydrated;\r\n                        if (suspenseInstance !== null) {\r\n                            commitHydratedSuspenseInstance(suspenseInstance);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function attachSuspenseRetryListeners(finishedWork) {\r\n            // If this boundary just timed out, then it will have a set of wakeables.\r\n            // For each wakeable, attach a listener so that when it resolves, React\r\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\r\n            var wakeables = finishedWork.updateQueue;\r\n            if (wakeables !== null) {\r\n                finishedWork.updateQueue = null;\r\n                var retryCache = finishedWork.stateNode;\r\n                if (retryCache === null) {\r\n                    retryCache = finishedWork.stateNode = new PossiblyWeakSet();\r\n                }\r\n                wakeables.forEach(function (wakeable) {\r\n                    // Memoize using the boundary fiber to prevent redundant listeners.\r\n                    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\r\n                    if (!retryCache.has(wakeable)) {\r\n                        {\r\n                            if (wakeable.__reactDoNotTraceInteractions !== true) {\r\n                                retry = tracing.unstable_wrap(retry);\r\n                            }\r\n                        }\r\n                        retryCache.add(wakeable);\r\n                        wakeable.then(retry, retry);\r\n                    }\r\n                });\r\n            }\r\n        } // This function detects when a Suspense boundary goes from visible to hidden.\r\n        // It returns false if the boundary is already hidden.\r\n        // TODO: Use an effect tag.\r\n        function isSuspenseBoundaryBeingHidden(current, finishedWork) {\r\n            if (current !== null) {\r\n                var oldState = current.memoizedState;\r\n                if (oldState === null || oldState.dehydrated !== null) {\r\n                    var newState = finishedWork.memoizedState;\r\n                    return newState !== null && newState.dehydrated === null;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function commitResetTextContent(current) {\r\n            resetTextContent(current.stateNode);\r\n        }\r\n        var COMPONENT_TYPE = 0;\r\n        var HAS_PSEUDO_CLASS_TYPE = 1;\r\n        var ROLE_TYPE = 2;\r\n        var TEST_NAME_TYPE = 3;\r\n        var TEXT_TYPE = 4;\r\n        if (typeof Symbol === 'function' && Symbol.for) {\r\n            var symbolFor$1 = Symbol.for;\r\n            COMPONENT_TYPE = symbolFor$1('selector.component');\r\n            HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');\r\n            ROLE_TYPE = symbolFor$1('selector.role');\r\n            TEST_NAME_TYPE = symbolFor$1('selector.test_id');\r\n            TEXT_TYPE = symbolFor$1('selector.text');\r\n        }\r\n        var commitHooks = [];\r\n        function onCommitRoot$1() {\r\n            {\r\n                commitHooks.forEach(function (commitHook) {\r\n                    return commitHook();\r\n                });\r\n            }\r\n        }\r\n        var ceil = Math.ceil;\r\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;\r\n        var NoContext = \r\n        /*             */\r\n        0;\r\n        var BatchedContext = \r\n        /*               */\r\n        1;\r\n        var EventContext = \r\n        /*                 */\r\n        2;\r\n        var DiscreteEventContext = \r\n        /*         */\r\n        4;\r\n        var LegacyUnbatchedContext = \r\n        /*       */\r\n        8;\r\n        var RenderContext = \r\n        /*                */\r\n        16;\r\n        var CommitContext = \r\n        /*                */\r\n        32;\r\n        var RetryAfterError = \r\n        /*       */\r\n        64;\r\n        var RootIncomplete = 0;\r\n        var RootFatalErrored = 1;\r\n        var RootErrored = 2;\r\n        var RootSuspended = 3;\r\n        var RootSuspendedWithDelay = 4;\r\n        var RootCompleted = 5; // Describes where we are in the React execution stack\r\n        var executionContext = NoContext; // The root we're working on\r\n        var workInProgressRoot = null; // The fiber we're working on\r\n        var workInProgress = null; // The lanes we're rendering\r\n        var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\r\n        // This is a superset of the lanes we started working on at the root. The only\r\n        // case where it's different from `workInProgressRootRenderLanes` is when we\r\n        // enter a subtree that is hidden and needs to be unhidden: Suspense and\r\n        // Offscreen component.\r\n        //\r\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\r\n        // Most things in begin/complete phases should deal with subtreeRenderLanes.\r\n        var subtreeRenderLanes = NoLanes;\r\n        var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\r\n        var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown\r\n        var workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\r\n        // slightly different than `renderLanes` because `renderLanes` can change as you\r\n        // enter and exit an Offscreen tree. This value is the combination of all render\r\n        // lanes for the entire render phase.\r\n        var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\r\n        // includes unprocessed updates, not work in bailed out children.\r\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\r\n        var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.\r\n        var workInProgressRootPingedLanes = NoLanes;\r\n        var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train\r\n        // model where we don't commit new loading states in too quick succession.\r\n        var globalMostRecentFallbackTime = 0;\r\n        var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\r\n        // more and prefer CPU suspense heuristics instead.\r\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\r\n        // suspense heuristics and opt out of rendering more content.\r\n        var RENDER_TIMEOUT_MS = 500;\r\n        function resetRenderTimer() {\r\n            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\r\n        }\r\n        function getRenderTargetTime() {\r\n            return workInProgressRootRenderTargetTime;\r\n        }\r\n        var nextEffect = null;\r\n        var hasUncaughtError = false;\r\n        var firstUncaughtError = null;\r\n        var legacyErrorBoundariesThatAlreadyFailed = null;\r\n        var rootDoesHavePassiveEffects = false;\r\n        var rootWithPendingPassiveEffects = null;\r\n        var pendingPassiveEffectsRenderPriority = NoPriority$1;\r\n        var pendingPassiveEffectsLanes = NoLanes;\r\n        var pendingPassiveHookEffectsMount = [];\r\n        var pendingPassiveHookEffectsUnmount = [];\r\n        var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates\r\n        var NESTED_UPDATE_LIMIT = 50;\r\n        var nestedUpdateCount = 0;\r\n        var rootWithNestedUpdates = null;\r\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\r\n        var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes\r\n        // during the commit phase. This enables them to be traced across components\r\n        // that spawn new work during render. E.g. hidden boundaries, suspended SSR\r\n        // hydration or SuspenseList.\r\n        // TODO: Can use a bitmask instead of an array\r\n        var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their\r\n        // event times as simultaneous, even if the actual clock time has advanced\r\n        // between the first and second call.\r\n        var currentEventTime = NoTimestamp;\r\n        var currentEventWipLanes = NoLanes;\r\n        var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.\r\n        // We warn about state updates for unmounted components differently in this case.\r\n        var isFlushingPassiveEffects = false;\r\n        var focusedInstanceHandle = null;\r\n        var shouldFireAfterActiveInstanceBlur = false;\r\n        function getWorkInProgressRoot() {\r\n            return workInProgressRoot;\r\n        }\r\n        function requestEventTime() {\r\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n                // We're inside React, so it's fine to read the actual time.\r\n                return now();\r\n            } // We're not inside React, so we may be in the middle of a browser event.\r\n            if (currentEventTime !== NoTimestamp) {\r\n                // Use the same start time for all updates until we enter React again.\r\n                return currentEventTime;\r\n            } // This is the first update since React yielded. Compute a new start time.\r\n            currentEventTime = now();\r\n            return currentEventTime;\r\n        }\r\n        function requestUpdateLane(fiber) {\r\n            // Special cases\r\n            var mode = fiber.mode;\r\n            if ((mode & BlockingMode) === NoMode) {\r\n                return SyncLane;\r\n            }\r\n            else if ((mode & ConcurrentMode) === NoMode) {\r\n                return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;\r\n            } // The algorithm for assigning an update to a lane should be stable for all\r\n            // updates at the same priority within the same event. To do this, the inputs\r\n            // to the algorithm must be the same. For example, we use the `renderLanes`\r\n            // to avoid choosing a lane that is already in the middle of rendering.\r\n            //\r\n            // However, the \"included\" lanes could be mutated in between updates in the\r\n            // same event, like if you perform an update inside `flushSync`. Or any other\r\n            // code path that might call `prepareFreshStack`.\r\n            //\r\n            // The trick we use is to cache the first of each of these inputs within an\r\n            // event. Then reset the cached values once we can be sure the event is over.\r\n            // Our heuristic for that is whenever we enter a concurrent work loop.\r\n            //\r\n            // We'll do the same for `currentEventPendingLanes` below.\r\n            if (currentEventWipLanes === NoLanes) {\r\n                currentEventWipLanes = workInProgressRootIncludedLanes;\r\n            }\r\n            var isTransition = requestCurrentTransition() !== NoTransition;\r\n            if (isTransition) {\r\n                if (currentEventPendingLanes !== NoLanes) {\r\n                    currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;\r\n                }\r\n                return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);\r\n            } // TODO: Remove this dependency on the Scheduler priority.\r\n            // To do that, we're replacing it with an update lane priority.\r\n            var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.\r\n            // This couples React to the Scheduler internals, so we're replacing it\r\n            // with the currentUpdateLanePriority above. As an example of how this\r\n            // could be problematic, if we're not inside `Scheduler.runWithPriority`,\r\n            // then we'll get the priority of the current running Scheduler task,\r\n            // which is probably not what we want.\r\n            var lane;\r\n            if ( // TODO: Temporary. We're removing the concept of discrete updates.\r\n            (executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {\r\n                lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);\r\n            }\r\n            else {\r\n                var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);\r\n                lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);\r\n            }\r\n            return lane;\r\n        }\r\n        function requestRetryLane(fiber) {\r\n            // This is a fork of `requestUpdateLane` designed specifically for Suspense\r\n            // \"retries\" — a special update that attempts to flip a Suspense boundary\r\n            // from its placeholder state to its primary/resolved state.\r\n            // Special cases\r\n            var mode = fiber.mode;\r\n            if ((mode & BlockingMode) === NoMode) {\r\n                return SyncLane;\r\n            }\r\n            else if ((mode & ConcurrentMode) === NoMode) {\r\n                return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;\r\n            } // See `requestUpdateLane` for explanation of `currentEventWipLanes`\r\n            if (currentEventWipLanes === NoLanes) {\r\n                currentEventWipLanes = workInProgressRootIncludedLanes;\r\n            }\r\n            return findRetryLane(currentEventWipLanes);\r\n        }\r\n        function scheduleUpdateOnFiber(fiber, lane, eventTime) {\r\n            checkForNestedUpdates();\r\n            warnAboutRenderPhaseUpdatesInDEV(fiber);\r\n            var root = markUpdateLaneFromFiberToRoot(fiber, lane);\r\n            if (root === null) {\r\n                warnAboutUpdateOnUnmountedFiberInDEV(fiber);\r\n                return null;\r\n            } // Mark that the root has a pending update.\r\n            markRootUpdated(root, lane, eventTime);\r\n            if (root === workInProgressRoot) {\r\n                // Received an update to a tree that's in the middle of rendering. Mark\r\n                // that there was an interleaved update work on this root. Unless the\r\n                // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\r\n                // phase update. In that case, we don't treat render phase updates as if\r\n                // they were interleaved, for backwards compat reasons.\r\n                {\r\n                    workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);\r\n                }\r\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\r\n                    // The root already suspended with a delay, which means this render\r\n                    // definitely won't finish. Since we have a new update, let's mark it as\r\n                    // suspended now, right before marking the incoming update. This has the\r\n                    // effect of interrupting the current render and switching to the update.\r\n                    // TODO: Make sure this doesn't override pings that happen while we've\r\n                    // already started rendering.\r\n                    markRootSuspended$1(root, workInProgressRootRenderLanes);\r\n                }\r\n            } // TODO: requestUpdateLanePriority also reads the priority. Pass the\r\n            // priority as an argument to that function and this one.\r\n            var priorityLevel = getCurrentPriorityLevel();\r\n            if (lane === SyncLane) {\r\n                if ( // Check if we're inside unbatchedUpdates\r\n                (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering\r\n                    (executionContext & (RenderContext | CommitContext)) === NoContext) {\r\n                    // Register pending interactions on the root to avoid losing traced interaction data.\r\n                    schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\r\n                    // root inside of batchedUpdates should be synchronous, but layout updates\r\n                    // should be deferred until the end of the batch.\r\n                    performSyncWorkOnRoot(root);\r\n                }\r\n                else {\r\n                    ensureRootIsScheduled(root, eventTime);\r\n                    schedulePendingInteractions(root, lane);\r\n                    if (executionContext === NoContext) {\r\n                        // Flush the synchronous work now, unless we're already working or inside\r\n                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\r\n                        // scheduleCallbackForFiber to preserve the ability to schedule a callback\r\n                        // without immediately flushing it. We only do this for user-initiated\r\n                        // updates, to preserve historical behavior of legacy mode.\r\n                        resetRenderTimer();\r\n                        flushSyncCallbackQueue();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Schedule a discrete update but only if it's not Sync.\r\n                if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered\r\n                // discrete, even inside a discrete event.\r\n                priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {\r\n                    // This is the result of a discrete event. Track the lowest priority\r\n                    // discrete update per root so we can flush them early, if needed.\r\n                    if (rootsWithPendingDiscreteUpdates === null) {\r\n                        rootsWithPendingDiscreteUpdates = new Set([root]);\r\n                    }\r\n                    else {\r\n                        rootsWithPendingDiscreteUpdates.add(root);\r\n                    }\r\n                } // Schedule other updates after in case the callback is sync.\r\n                ensureRootIsScheduled(root, eventTime);\r\n                schedulePendingInteractions(root, lane);\r\n            } // We use this when assigning a lane for a transition inside\r\n            // `requestUpdateLane`. We assume it's the same as the root being updated,\r\n            // since in the common case of a single root app it probably is. If it's not\r\n            // the same root, then it's not a huge deal, we just might batch more stuff\r\n            // together more than necessary.\r\n            mostRecentlyUpdatedRoot = root;\r\n        } // This is split into a separate function so we can mark a fiber with pending\r\n        // work without treating it as a typical update that originates from an event;\r\n        // e.g. retrying a Suspense boundary isn't an update, but it does schedule work\r\n        // on a fiber.\r\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\r\n            // Update the source fiber's lanes\r\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\r\n            var alternate = sourceFiber.alternate;\r\n            if (alternate !== null) {\r\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\r\n            }\r\n            {\r\n                if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\r\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n                }\r\n            } // Walk the parent path to the root and update the child expiration time.\r\n            var node = sourceFiber;\r\n            var parent = sourceFiber.return;\r\n            while (parent !== null) {\r\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\r\n                alternate = parent.alternate;\r\n                if (alternate !== null) {\r\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\r\n                }\r\n                else {\r\n                    {\r\n                        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\r\n                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\r\n                        }\r\n                    }\r\n                }\r\n                node = parent;\r\n                parent = parent.return;\r\n            }\r\n            if (node.tag === HostRoot) {\r\n                var root = node.stateNode;\r\n                return root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        } // Use this function to schedule a task for a root. There's only one task per\r\n        // root; if a task was already scheduled, we'll check to make sure the priority\r\n        // of the existing task is the same as the priority of the next level that the\r\n        // root has work on. This function is called on every update, and right before\r\n        // exiting a task.\r\n        function ensureRootIsScheduled(root, currentTime) {\r\n            var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\r\n            // expired so we know to work on those next.\r\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\r\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.\r\n            var newCallbackPriority = returnNextLanesPriority();\r\n            if (nextLanes === NoLanes) {\r\n                // Special case: There's nothing to work on.\r\n                if (existingCallbackNode !== null) {\r\n                    cancelCallback(existingCallbackNode);\r\n                    root.callbackNode = null;\r\n                    root.callbackPriority = NoLanePriority;\r\n                }\r\n                return;\r\n            } // Check if there's an existing task. We may be able to reuse it.\r\n            if (existingCallbackNode !== null) {\r\n                var existingCallbackPriority = root.callbackPriority;\r\n                if (existingCallbackPriority === newCallbackPriority) {\r\n                    // The priority hasn't changed. We can reuse the existing task. Exit.\r\n                    return;\r\n                } // The priority changed. Cancel the existing callback. We'll schedule a new\r\n                // one below.\r\n                cancelCallback(existingCallbackNode);\r\n            } // Schedule a new callback.\r\n            var newCallbackNode;\r\n            if (newCallbackPriority === SyncLanePriority) {\r\n                // Special case: Sync React callbacks are scheduled on a special\r\n                // internal queue\r\n                newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\r\n            }\r\n            else if (newCallbackPriority === SyncBatchedLanePriority) {\r\n                newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));\r\n            }\r\n            else {\r\n                var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);\r\n                newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\r\n            }\r\n            root.callbackPriority = newCallbackPriority;\r\n            root.callbackNode = newCallbackNode;\r\n        } // This is the entry point for every concurrent task, i.e. anything that\r\n        // goes through Scheduler.\r\n        function performConcurrentWorkOnRoot(root) {\r\n            // Since we know we're in a React event, we can clear the current\r\n            // event time. The next update will compute a new event time.\r\n            currentEventTime = NoTimestamp;\r\n            currentEventWipLanes = NoLanes;\r\n            currentEventPendingLanes = NoLanes;\r\n            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {\r\n                {\r\n                    throw Error(\"Should not already be working.\");\r\n                }\r\n            } // Flush any pending passive effects before deciding which lanes to work on,\r\n            // in case they schedule additional work.\r\n            var originalCallbackNode = root.callbackNode;\r\n            var didFlushPassiveEffects = flushPassiveEffects();\r\n            if (didFlushPassiveEffects) {\r\n                // Something in the passive effect phase may have canceled the current task.\r\n                // Check if the task node for this root was changed.\r\n                if (root.callbackNode !== originalCallbackNode) {\r\n                    // The current task was canceled. Exit. We don't need to call\r\n                    // `ensureRootIsScheduled` because the check above implies either that\r\n                    // there's a new task, or that there's no remaining work on this root.\r\n                    return null;\r\n                }\r\n            } // Determine the next expiration time to work on, using the fields stored\r\n            // on the root.\r\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\r\n            if (lanes === NoLanes) {\r\n                // Defensive coding. This is never expected to happen.\r\n                return null;\r\n            }\r\n            var exitStatus = renderRootConcurrent(root, lanes);\r\n            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {\r\n                // The render included lanes that were updated during the render phase.\r\n                // For example, when unhiding a hidden tree, we include all the lanes\r\n                // that were previously skipped when the tree was hidden. That set of\r\n                // lanes is a superset of the lanes we started rendering with.\r\n                //\r\n                // So we'll throw out the current work and restart.\r\n                prepareFreshStack(root, NoLanes);\r\n            }\r\n            else if (exitStatus !== RootIncomplete) {\r\n                if (exitStatus === RootErrored) {\r\n                    executionContext |= RetryAfterError; // If an error occurred during hydration,\r\n                    // discard server response and fall back to client side render.\r\n                    if (root.hydrate) {\r\n                        root.hydrate = false;\r\n                        clearContainer(root.containerInfo);\r\n                    } // If something threw an error, try rendering one more time. We'll render\r\n                    // synchronously to block concurrent data mutations, and we'll includes\r\n                    // all pending updates are included. If it still fails after the second\r\n                    // attempt, we'll give up and commit the resulting tree.\r\n                    lanes = getLanesToRetrySynchronouslyOnError(root);\r\n                    if (lanes !== NoLanes) {\r\n                        exitStatus = renderRootSync(root, lanes);\r\n                    }\r\n                }\r\n                if (exitStatus === RootFatalErrored) {\r\n                    var fatalError = workInProgressRootFatalError;\r\n                    prepareFreshStack(root, NoLanes);\r\n                    markRootSuspended$1(root, lanes);\r\n                    ensureRootIsScheduled(root, now());\r\n                    throw fatalError;\r\n                } // We now have a consistent tree. The next step is either to commit it,\r\n                // or, if something suspended, wait to commit it after a timeout.\r\n                var finishedWork = root.current.alternate;\r\n                root.finishedWork = finishedWork;\r\n                root.finishedLanes = lanes;\r\n                finishConcurrentRender(root, exitStatus, lanes);\r\n            }\r\n            ensureRootIsScheduled(root, now());\r\n            if (root.callbackNode === originalCallbackNode) {\r\n                // The task node scheduled for this root is the same one that's\r\n                // currently executed. Need to return a continuation.\r\n                return performConcurrentWorkOnRoot.bind(null, root);\r\n            }\r\n            return null;\r\n        }\r\n        function finishConcurrentRender(root, exitStatus, lanes) {\r\n            switch (exitStatus) {\r\n                case RootIncomplete:\r\n                case RootFatalErrored:\r\n                    {\r\n                        {\r\n                            {\r\n                                throw Error(\"Root did not complete. This is a bug in React.\");\r\n                            }\r\n                        }\r\n                    }\r\n                // Flow knows about invariant, so it complains if I add a break\r\n                // statement, but eslint doesn't know about invariant, so it complains\r\n                // if I do. eslint-disable-next-line no-fallthrough\r\n                case RootErrored:\r\n                    {\r\n                        // We should have already attempted to retry this tree. If we reached\r\n                        // this point, it errored again. Commit it.\r\n                        commitRoot(root);\r\n                        break;\r\n                    }\r\n                case RootSuspended:\r\n                    {\r\n                        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\r\n                        // should immediately commit it or wait a bit.\r\n                        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\r\n                            !shouldForceFlushFallbacksInDEV()) {\r\n                            // This render only included retries, no updates. Throttle committing\r\n                            // retries so that we don't show too many loading states too quickly.\r\n                            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\r\n                            if (msUntilTimeout > 10) {\r\n                                var nextLanes = getNextLanes(root, NoLanes);\r\n                                if (nextLanes !== NoLanes) {\r\n                                    // There's additional work on this root.\r\n                                    break;\r\n                                }\r\n                                var suspendedLanes = root.suspendedLanes;\r\n                                if (!isSubsetOfLanes(suspendedLanes, lanes)) {\r\n                                    // We should prefer to render the fallback of at the last\r\n                                    // suspended level. Ping the last suspended level to try\r\n                                    // rendering it again.\r\n                                    // FIXME: What if the suspended lanes are Idle? Should not restart.\r\n                                    var eventTime = requestEventTime();\r\n                                    markRootPinged(root, suspendedLanes);\r\n                                    break;\r\n                                } // The render is suspended, it hasn't timed out, and there's no\r\n                                // lower priority work to do. Instead of committing the fallback\r\n                                // immediately, wait for more data to arrive.\r\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\r\n                                break;\r\n                            }\r\n                        } // The work expired. Commit immediately.\r\n                        commitRoot(root);\r\n                        break;\r\n                    }\r\n                case RootSuspendedWithDelay:\r\n                    {\r\n                        markRootSuspended$1(root, lanes);\r\n                        if (includesOnlyTransitions(lanes)) {\r\n                            // This is a transition, so we should exit without committing a\r\n                            // placeholder and without scheduling a timeout. Delay indefinitely\r\n                            // until we receive more data.\r\n                            break;\r\n                        }\r\n                        if (!shouldForceFlushFallbacksInDEV()) {\r\n                            // This is not a transition, but we did trigger an avoided state.\r\n                            // Schedule a placeholder to display after a short delay, using the Just\r\n                            // Noticeable Difference.\r\n                            // TODO: Is the JND optimization worth the added complexity? If this is\r\n                            // the only reason we track the event time, then probably not.\r\n                            // Consider removing.\r\n                            var mostRecentEventTime = getMostRecentEventTime(root, lanes);\r\n                            var eventTimeMs = mostRecentEventTime;\r\n                            var timeElapsedMs = now() - eventTimeMs;\r\n                            var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\r\n                            if (_msUntilTimeout > 10) {\r\n                                // Instead of committing the fallback immediately, wait for more data\r\n                                // to arrive.\r\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);\r\n                                break;\r\n                            }\r\n                        } // Commit the placeholder.\r\n                        commitRoot(root);\r\n                        break;\r\n                    }\r\n                case RootCompleted:\r\n                    {\r\n                        // The work completed. Ready to commit.\r\n                        commitRoot(root);\r\n                        break;\r\n                    }\r\n                default:\r\n                    {\r\n                        {\r\n                            {\r\n                                throw Error(\"Unknown root exit status.\");\r\n                            }\r\n                        }\r\n                    }\r\n            }\r\n        }\r\n        function markRootSuspended$1(root, suspendedLanes) {\r\n            // When suspending, we should always exclude lanes that were pinged or (more\r\n            // rarely, since we try to avoid it) updated during the render phase.\r\n            // TODO: Lol maybe there's a better way to factor this besides this\r\n            // obnoxiously named function :)\r\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\r\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);\r\n            markRootSuspended(root, suspendedLanes);\r\n        } // This is the entry point for synchronous tasks that don't go\r\n        // through Scheduler\r\n        function performSyncWorkOnRoot(root) {\r\n            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {\r\n                {\r\n                    throw Error(\"Should not already be working.\");\r\n                }\r\n            }\r\n            flushPassiveEffects();\r\n            var lanes;\r\n            var exitStatus;\r\n            if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {\r\n                // There's a partial tree, and at least one of its lanes has expired. Finish\r\n                // rendering it before rendering the rest of the expired work.\r\n                lanes = workInProgressRootRenderLanes;\r\n                exitStatus = renderRootSync(root, lanes);\r\n                if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {\r\n                    // The render included lanes that were updated during the render phase.\r\n                    // For example, when unhiding a hidden tree, we include all the lanes\r\n                    // that were previously skipped when the tree was hidden. That set of\r\n                    // lanes is a superset of the lanes we started rendering with.\r\n                    //\r\n                    // Note that this only happens when part of the tree is rendered\r\n                    // concurrently. If the whole tree is rendered synchronously, then there\r\n                    // are no interleaved events.\r\n                    lanes = getNextLanes(root, lanes);\r\n                    exitStatus = renderRootSync(root, lanes);\r\n                }\r\n            }\r\n            else {\r\n                lanes = getNextLanes(root, NoLanes);\r\n                exitStatus = renderRootSync(root, lanes);\r\n            }\r\n            if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\r\n                executionContext |= RetryAfterError; // If an error occurred during hydration,\r\n                // discard server response and fall back to client side render.\r\n                if (root.hydrate) {\r\n                    root.hydrate = false;\r\n                    clearContainer(root.containerInfo);\r\n                } // If something threw an error, try rendering one more time. We'll render\r\n                // synchronously to block concurrent data mutations, and we'll includes\r\n                // all pending updates are included. If it still fails after the second\r\n                // attempt, we'll give up and commit the resulting tree.\r\n                lanes = getLanesToRetrySynchronouslyOnError(root);\r\n                if (lanes !== NoLanes) {\r\n                    exitStatus = renderRootSync(root, lanes);\r\n                }\r\n            }\r\n            if (exitStatus === RootFatalErrored) {\r\n                var fatalError = workInProgressRootFatalError;\r\n                prepareFreshStack(root, NoLanes);\r\n                markRootSuspended$1(root, lanes);\r\n                ensureRootIsScheduled(root, now());\r\n                throw fatalError;\r\n            } // We now have a consistent tree. Because this is a sync render, we\r\n            // will commit it even if something suspended.\r\n            var finishedWork = root.current.alternate;\r\n            root.finishedWork = finishedWork;\r\n            root.finishedLanes = lanes;\r\n            commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next\r\n            // pending level.\r\n            ensureRootIsScheduled(root, now());\r\n            return null;\r\n        }\r\n        function flushDiscreteUpdates() {\r\n            // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\r\n            // However, `act` uses `batchedUpdates`, so there's no way to distinguish\r\n            // those two cases. Need to fix this before exposing flushDiscreteUpdates\r\n            // as a public API.\r\n            if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {\r\n                {\r\n                    if ((executionContext & RenderContext) !== NoContext) {\r\n                        error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');\r\n                    }\r\n                } // We're already rendering, so we can't synchronously flush pending work.\r\n                // This is probably a nested event dispatch triggered by a lifecycle/effect,\r\n                // like `el.focus()`. Exit.\r\n                return;\r\n            }\r\n            flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that\r\n            // they fire before the next serial event.\r\n            flushPassiveEffects();\r\n        }\r\n        function flushPendingDiscreteUpdates() {\r\n            if (rootsWithPendingDiscreteUpdates !== null) {\r\n                // For each root with pending discrete updates, schedule a callback to\r\n                // immediately flush them.\r\n                var roots = rootsWithPendingDiscreteUpdates;\r\n                rootsWithPendingDiscreteUpdates = null;\r\n                roots.forEach(function (root) {\r\n                    markDiscreteUpdatesExpired(root);\r\n                    ensureRootIsScheduled(root, now());\r\n                });\r\n            } // Now flush the immediate queue.\r\n            flushSyncCallbackQueue();\r\n        }\r\n        function batchedUpdates$1(fn, a) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= BatchedContext;\r\n            try {\r\n                return fn(a);\r\n            }\r\n            finally {\r\n                executionContext = prevExecutionContext;\r\n                if (executionContext === NoContext) {\r\n                    // Flush the immediate callbacks that were scheduled during this batch\r\n                    resetRenderTimer();\r\n                    flushSyncCallbackQueue();\r\n                }\r\n            }\r\n        }\r\n        function batchedEventUpdates$1(fn, a) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= EventContext;\r\n            try {\r\n                return fn(a);\r\n            }\r\n            finally {\r\n                executionContext = prevExecutionContext;\r\n                if (executionContext === NoContext) {\r\n                    // Flush the immediate callbacks that were scheduled during this batch\r\n                    resetRenderTimer();\r\n                    flushSyncCallbackQueue();\r\n                }\r\n            }\r\n        }\r\n        function discreteUpdates$1(fn, a, b, c, d) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= DiscreteEventContext;\r\n            {\r\n                try {\r\n                    return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));\r\n                }\r\n                finally {\r\n                    executionContext = prevExecutionContext;\r\n                    if (executionContext === NoContext) {\r\n                        // Flush the immediate callbacks that were scheduled during this batch\r\n                        resetRenderTimer();\r\n                        flushSyncCallbackQueue();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function unbatchedUpdates(fn, a) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext &= ~BatchedContext;\r\n            executionContext |= LegacyUnbatchedContext;\r\n            try {\r\n                return fn(a);\r\n            }\r\n            finally {\r\n                executionContext = prevExecutionContext;\r\n                if (executionContext === NoContext) {\r\n                    // Flush the immediate callbacks that were scheduled during this batch\r\n                    resetRenderTimer();\r\n                    flushSyncCallbackQueue();\r\n                }\r\n            }\r\n        }\r\n        function flushSync(fn, a) {\r\n            var prevExecutionContext = executionContext;\r\n            if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {\r\n                {\r\n                    error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');\r\n                }\r\n                return fn(a);\r\n            }\r\n            executionContext |= BatchedContext;\r\n            {\r\n                try {\r\n                    if (fn) {\r\n                        return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));\r\n                    }\r\n                    else {\r\n                        return undefined;\r\n                    }\r\n                }\r\n                finally {\r\n                    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\r\n                    // Note that this will happen even if batchedUpdates is higher up\r\n                    // the stack.\r\n                    flushSyncCallbackQueue();\r\n                }\r\n            }\r\n        }\r\n        function pushRenderLanes(fiber, lanes) {\r\n            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\r\n            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\r\n            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\r\n        }\r\n        function popRenderLanes(fiber) {\r\n            subtreeRenderLanes = subtreeRenderLanesCursor.current;\r\n            pop(subtreeRenderLanesCursor, fiber);\r\n        }\r\n        function prepareFreshStack(root, lanes) {\r\n            root.finishedWork = null;\r\n            root.finishedLanes = NoLanes;\r\n            var timeoutHandle = root.timeoutHandle;\r\n            if (timeoutHandle !== noTimeout) {\r\n                // The root previous suspended and scheduled a timeout to commit a fallback\r\n                // state. Now that we have additional work, cancel the timeout.\r\n                root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\r\n                cancelTimeout(timeoutHandle);\r\n            }\r\n            if (workInProgress !== null) {\r\n                var interruptedWork = workInProgress.return;\r\n                while (interruptedWork !== null) {\r\n                    unwindInterruptedWork(interruptedWork);\r\n                    interruptedWork = interruptedWork.return;\r\n                }\r\n            }\r\n            workInProgressRoot = root;\r\n            workInProgress = createWorkInProgress(root.current, null);\r\n            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\r\n            workInProgressRootExitStatus = RootIncomplete;\r\n            workInProgressRootFatalError = null;\r\n            workInProgressRootSkippedLanes = NoLanes;\r\n            workInProgressRootUpdatedLanes = NoLanes;\r\n            workInProgressRootPingedLanes = NoLanes;\r\n            {\r\n                spawnedWorkDuringRender = null;\r\n            }\r\n            {\r\n                ReactStrictModeWarnings.discardPendingWarnings();\r\n            }\r\n        }\r\n        function handleError(root, thrownValue) {\r\n            do {\r\n                var erroredWork = workInProgress;\r\n                try {\r\n                    // Reset module-level state that was set during the render phase.\r\n                    resetContextDependencies();\r\n                    resetHooksAfterThrow();\r\n                    resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\r\n                    // separate issue. Write a regression test using string refs.\r\n                    ReactCurrentOwner$2.current = null;\r\n                    if (erroredWork === null || erroredWork.return === null) {\r\n                        // Expected to be working on a non-root fiber. This is a fatal error\r\n                        // because there's no ancestor that can handle it; the root is\r\n                        // supposed to capture all errors that weren't caught by an error\r\n                        // boundary.\r\n                        workInProgressRootExitStatus = RootFatalErrored;\r\n                        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\r\n                        // sibling, or the parent if there are no siblings. But since the root\r\n                        // has no siblings nor a parent, we set it to null. Usually this is\r\n                        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\r\n                        // intentionally not calling those, we need set it here.\r\n                        // TODO: Consider calling `unwindWork` to pop the contexts.\r\n                        workInProgress = null;\r\n                        return;\r\n                    }\r\n                    if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\r\n                        // Record the time spent rendering before an error was thrown. This\r\n                        // avoids inaccurate Profiler durations in the case of a\r\n                        // suspended render.\r\n                        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\r\n                    }\r\n                    throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\r\n                    completeUnitOfWork(erroredWork);\r\n                }\r\n                catch (yetAnotherThrownValue) {\r\n                    // Something in the return path also threw.\r\n                    thrownValue = yetAnotherThrownValue;\r\n                    if (workInProgress === erroredWork && erroredWork !== null) {\r\n                        // If this boundary has already errored, then we had trouble processing\r\n                        // the error. Bubble it to the next boundary.\r\n                        erroredWork = erroredWork.return;\r\n                        workInProgress = erroredWork;\r\n                    }\r\n                    else {\r\n                        erroredWork = workInProgress;\r\n                    }\r\n                    continue;\r\n                } // Return to the normal work loop.\r\n                return;\r\n            } while (true);\r\n        }\r\n        function pushDispatcher() {\r\n            var prevDispatcher = ReactCurrentDispatcher$2.current;\r\n            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\r\n            if (prevDispatcher === null) {\r\n                // The React isomorphic package does not include a default dispatcher.\r\n                // Instead the first renderer will lazily attach one, in order to give\r\n                // nicer error messages.\r\n                return ContextOnlyDispatcher;\r\n            }\r\n            else {\r\n                return prevDispatcher;\r\n            }\r\n        }\r\n        function popDispatcher(prevDispatcher) {\r\n            ReactCurrentDispatcher$2.current = prevDispatcher;\r\n        }\r\n        function pushInteractions(root) {\r\n            {\r\n                var prevInteractions = tracing.__interactionsRef.current;\r\n                tracing.__interactionsRef.current = root.memoizedInteractions;\r\n                return prevInteractions;\r\n            }\r\n        }\r\n        function popInteractions(prevInteractions) {\r\n            {\r\n                tracing.__interactionsRef.current = prevInteractions;\r\n            }\r\n        }\r\n        function markCommitTimeOfFallback() {\r\n            globalMostRecentFallbackTime = now();\r\n        }\r\n        function markSkippedUpdateLanes(lane) {\r\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\r\n        }\r\n        function renderDidSuspend() {\r\n            if (workInProgressRootExitStatus === RootIncomplete) {\r\n                workInProgressRootExitStatus = RootSuspended;\r\n            }\r\n        }\r\n        function renderDidSuspendDelayIfPossible() {\r\n            if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {\r\n                workInProgressRootExitStatus = RootSuspendedWithDelay;\r\n            } // Check if there are updates that we skipped tree that might have unblocked\r\n            // this render.\r\n            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {\r\n                // Mark the current render as suspended so that we switch to working on\r\n                // the updates that were skipped. Usually we only suspend at the end of\r\n                // the render phase.\r\n                // TODO: We should probably always mark the root as suspended immediately\r\n                // (inside this function), since by suspending at the end of the render\r\n                // phase introduces a potential mistake where we suspend lanes that were\r\n                // pinged or updated while we were rendering.\r\n                markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\r\n            }\r\n        }\r\n        function renderDidError() {\r\n            if (workInProgressRootExitStatus !== RootCompleted) {\r\n                workInProgressRootExitStatus = RootErrored;\r\n            }\r\n        } // Called during render to determine if anything has suspended.\r\n        // Returns false if we're not sure.\r\n        function renderHasNotSuspendedYet() {\r\n            // If something errored or completed, we can't really be sure,\r\n            // so those are false.\r\n            return workInProgressRootExitStatus === RootIncomplete;\r\n        }\r\n        function renderRootSync(root, lanes) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= RenderContext;\r\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\r\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n                prepareFreshStack(root, lanes);\r\n                startWorkOnPendingInteractions(root, lanes);\r\n            }\r\n            var prevInteractions = pushInteractions(root);\r\n            do {\r\n                try {\r\n                    workLoopSync();\r\n                    break;\r\n                }\r\n                catch (thrownValue) {\r\n                    handleError(root, thrownValue);\r\n                }\r\n            } while (true);\r\n            resetContextDependencies();\r\n            {\r\n                popInteractions(prevInteractions);\r\n            }\r\n            executionContext = prevExecutionContext;\r\n            popDispatcher(prevDispatcher);\r\n            if (workInProgress !== null) {\r\n                // This is a sync render, so we should have finished the whole tree.\r\n                {\r\n                    {\r\n                        throw Error(\"Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n            }\r\n            workInProgressRoot = null;\r\n            workInProgressRootRenderLanes = NoLanes;\r\n            return workInProgressRootExitStatus;\r\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\r\n        /** @noinline */\r\n        function workLoopSync() {\r\n            // Already timed out, so perform work without checking if we need to yield.\r\n            while (workInProgress !== null) {\r\n                performUnitOfWork(workInProgress);\r\n            }\r\n        }\r\n        function renderRootConcurrent(root, lanes) {\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= RenderContext;\r\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\r\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\r\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\r\n                resetRenderTimer();\r\n                prepareFreshStack(root, lanes);\r\n                startWorkOnPendingInteractions(root, lanes);\r\n            }\r\n            var prevInteractions = pushInteractions(root);\r\n            do {\r\n                try {\r\n                    workLoopConcurrent();\r\n                    break;\r\n                }\r\n                catch (thrownValue) {\r\n                    handleError(root, thrownValue);\r\n                }\r\n            } while (true);\r\n            resetContextDependencies();\r\n            {\r\n                popInteractions(prevInteractions);\r\n            }\r\n            popDispatcher(prevDispatcher);\r\n            executionContext = prevExecutionContext;\r\n            if (workInProgress !== null) {\r\n                return RootIncomplete;\r\n            }\r\n            else {\r\n                workInProgressRoot = null;\r\n                workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\r\n                return workInProgressRootExitStatus;\r\n            }\r\n        }\r\n        /** @noinline */\r\n        function workLoopConcurrent() {\r\n            // Perform work until Scheduler asks us to yield\r\n            while (workInProgress !== null && !shouldYield()) {\r\n                performUnitOfWork(workInProgress);\r\n            }\r\n        }\r\n        function performUnitOfWork(unitOfWork) {\r\n            // The current, flushed, state of this fiber is the alternate. Ideally\r\n            // nothing should rely on this, but relying on it here means that we don't\r\n            // need an additional field on the work in progress.\r\n            var current = unitOfWork.alternate;\r\n            setCurrentFiber(unitOfWork);\r\n            var next;\r\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\r\n                startProfilerTimer(unitOfWork);\r\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\r\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\r\n            }\r\n            else {\r\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\r\n            }\r\n            resetCurrentFiber();\r\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\r\n            if (next === null) {\r\n                // If this doesn't spawn new work, complete the current work.\r\n                completeUnitOfWork(unitOfWork);\r\n            }\r\n            else {\r\n                workInProgress = next;\r\n            }\r\n            ReactCurrentOwner$2.current = null;\r\n        }\r\n        function completeUnitOfWork(unitOfWork) {\r\n            // Attempt to complete the current unit of work, then move to the next\r\n            // sibling. If there are no more siblings, return to the parent fiber.\r\n            var completedWork = unitOfWork;\r\n            do {\r\n                // The current, flushed, state of this fiber is the alternate. Ideally\r\n                // nothing should rely on this, but relying on it here means that we don't\r\n                // need an additional field on the work in progress.\r\n                var current = completedWork.alternate;\r\n                var returnFiber = completedWork.return; // Check if the work completed or if something threw.\r\n                if ((completedWork.flags & Incomplete) === NoFlags) {\r\n                    setCurrentFiber(completedWork);\r\n                    var next = void 0;\r\n                    if ((completedWork.mode & ProfileMode) === NoMode) {\r\n                        next = completeWork(current, completedWork, subtreeRenderLanes);\r\n                    }\r\n                    else {\r\n                        startProfilerTimer(completedWork);\r\n                        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\r\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\r\n                    }\r\n                    resetCurrentFiber();\r\n                    if (next !== null) {\r\n                        // Completing this fiber spawned new work. Work on that next.\r\n                        workInProgress = next;\r\n                        return;\r\n                    }\r\n                    resetChildLanes(completedWork);\r\n                    if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete\r\n                        (returnFiber.flags & Incomplete) === NoFlags) {\r\n                        // Append all the effects of the subtree and this fiber onto the effect\r\n                        // list of the parent. The completion order of the children affects the\r\n                        // side-effect order.\r\n                        if (returnFiber.firstEffect === null) {\r\n                            returnFiber.firstEffect = completedWork.firstEffect;\r\n                        }\r\n                        if (completedWork.lastEffect !== null) {\r\n                            if (returnFiber.lastEffect !== null) {\r\n                                returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\r\n                            }\r\n                            returnFiber.lastEffect = completedWork.lastEffect;\r\n                        } // If this fiber had side-effects, we append it AFTER the children's\r\n                        // side-effects. We can perform certain side-effects earlier if needed,\r\n                        // by doing multiple passes over the effect list. We don't want to\r\n                        // schedule our own side-effect on our own list because if end up\r\n                        // reusing children we'll schedule this effect onto itself since we're\r\n                        // at the end.\r\n                        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect\r\n                        // list. PerformedWork effect is read by React DevTools but shouldn't be\r\n                        // committed.\r\n                        if (flags > PerformedWork) {\r\n                            if (returnFiber.lastEffect !== null) {\r\n                                returnFiber.lastEffect.nextEffect = completedWork;\r\n                            }\r\n                            else {\r\n                                returnFiber.firstEffect = completedWork;\r\n                            }\r\n                            returnFiber.lastEffect = completedWork;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // This fiber did not complete because something threw. Pop values off\r\n                    // the stack without entering the complete phase. If this is a boundary,\r\n                    // capture values if possible.\r\n                    var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.\r\n                    if (_next !== null) {\r\n                        // If completing this work spawned new work, do that next. We'll come\r\n                        // back here again.\r\n                        // Since we're restarting, remove anything that is not a host effect\r\n                        // from the effect tag.\r\n                        _next.flags &= HostEffectMask;\r\n                        workInProgress = _next;\r\n                        return;\r\n                    }\r\n                    if ((completedWork.mode & ProfileMode) !== NoMode) {\r\n                        // Record the render duration for the fiber that errored.\r\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\r\n                        var actualDuration = completedWork.actualDuration;\r\n                        var child = completedWork.child;\r\n                        while (child !== null) {\r\n                            actualDuration += child.actualDuration;\r\n                            child = child.sibling;\r\n                        }\r\n                        completedWork.actualDuration = actualDuration;\r\n                    }\r\n                    if (returnFiber !== null) {\r\n                        // Mark the parent fiber as incomplete and clear its effect list.\r\n                        returnFiber.firstEffect = returnFiber.lastEffect = null;\r\n                        returnFiber.flags |= Incomplete;\r\n                    }\r\n                }\r\n                var siblingFiber = completedWork.sibling;\r\n                if (siblingFiber !== null) {\r\n                    // If there is more work to do in this returnFiber, do that next.\r\n                    workInProgress = siblingFiber;\r\n                    return;\r\n                } // Otherwise, return to the parent\r\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\r\n                workInProgress = completedWork;\r\n            } while (completedWork !== null); // We've reached the root.\r\n            if (workInProgressRootExitStatus === RootIncomplete) {\r\n                workInProgressRootExitStatus = RootCompleted;\r\n            }\r\n        }\r\n        function resetChildLanes(completedWork) {\r\n            if ( // TODO: Move this check out of the hot path by moving `resetChildLanes`\r\n            // to switch statement in `completeWork`.\r\n            (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {\r\n                // The children of this component are hidden. Don't bubble their\r\n                // expiration times.\r\n                return;\r\n            }\r\n            var newChildLanes = NoLanes; // Bubble up the earliest expiration time.\r\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\r\n                // In profiling mode, resetChildExpirationTime is also used to reset\r\n                // profiler durations.\r\n                var actualDuration = completedWork.actualDuration;\r\n                var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will\r\n                // only be updated if work is done on the fiber (i.e. it doesn't bailout).\r\n                // When work is done, it should bubble to the parent's actualDuration. If\r\n                // the fiber has not been cloned though, (meaning no work was done), then\r\n                // this value will reflect the amount of time spent working on a previous\r\n                // render. In that case it should not bubble. We determine whether it was\r\n                // cloned by comparing the child pointer.\r\n                var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;\r\n                var child = completedWork.child;\r\n                while (child !== null) {\r\n                    newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\r\n                    if (shouldBubbleActualDurations) {\r\n                        actualDuration += child.actualDuration;\r\n                    }\r\n                    treeBaseDuration += child.treeBaseDuration;\r\n                    child = child.sibling;\r\n                }\r\n                var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;\r\n                if (isTimedOutSuspense) {\r\n                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\r\n                    var primaryChildFragment = completedWork.child;\r\n                    if (primaryChildFragment !== null) {\r\n                        treeBaseDuration -= primaryChildFragment.treeBaseDuration;\r\n                    }\r\n                }\r\n                completedWork.actualDuration = actualDuration;\r\n                completedWork.treeBaseDuration = treeBaseDuration;\r\n            }\r\n            else {\r\n                var _child = completedWork.child;\r\n                while (_child !== null) {\r\n                    newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\r\n                    _child = _child.sibling;\r\n                }\r\n            }\r\n            completedWork.childLanes = newChildLanes;\r\n        }\r\n        function commitRoot(root) {\r\n            var renderPriorityLevel = getCurrentPriorityLevel();\r\n            runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));\r\n            return null;\r\n        }\r\n        function commitRootImpl(root, renderPriorityLevel) {\r\n            do {\r\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\r\n                // means `flushPassiveEffects` will sometimes result in additional\r\n                // passive effects. So we need to keep flushing in a loop until there are\r\n                // no more pending effects.\r\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\r\n                // flush synchronous work at the end, to avoid factoring hazards like this.\r\n                flushPassiveEffects();\r\n            } while (rootWithPendingPassiveEffects !== null);\r\n            flushRenderPhaseStrictModeWarningsInDEV();\r\n            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {\r\n                {\r\n                    throw Error(\"Should not already be working.\");\r\n                }\r\n            }\r\n            var finishedWork = root.finishedWork;\r\n            var lanes = root.finishedLanes;\r\n            if (finishedWork === null) {\r\n                return null;\r\n            }\r\n            root.finishedWork = null;\r\n            root.finishedLanes = NoLanes;\r\n            if (!(finishedWork !== root.current)) {\r\n                {\r\n                    throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\r\n                }\r\n            } // commitRoot never returns a continuation; it always finishes synchronously.\r\n            // So we can clear these now to allow a new callback to be scheduled.\r\n            root.callbackNode = null; // Update the first and last pending times on this root. The new first\r\n            // pending time is whatever is left on the root fiber.\r\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\r\n            markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of\r\n            // `flushDiscreteUpdates` starts a useless render pass which may cancels\r\n            // a scheduled timeout.\r\n            if (rootsWithPendingDiscreteUpdates !== null) {\r\n                if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {\r\n                    rootsWithPendingDiscreteUpdates.delete(root);\r\n                }\r\n            }\r\n            if (root === workInProgressRoot) {\r\n                // We can reset these now that they are finished.\r\n                workInProgressRoot = null;\r\n                workInProgress = null;\r\n                workInProgressRootRenderLanes = NoLanes;\r\n            } // Get the list of effects.\r\n            var firstEffect;\r\n            if (finishedWork.flags > PerformedWork) {\r\n                // A fiber's effect list consists only of its children, not itself. So if\r\n                // the root has an effect, we need to add it to the end of the list. The\r\n                // resulting list is the set that would belong to the root's parent, if it\r\n                // had one; that is, all the effects in the tree including the root.\r\n                if (finishedWork.lastEffect !== null) {\r\n                    finishedWork.lastEffect.nextEffect = finishedWork;\r\n                    firstEffect = finishedWork.firstEffect;\r\n                }\r\n                else {\r\n                    firstEffect = finishedWork;\r\n                }\r\n            }\r\n            else {\r\n                // There is no effect on the root.\r\n                firstEffect = finishedWork.firstEffect;\r\n            }\r\n            if (firstEffect !== null) {\r\n                var prevExecutionContext = executionContext;\r\n                executionContext |= CommitContext;\r\n                var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles\r\n                ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\r\n                // of the effect list for each phase: all mutation effects come before all\r\n                // layout effects, and so on.\r\n                // The first phase a \"before mutation\" phase. We use this phase to read the\r\n                // state of the host tree right before we mutate it. This is where\r\n                // getSnapshotBeforeUpdate is called.\r\n                focusedInstanceHandle = prepareForCommit(root.containerInfo);\r\n                shouldFireAfterActiveInstanceBlur = false;\r\n                nextEffect = firstEffect;\r\n                do {\r\n                    {\r\n                        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\r\n                        if (hasCaughtError()) {\r\n                            if (!(nextEffect !== null)) {\r\n                                {\r\n                                    throw Error(\"Should be working on an effect.\");\r\n                                }\r\n                            }\r\n                            var error = clearCaughtError();\r\n                            captureCommitPhaseError(nextEffect, error);\r\n                            nextEffect = nextEffect.nextEffect;\r\n                        }\r\n                    }\r\n                } while (nextEffect !== null); // We no longer need to track the active instance fiber\r\n                focusedInstanceHandle = null;\r\n                {\r\n                    // Mark the current commit time to be shared by all Profilers in this\r\n                    // batch. This enables them to be grouped later.\r\n                    recordCommitTime();\r\n                } // The next phase is the mutation phase, where we mutate the host tree.\r\n                nextEffect = firstEffect;\r\n                do {\r\n                    {\r\n                        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);\r\n                        if (hasCaughtError()) {\r\n                            if (!(nextEffect !== null)) {\r\n                                {\r\n                                    throw Error(\"Should be working on an effect.\");\r\n                                }\r\n                            }\r\n                            var _error = clearCaughtError();\r\n                            captureCommitPhaseError(nextEffect, _error);\r\n                            nextEffect = nextEffect.nextEffect;\r\n                        }\r\n                    }\r\n                } while (nextEffect !== null);\r\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\r\n                // the mutation phase, so that the previous tree is still current during\r\n                // componentWillUnmount, but before the layout phase, so that the finished\r\n                // work is current during componentDidMount/Update.\r\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\r\n                // the host tree after it's been mutated. The idiomatic use case for this is\r\n                // layout, but class component lifecycles also fire here for legacy reasons.\r\n                nextEffect = firstEffect;\r\n                do {\r\n                    {\r\n                        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);\r\n                        if (hasCaughtError()) {\r\n                            if (!(nextEffect !== null)) {\r\n                                {\r\n                                    throw Error(\"Should be working on an effect.\");\r\n                                }\r\n                            }\r\n                            var _error2 = clearCaughtError();\r\n                            captureCommitPhaseError(nextEffect, _error2);\r\n                            nextEffect = nextEffect.nextEffect;\r\n                        }\r\n                    }\r\n                } while (nextEffect !== null);\r\n                nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an\r\n                // opportunity to paint.\r\n                requestPaint();\r\n                {\r\n                    popInteractions(prevInteractions);\r\n                }\r\n                executionContext = prevExecutionContext;\r\n            }\r\n            else {\r\n                // No effects.\r\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\r\n                // no effects.\r\n                // TODO: Maybe there's a better way to report this.\r\n                {\r\n                    recordCommitTime();\r\n                }\r\n            }\r\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\r\n            if (rootDoesHavePassiveEffects) {\r\n                // This commit has passive effects. Stash a reference to them. But don't\r\n                // schedule a callback until after flushing layout work.\r\n                rootDoesHavePassiveEffects = false;\r\n                rootWithPendingPassiveEffects = root;\r\n                pendingPassiveEffectsLanes = lanes;\r\n                pendingPassiveEffectsRenderPriority = renderPriorityLevel;\r\n            }\r\n            else {\r\n                // We are done with the effect chain at this point so let's clear the\r\n                // nextEffect pointers to assist with GC. If we have passive effects, we'll\r\n                // clear this in flushPassiveEffects.\r\n                nextEffect = firstEffect;\r\n                while (nextEffect !== null) {\r\n                    var nextNextEffect = nextEffect.nextEffect;\r\n                    nextEffect.nextEffect = null;\r\n                    if (nextEffect.flags & Deletion) {\r\n                        detachFiberAfterEffects(nextEffect);\r\n                    }\r\n                    nextEffect = nextNextEffect;\r\n                }\r\n            } // Read this again, since an effect might have updated it\r\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\r\n            if (remainingLanes !== NoLanes) {\r\n                {\r\n                    if (spawnedWorkDuringRender !== null) {\r\n                        var expirationTimes = spawnedWorkDuringRender;\r\n                        spawnedWorkDuringRender = null;\r\n                        for (var i = 0; i < expirationTimes.length; i++) {\r\n                            scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);\r\n                        }\r\n                    }\r\n                    schedulePendingInteractions(root, remainingLanes);\r\n                }\r\n            }\r\n            else {\r\n                // If there's no remaining work, we can clear the set of already failed\r\n                // error boundaries.\r\n                legacyErrorBoundariesThatAlreadyFailed = null;\r\n            }\r\n            {\r\n                if (!rootDidHavePassiveEffects) {\r\n                    // If there are no passive effects, then we can complete the pending interactions.\r\n                    // Otherwise, we'll wait until after the passive effects are flushed.\r\n                    // Wait to do this until after remaining work has been scheduled,\r\n                    // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\r\n                    finishPendingInteractions(root, lanes);\r\n                }\r\n            }\r\n            if (remainingLanes === SyncLane) {\r\n                // Count the number of times the root synchronously re-renders without\r\n                // finishing. If there are too many, it indicates an infinite update loop.\r\n                if (root === rootWithNestedUpdates) {\r\n                    nestedUpdateCount++;\r\n                }\r\n                else {\r\n                    nestedUpdateCount = 0;\r\n                    rootWithNestedUpdates = root;\r\n                }\r\n            }\r\n            else {\r\n                nestedUpdateCount = 0;\r\n            }\r\n            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\r\n            {\r\n                onCommitRoot$1();\r\n            } // Always call this before exiting `commitRoot`, to ensure that any\r\n            // additional work on this root is scheduled.\r\n            ensureRootIsScheduled(root, now());\r\n            if (hasUncaughtError) {\r\n                hasUncaughtError = false;\r\n                var _error3 = firstUncaughtError;\r\n                firstUncaughtError = null;\r\n                throw _error3;\r\n            }\r\n            if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\r\n                // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\r\n                // synchronously, but layout updates should be deferred until the end\r\n                // of the batch.\r\n                return null;\r\n            } // If layout work was scheduled, flush it now.\r\n            flushSyncCallbackQueue();\r\n            return null;\r\n        }\r\n        function commitBeforeMutationEffects() {\r\n            while (nextEffect !== null) {\r\n                var current = nextEffect.alternate;\r\n                if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\r\n                    if ((nextEffect.flags & Deletion) !== NoFlags) {\r\n                        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n                            shouldFireAfterActiveInstanceBlur = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // TODO: Move this out of the hot path using a dedicated effect tag.\r\n                        if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {\r\n                            shouldFireAfterActiveInstanceBlur = true;\r\n                        }\r\n                    }\r\n                }\r\n                var flags = nextEffect.flags;\r\n                if ((flags & Snapshot) !== NoFlags) {\r\n                    setCurrentFiber(nextEffect);\r\n                    commitBeforeMutationLifeCycles(current, nextEffect);\r\n                    resetCurrentFiber();\r\n                }\r\n                if ((flags & Passive) !== NoFlags) {\r\n                    // If there are passive effects, schedule a callback to flush at\r\n                    // the earliest opportunity.\r\n                    if (!rootDoesHavePassiveEffects) {\r\n                        rootDoesHavePassiveEffects = true;\r\n                        scheduleCallback(NormalPriority$1, function () {\r\n                            flushPassiveEffects();\r\n                            return null;\r\n                        });\r\n                    }\r\n                }\r\n                nextEffect = nextEffect.nextEffect;\r\n            }\r\n        }\r\n        function commitMutationEffects(root, renderPriorityLevel) {\r\n            // TODO: Should probably move the bulk of this function to commitWork.\r\n            while (nextEffect !== null) {\r\n                setCurrentFiber(nextEffect);\r\n                var flags = nextEffect.flags;\r\n                if (flags & ContentReset) {\r\n                    commitResetTextContent(nextEffect);\r\n                }\r\n                if (flags & Ref) {\r\n                    var current = nextEffect.alternate;\r\n                    if (current !== null) {\r\n                        commitDetachRef(current);\r\n                    }\r\n                } // The following switch statement is only concerned about placement,\r\n                // updates, and deletions. To avoid needing to add a case for every possible\r\n                // bitmap value, we remove the secondary effects from the effect tag and\r\n                // switch on that value.\r\n                var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\r\n                switch (primaryFlags) {\r\n                    case Placement:\r\n                        {\r\n                            commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\r\n                            // inserted, before any life-cycles like componentDidMount gets called.\r\n                            // TODO: findDOMNode doesn't rely on this any more but isMounted does\r\n                            // and isMounted is deprecated anyway so we should be able to kill this.\r\n                            nextEffect.flags &= ~Placement;\r\n                            break;\r\n                        }\r\n                    case PlacementAndUpdate:\r\n                        {\r\n                            // Placement\r\n                            commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\r\n                            // inserted, before any life-cycles like componentDidMount gets called.\r\n                            nextEffect.flags &= ~Placement; // Update\r\n                            var _current = nextEffect.alternate;\r\n                            commitWork(_current, nextEffect);\r\n                            break;\r\n                        }\r\n                    case Hydrating:\r\n                        {\r\n                            nextEffect.flags &= ~Hydrating;\r\n                            break;\r\n                        }\r\n                    case HydratingAndUpdate:\r\n                        {\r\n                            nextEffect.flags &= ~Hydrating; // Update\r\n                            var _current2 = nextEffect.alternate;\r\n                            commitWork(_current2, nextEffect);\r\n                            break;\r\n                        }\r\n                    case Update:\r\n                        {\r\n                            var _current3 = nextEffect.alternate;\r\n                            commitWork(_current3, nextEffect);\r\n                            break;\r\n                        }\r\n                    case Deletion:\r\n                        {\r\n                            commitDeletion(root, nextEffect);\r\n                            break;\r\n                        }\r\n                }\r\n                resetCurrentFiber();\r\n                nextEffect = nextEffect.nextEffect;\r\n            }\r\n        }\r\n        function commitLayoutEffects(root, committedLanes) {\r\n            while (nextEffect !== null) {\r\n                setCurrentFiber(nextEffect);\r\n                var flags = nextEffect.flags;\r\n                if (flags & (Update | Callback)) {\r\n                    var current = nextEffect.alternate;\r\n                    commitLifeCycles(root, current, nextEffect);\r\n                }\r\n                {\r\n                    if (flags & Ref) {\r\n                        commitAttachRef(nextEffect);\r\n                    }\r\n                }\r\n                resetCurrentFiber();\r\n                nextEffect = nextEffect.nextEffect;\r\n            }\r\n        }\r\n        function flushPassiveEffects() {\r\n            // Returns whether passive effects were flushed.\r\n            if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {\r\n                var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;\r\n                pendingPassiveEffectsRenderPriority = NoPriority$1;\r\n                {\r\n                    return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function enqueuePendingPassiveHookEffectMount(fiber, effect) {\r\n            pendingPassiveHookEffectsMount.push(effect, fiber);\r\n            if (!rootDoesHavePassiveEffects) {\r\n                rootDoesHavePassiveEffects = true;\r\n                scheduleCallback(NormalPriority$1, function () {\r\n                    flushPassiveEffects();\r\n                    return null;\r\n                });\r\n            }\r\n        }\r\n        function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {\r\n            pendingPassiveHookEffectsUnmount.push(effect, fiber);\r\n            {\r\n                fiber.flags |= PassiveUnmountPendingDev;\r\n                var alternate = fiber.alternate;\r\n                if (alternate !== null) {\r\n                    alternate.flags |= PassiveUnmountPendingDev;\r\n                }\r\n            }\r\n            if (!rootDoesHavePassiveEffects) {\r\n                rootDoesHavePassiveEffects = true;\r\n                scheduleCallback(NormalPriority$1, function () {\r\n                    flushPassiveEffects();\r\n                    return null;\r\n                });\r\n            }\r\n        }\r\n        function invokePassiveEffectCreate(effect) {\r\n            var create = effect.create;\r\n            effect.destroy = create();\r\n        }\r\n        function flushPassiveEffectsImpl() {\r\n            if (rootWithPendingPassiveEffects === null) {\r\n                return false;\r\n            }\r\n            var root = rootWithPendingPassiveEffects;\r\n            var lanes = pendingPassiveEffectsLanes;\r\n            rootWithPendingPassiveEffects = null;\r\n            pendingPassiveEffectsLanes = NoLanes;\r\n            if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {\r\n                {\r\n                    throw Error(\"Cannot flush passive effects while already rendering.\");\r\n                }\r\n            }\r\n            {\r\n                isFlushingPassiveEffects = true;\r\n            }\r\n            var prevExecutionContext = executionContext;\r\n            executionContext |= CommitContext;\r\n            var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called\r\n            // before ANY passive effect create functions are called.\r\n            // Otherwise effects in sibling components might interfere with each other.\r\n            // e.g. a destroy function in one component may unintentionally override a ref\r\n            // value set by a create function in another component.\r\n            // Layout effects have the same constraint.\r\n            // First pass: Destroy stale passive effects.\r\n            var unmountEffects = pendingPassiveHookEffectsUnmount;\r\n            pendingPassiveHookEffectsUnmount = [];\r\n            for (var i = 0; i < unmountEffects.length; i += 2) {\r\n                var _effect = unmountEffects[i];\r\n                var fiber = unmountEffects[i + 1];\r\n                var destroy = _effect.destroy;\r\n                _effect.destroy = undefined;\r\n                {\r\n                    fiber.flags &= ~PassiveUnmountPendingDev;\r\n                    var alternate = fiber.alternate;\r\n                    if (alternate !== null) {\r\n                        alternate.flags &= ~PassiveUnmountPendingDev;\r\n                    }\r\n                }\r\n                if (typeof destroy === 'function') {\r\n                    {\r\n                        setCurrentFiber(fiber);\r\n                        {\r\n                            invokeGuardedCallback(null, destroy, null);\r\n                        }\r\n                        if (hasCaughtError()) {\r\n                            if (!(fiber !== null)) {\r\n                                {\r\n                                    throw Error(\"Should be working on an effect.\");\r\n                                }\r\n                            }\r\n                            var error = clearCaughtError();\r\n                            captureCommitPhaseError(fiber, error);\r\n                        }\r\n                        resetCurrentFiber();\r\n                    }\r\n                }\r\n            } // Second pass: Create new passive effects.\r\n            var mountEffects = pendingPassiveHookEffectsMount;\r\n            pendingPassiveHookEffectsMount = [];\r\n            for (var _i = 0; _i < mountEffects.length; _i += 2) {\r\n                var _effect2 = mountEffects[_i];\r\n                var _fiber = mountEffects[_i + 1];\r\n                {\r\n                    setCurrentFiber(_fiber);\r\n                    {\r\n                        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);\r\n                    }\r\n                    if (hasCaughtError()) {\r\n                        if (!(_fiber !== null)) {\r\n                            {\r\n                                throw Error(\"Should be working on an effect.\");\r\n                            }\r\n                        }\r\n                        var _error4 = clearCaughtError();\r\n                        captureCommitPhaseError(_fiber, _error4);\r\n                    }\r\n                    resetCurrentFiber();\r\n                }\r\n            } // Note: This currently assumes there are no passive effects on the root fiber\r\n            // because the root is not part of its own effect list.\r\n            // This could change in the future.\r\n            var effect = root.current.firstEffect;\r\n            while (effect !== null) {\r\n                var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC\r\n                effect.nextEffect = null;\r\n                if (effect.flags & Deletion) {\r\n                    detachFiberAfterEffects(effect);\r\n                }\r\n                effect = nextNextEffect;\r\n            }\r\n            {\r\n                popInteractions(prevInteractions);\r\n                finishPendingInteractions(root, lanes);\r\n            }\r\n            {\r\n                isFlushingPassiveEffects = false;\r\n            }\r\n            executionContext = prevExecutionContext;\r\n            flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this\r\n            // exceeds the limit, we'll fire a warning.\r\n            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\r\n            return true;\r\n        }\r\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\r\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\r\n        }\r\n        function markLegacyErrorBoundaryAsFailed(instance) {\r\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\r\n                legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\r\n            }\r\n            else {\r\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\r\n            }\r\n        }\r\n        function prepareToThrowUncaughtError(error) {\r\n            if (!hasUncaughtError) {\r\n                hasUncaughtError = true;\r\n                firstUncaughtError = error;\r\n            }\r\n        }\r\n        var onUncaughtError = prepareToThrowUncaughtError;\r\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\r\n            var errorInfo = createCapturedValue(error, sourceFiber);\r\n            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\r\n            enqueueUpdate(rootFiber, update);\r\n            var eventTime = requestEventTime();\r\n            var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\r\n            if (root !== null) {\r\n                markRootUpdated(root, SyncLane, eventTime);\r\n                ensureRootIsScheduled(root, eventTime);\r\n                schedulePendingInteractions(root, SyncLane);\r\n            }\r\n        }\r\n        function captureCommitPhaseError(sourceFiber, error) {\r\n            if (sourceFiber.tag === HostRoot) {\r\n                // Error was thrown at the root. There is no parent, so the root\r\n                // itself should capture it.\r\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\r\n                return;\r\n            }\r\n            var fiber = sourceFiber.return;\r\n            while (fiber !== null) {\r\n                if (fiber.tag === HostRoot) {\r\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\r\n                    return;\r\n                }\r\n                else if (fiber.tag === ClassComponent) {\r\n                    var ctor = fiber.type;\r\n                    var instance = fiber.stateNode;\r\n                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\r\n                        var errorInfo = createCapturedValue(error, sourceFiber);\r\n                        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\r\n                        enqueueUpdate(fiber, update);\r\n                        var eventTime = requestEventTime();\r\n                        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\r\n                        if (root !== null) {\r\n                            markRootUpdated(root, SyncLane, eventTime);\r\n                            ensureRootIsScheduled(root, eventTime);\r\n                            schedulePendingInteractions(root, SyncLane);\r\n                        }\r\n                        else {\r\n                            // This component has already been unmounted.\r\n                            // We can't schedule any follow up work for the root because the fiber is already unmounted,\r\n                            // but we can still call the log-only boundary so the error isn't swallowed.\r\n                            //\r\n                            // TODO This is only a temporary bandaid for the old reconciler fork.\r\n                            // We can delete this special case once the new fork is merged.\r\n                            if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\r\n                                try {\r\n                                    instance.componentDidCatch(error, errorInfo);\r\n                                }\r\n                                catch (errorToIgnore) { // TODO Ignore this error? Rethrow it?\r\n                                    // This is kind of an edge case.\r\n                                }\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                }\r\n                fiber = fiber.return;\r\n            }\r\n        }\r\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\r\n            var pingCache = root.pingCache;\r\n            if (pingCache !== null) {\r\n                // The wakeable resolved, so we no longer need to memoize, because it will\r\n                // never be thrown again.\r\n                pingCache.delete(wakeable);\r\n            }\r\n            var eventTime = requestEventTime();\r\n            markRootPinged(root, pingedLanes);\r\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\r\n                // Received a ping at the same priority level at which we're currently\r\n                // rendering. We might want to restart this render. This should mirror\r\n                // the logic of whether or not a root suspends once it completes.\r\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\r\n                // we should probably never restart.\r\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\r\n                // so we can always restart.\r\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\r\n                    // Restart from the root.\r\n                    prepareFreshStack(root, NoLanes);\r\n                }\r\n                else {\r\n                    // Even though we can't restart right now, we might get an\r\n                    // opportunity later. So we mark this render as having a ping.\r\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\r\n                }\r\n            }\r\n            ensureRootIsScheduled(root, eventTime);\r\n            schedulePendingInteractions(root, pingedLanes);\r\n        }\r\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\r\n            // The boundary fiber (a Suspense component or SuspenseList component)\r\n            // previously was rendered in its fallback state. One of the promises that\r\n            // suspended it has resolved, which means at least part of the tree was\r\n            // likely unblocked. Try rendering again, at a new expiration time.\r\n            if (retryLane === NoLane) {\r\n                retryLane = requestRetryLane(boundaryFiber);\r\n            } // TODO: Special case idle priority?\r\n            var eventTime = requestEventTime();\r\n            var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\r\n            if (root !== null) {\r\n                markRootUpdated(root, retryLane, eventTime);\r\n                ensureRootIsScheduled(root, eventTime);\r\n                schedulePendingInteractions(root, retryLane);\r\n            }\r\n        }\r\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\r\n            var retryLane = NoLane; // Default\r\n            var retryCache;\r\n            {\r\n                retryCache = boundaryFiber.stateNode;\r\n            }\r\n            if (retryCache !== null) {\r\n                // The wakeable resolved, so we no longer need to memoize, because it will\r\n                // never be thrown again.\r\n                retryCache.delete(wakeable);\r\n            }\r\n            retryTimedOutBoundary(boundaryFiber, retryLane);\r\n        } // Computes the next Just Noticeable Difference (JND) boundary.\r\n        // The theory is that a person can't tell the difference between small differences in time.\r\n        // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\r\n        // difference in the experience. However, waiting for longer might mean that we can avoid\r\n        // showing an intermediate loading state. The longer we have already waited, the harder it\r\n        // is to tell small differences in time. Therefore, the longer we've already waited,\r\n        // the longer we can wait additionally. At some point we have to give up though.\r\n        // We pick a train model where the next boundary commits at a consistent schedule.\r\n        // These particular numbers are vague estimates. We expect to adjust them based on research.\r\n        function jnd(timeElapsed) {\r\n            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\r\n        }\r\n        function checkForNestedUpdates() {\r\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\r\n                nestedUpdateCount = 0;\r\n                rootWithNestedUpdates = null;\r\n                {\r\n                    {\r\n                        throw Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\r\n                    }\r\n                }\r\n            }\r\n            {\r\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\r\n                    nestedPassiveUpdateCount = 0;\r\n                    error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\r\n                }\r\n            }\r\n        }\r\n        function flushRenderPhaseStrictModeWarningsInDEV() {\r\n            {\r\n                ReactStrictModeWarnings.flushLegacyContextWarning();\r\n                {\r\n                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\r\n                }\r\n            }\r\n        }\r\n        var didWarnStateUpdateForNotYetMountedComponent = null;\r\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\r\n            {\r\n                if ((executionContext & RenderContext) !== NoContext) {\r\n                    // We let the other warning about render phase updates deal with this one.\r\n                    return;\r\n                }\r\n                if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {\r\n                    return;\r\n                }\r\n                var tag = fiber.tag;\r\n                if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {\r\n                    // Only warn for user-defined components, not internal ones like Suspense.\r\n                    return;\r\n                } // We show the whole stack but dedupe on the top component's name because\r\n                // the problematic code almost always lies inside that component.\r\n                var componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\r\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\r\n                        return;\r\n                    }\r\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\r\n                }\r\n                else {\r\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\r\n                }\r\n                var previousFiber = current;\r\n                try {\r\n                    setCurrentFiber(fiber);\r\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\r\n                }\r\n                finally {\r\n                    if (previousFiber) {\r\n                        setCurrentFiber(fiber);\r\n                    }\r\n                    else {\r\n                        resetCurrentFiber();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var didWarnStateUpdateForUnmountedComponent = null;\r\n        function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\r\n            {\r\n                var tag = fiber.tag;\r\n                if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {\r\n                    // Only warn for user-defined components, not internal ones like Suspense.\r\n                    return;\r\n                } // If there are pending passive effects unmounts for this Fiber,\r\n                // we can assume that they would have prevented this update.\r\n                if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {\r\n                    return;\r\n                } // We show the whole stack but dedupe on the top component's name because\r\n                // the problematic code almost always lies inside that component.\r\n                var componentName = getComponentName(fiber.type) || 'ReactComponent';\r\n                if (didWarnStateUpdateForUnmountedComponent !== null) {\r\n                    if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\r\n                        return;\r\n                    }\r\n                    didWarnStateUpdateForUnmountedComponent.add(componentName);\r\n                }\r\n                else {\r\n                    didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\r\n                }\r\n                if (isFlushingPassiveEffects)\r\n                    ;\r\n                else {\r\n                    var previousFiber = current;\r\n                    try {\r\n                        setCurrentFiber(fiber);\r\n                        error(\"Can't perform a React state update on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');\r\n                    }\r\n                    finally {\r\n                        if (previousFiber) {\r\n                            setCurrentFiber(fiber);\r\n                        }\r\n                        else {\r\n                            resetCurrentFiber();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var beginWork$1;\r\n        {\r\n            var dummyFiber = null;\r\n            beginWork$1 = function (current, unitOfWork, lanes) {\r\n                // If a component throws an error, we replay it again in a synchronously\r\n                // dispatched event, so that the debugger will treat it as an uncaught\r\n                // error See ReactErrorUtils for more information.\r\n                // Before entering the begin phase, copy the work-in-progress onto a dummy\r\n                // fiber. If beginWork throws, we'll use this to reset the state.\r\n                var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\r\n                try {\r\n                    return beginWork(current, unitOfWork, lanes);\r\n                }\r\n                catch (originalError) {\r\n                    if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\r\n                        // Don't replay promises. Treat everything else like an error.\r\n                        throw originalError;\r\n                    } // Keep this code in sync with handleError; any changes here must have\r\n                    // corresponding changes there.\r\n                    resetContextDependencies();\r\n                    resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\r\n                    // same fiber again.\r\n                    // Unwind the failed stack frame\r\n                    unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.\r\n                    assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\r\n                    if (unitOfWork.mode & ProfileMode) {\r\n                        // Reset the profiler timer.\r\n                        startProfilerTimer(unitOfWork);\r\n                    } // Run beginWork again.\r\n                    invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\r\n                    if (hasCaughtError()) {\r\n                        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\r\n                        // Rethrow this error instead of the original one.\r\n                        throw replayError;\r\n                    }\r\n                    else {\r\n                        // This branch is reachable if the render phase is impure.\r\n                        throw originalError;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        var didWarnAboutUpdateInRender = false;\r\n        var didWarnAboutUpdateInRenderForAnotherComponent;\r\n        {\r\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\r\n        }\r\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\r\n            {\r\n                if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\r\n                    switch (fiber.tag) {\r\n                        case FunctionComponent:\r\n                        case ForwardRef:\r\n                        case SimpleMemoComponent:\r\n                            {\r\n                                var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\r\n                                var dedupeKey = renderingComponentName;\r\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\r\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\r\n                                    var setStateComponentName = getComponentName(fiber.type) || 'Unknown';\r\n                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\r\n                                }\r\n                                break;\r\n                            }\r\n                        case ClassComponent:\r\n                            {\r\n                                if (!didWarnAboutUpdateInRender) {\r\n                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\r\n                                    didWarnAboutUpdateInRender = true;\r\n                                }\r\n                                break;\r\n                            }\r\n                    }\r\n                }\r\n            }\r\n        } // a 'shared' variable that changes when act() opens/closes in tests.\r\n        var IsThisRendererActing = {\r\n            current: false\r\n        };\r\n        function warnIfNotScopedWithMatchingAct(fiber) {\r\n            {\r\n                if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {\r\n                    var previousFiber = current;\r\n                    try {\r\n                        setCurrentFiber(fiber);\r\n                        error(\"It looks like you're using the wrong act() around your test interactions.\\n\" + 'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' + '// for react-dom:\\n' + // Break up imports to avoid accidentally parsing them as dependencies.\r\n                            'import {act} fr' + \"om 'react-dom/test-utils';\\n\" + '// ...\\n' + 'act(() => ...);\\n\\n' + '// for react-test-renderer:\\n' + // Break up imports to avoid accidentally parsing them as dependencies.\r\n                            'import TestRenderer fr' + \"om react-test-renderer';\\n\" + 'const {act} = TestRenderer;\\n' + '// ...\\n' + 'act(() => ...);');\r\n                    }\r\n                    finally {\r\n                        if (previousFiber) {\r\n                            setCurrentFiber(fiber);\r\n                        }\r\n                        else {\r\n                            resetCurrentFiber();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function warnIfNotCurrentlyActingEffectsInDEV(fiber) {\r\n            {\r\n                if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\r\n                    error('An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));\r\n                }\r\n            }\r\n        }\r\n        function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {\r\n            {\r\n                if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\r\n                    var previousFiber = current;\r\n                    try {\r\n                        setCurrentFiber(fiber);\r\n                        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));\r\n                    }\r\n                    finally {\r\n                        if (previousFiber) {\r\n                            setCurrentFiber(fiber);\r\n                        }\r\n                        else {\r\n                            resetCurrentFiber();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.\r\n        var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked\r\n        // scheduler is the actual recommendation. The alternative could be a testing build,\r\n        // a new lib, or whatever; we dunno just yet. This message is for early adopters\r\n        // to get their tests right.\r\n        function warnIfUnmockedScheduler(fiber) {\r\n            {\r\n                if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {\r\n                    if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\r\n                        didWarnAboutUnmockedScheduler = true;\r\n                        error('In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + // Break up requires to avoid accidentally parsing them as dependencies.\r\n                            \"jest.mock('scheduler', () => require\" + \"('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://reactjs.org/link/mock-scheduler');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function computeThreadID(root, lane) {\r\n            // Interaction threads are unique per root and expiration time.\r\n            // NOTE: Intentionally unsound cast. All that matters is that it's a number\r\n            // and it represents a batch of work. Could make a helper function instead,\r\n            // but meh this is fine for now.\r\n            return lane * 1000 + root.interactionThreadID;\r\n        }\r\n        function markSpawnedWork(lane) {\r\n            if (spawnedWorkDuringRender === null) {\r\n                spawnedWorkDuringRender = [lane];\r\n            }\r\n            else {\r\n                spawnedWorkDuringRender.push(lane);\r\n            }\r\n        }\r\n        function scheduleInteractions(root, lane, interactions) {\r\n            if (interactions.size > 0) {\r\n                var pendingInteractionMap = root.pendingInteractionMap;\r\n                var pendingInteractions = pendingInteractionMap.get(lane);\r\n                if (pendingInteractions != null) {\r\n                    interactions.forEach(function (interaction) {\r\n                        if (!pendingInteractions.has(interaction)) {\r\n                            // Update the pending async work count for previously unscheduled interaction.\r\n                            interaction.__count++;\r\n                        }\r\n                        pendingInteractions.add(interaction);\r\n                    });\r\n                }\r\n                else {\r\n                    pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.\r\n                    interactions.forEach(function (interaction) {\r\n                        interaction.__count++;\r\n                    });\r\n                }\r\n                var subscriber = tracing.__subscriberRef.current;\r\n                if (subscriber !== null) {\r\n                    var threadID = computeThreadID(root, lane);\r\n                    subscriber.onWorkScheduled(interactions, threadID);\r\n                }\r\n            }\r\n        }\r\n        function schedulePendingInteractions(root, lane) {\r\n            scheduleInteractions(root, lane, tracing.__interactionsRef.current);\r\n        }\r\n        function startWorkOnPendingInteractions(root, lanes) {\r\n            // we can accurately attribute time spent working on it, And so that cascading\r\n            // work triggered during the render phase will be associated with it.\r\n            var interactions = new Set();\r\n            root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledLane) {\r\n                if (includesSomeLane(lanes, scheduledLane)) {\r\n                    scheduledInteractions.forEach(function (interaction) {\r\n                        return interactions.add(interaction);\r\n                    });\r\n                }\r\n            }); // Store the current set of interactions on the FiberRoot for a few reasons:\r\n            // We can re-use it in hot functions like performConcurrentWorkOnRoot()\r\n            // without having to recalculate it. We will also use it in commitWork() to\r\n            // pass to any Profiler onRender() hooks. This also provides DevTools with a\r\n            // way to access it when the onCommitRoot() hook is called.\r\n            root.memoizedInteractions = interactions;\r\n            if (interactions.size > 0) {\r\n                var subscriber = tracing.__subscriberRef.current;\r\n                if (subscriber !== null) {\r\n                    var threadID = computeThreadID(root, lanes);\r\n                    try {\r\n                        subscriber.onWorkStarted(interactions, threadID);\r\n                    }\r\n                    catch (error) {\r\n                        // If the subscriber throws, rethrow it in a separate task\r\n                        scheduleCallback(ImmediatePriority$1, function () {\r\n                            throw error;\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function finishPendingInteractions(root, committedLanes) {\r\n            var remainingLanesAfterCommit = root.pendingLanes;\r\n            var subscriber;\r\n            try {\r\n                subscriber = tracing.__subscriberRef.current;\r\n                if (subscriber !== null && root.memoizedInteractions.size > 0) {\r\n                    // FIXME: More than one lane can finish in a single commit.\r\n                    var threadID = computeThreadID(root, committedLanes);\r\n                    subscriber.onWorkStopped(root.memoizedInteractions, threadID);\r\n                }\r\n            }\r\n            catch (error) {\r\n                // If the subscriber throws, rethrow it in a separate task\r\n                scheduleCallback(ImmediatePriority$1, function () {\r\n                    throw error;\r\n                });\r\n            }\r\n            finally {\r\n                // Clear completed interactions from the pending Map.\r\n                // Unless the render was suspended or cascading work was scheduled,\r\n                // In which case– leave pending interactions until the subsequent render.\r\n                var pendingInteractionMap = root.pendingInteractionMap;\r\n                pendingInteractionMap.forEach(function (scheduledInteractions, lane) {\r\n                    // Only decrement the pending interaction count if we're done.\r\n                    // If there's still work at the current priority,\r\n                    // That indicates that we are waiting for suspense data.\r\n                    if (!includesSomeLane(remainingLanesAfterCommit, lane)) {\r\n                        pendingInteractionMap.delete(lane);\r\n                        scheduledInteractions.forEach(function (interaction) {\r\n                            interaction.__count--;\r\n                            if (subscriber !== null && interaction.__count === 0) {\r\n                                try {\r\n                                    subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n                                }\r\n                                catch (error) {\r\n                                    // If the subscriber throws, rethrow it in a separate task\r\n                                    scheduleCallback(ImmediatePriority$1, function () {\r\n                                        throw error;\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        } // `act` testing API\r\n        function shouldForceFlushFallbacksInDEV() {\r\n            // Never force flush in production. This function should get stripped out.\r\n            return actingUpdatesScopeDepth > 0;\r\n        }\r\n        // so we can tell if any async act() calls try to run in parallel.\r\n        var actingUpdatesScopeDepth = 0;\r\n        function detachFiberAfterEffects(fiber) {\r\n            fiber.sibling = null;\r\n            fiber.stateNode = null;\r\n        }\r\n        var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\r\n        var failedBoundaries = null;\r\n        var setRefreshHandler = function (handler) {\r\n            {\r\n                resolveFamily = handler;\r\n            }\r\n        };\r\n        function resolveFunctionForHotReloading(type) {\r\n            {\r\n                if (resolveFamily === null) {\r\n                    // Hot reloading is disabled.\r\n                    return type;\r\n                }\r\n                var family = resolveFamily(type);\r\n                if (family === undefined) {\r\n                    return type;\r\n                } // Use the latest known implementation.\r\n                return family.current;\r\n            }\r\n        }\r\n        function resolveClassForHotReloading(type) {\r\n            // No implementation differences.\r\n            return resolveFunctionForHotReloading(type);\r\n        }\r\n        function resolveForwardRefForHotReloading(type) {\r\n            {\r\n                if (resolveFamily === null) {\r\n                    // Hot reloading is disabled.\r\n                    return type;\r\n                }\r\n                var family = resolveFamily(type);\r\n                if (family === undefined) {\r\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\r\n                    if (type !== null && type !== undefined && typeof type.render === 'function') {\r\n                        // ForwardRef is special because its resolved .type is an object,\r\n                        // but it's possible that we only have its inner render function in the map.\r\n                        // If that inner render function is different, we'll build a new forwardRef type.\r\n                        var currentRender = resolveFunctionForHotReloading(type.render);\r\n                        if (type.render !== currentRender) {\r\n                            var syntheticType = {\r\n                                $$typeof: REACT_FORWARD_REF_TYPE,\r\n                                render: currentRender\r\n                            };\r\n                            if (type.displayName !== undefined) {\r\n                                syntheticType.displayName = type.displayName;\r\n                            }\r\n                            return syntheticType;\r\n                        }\r\n                    }\r\n                    return type;\r\n                } // Use the latest known implementation.\r\n                return family.current;\r\n            }\r\n        }\r\n        function isCompatibleFamilyForHotReloading(fiber, element) {\r\n            {\r\n                if (resolveFamily === null) {\r\n                    // Hot reloading is disabled.\r\n                    return false;\r\n                }\r\n                var prevType = fiber.elementType;\r\n                var nextType = element.type; // If we got here, we know types aren't === equal.\r\n                var needsCompareFamilies = false;\r\n                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\r\n                switch (fiber.tag) {\r\n                    case ClassComponent:\r\n                        {\r\n                            if (typeof nextType === 'function') {\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    case FunctionComponent:\r\n                        {\r\n                            if (typeof nextType === 'function') {\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n                                // We don't know the inner type yet.\r\n                                // We're going to assume that the lazy inner type is stable,\r\n                                // and so it is sufficient to avoid reconciling it away.\r\n                                // We're not going to unwrap or actually use the new lazy type.\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    case ForwardRef:\r\n                        {\r\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    case MemoComponent:\r\n                    case SimpleMemoComponent:\r\n                        {\r\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\r\n                                // TODO: if it was but can no longer be simple,\r\n                                // we shouldn't set this.\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            else if ($$typeofNextType === REACT_LAZY_TYPE) {\r\n                                needsCompareFamilies = true;\r\n                            }\r\n                            break;\r\n                        }\r\n                    default:\r\n                        return false;\r\n                } // Check if both types have a family and it's the same one.\r\n                if (needsCompareFamilies) {\r\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\r\n                    // This means both of them need to be registered to preserve state.\r\n                    // If we unwrapped and compared the inner types for wrappers instead,\r\n                    // then we would risk falsely saying two separate memo(Foo)\r\n                    // calls are equivalent because they wrap the same Foo function.\r\n                    var prevFamily = resolveFamily(prevType);\r\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        function markFailedErrorBoundaryForHotReloading(fiber) {\r\n            {\r\n                if (resolveFamily === null) {\r\n                    // Hot reloading is disabled.\r\n                    return;\r\n                }\r\n                if (typeof WeakSet !== 'function') {\r\n                    return;\r\n                }\r\n                if (failedBoundaries === null) {\r\n                    failedBoundaries = new WeakSet();\r\n                }\r\n                failedBoundaries.add(fiber);\r\n            }\r\n        }\r\n        var scheduleRefresh = function (root, update) {\r\n            {\r\n                if (resolveFamily === null) {\r\n                    // Hot reloading is disabled.\r\n                    return;\r\n                }\r\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\r\n                flushPassiveEffects();\r\n                flushSync(function () {\r\n                    scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\r\n                });\r\n            }\r\n        };\r\n        var scheduleRoot = function (root, element) {\r\n            {\r\n                if (root.context !== emptyContextObject) {\r\n                    // Super edge case: root has a legacy _renderSubtree context\r\n                    // but we don't know the parentComponent so we can't pass it.\r\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\r\n                    return;\r\n                }\r\n                flushPassiveEffects();\r\n                flushSync(function () {\r\n                    updateContainer(element, root, null, null);\r\n                });\r\n            }\r\n        };\r\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\r\n            {\r\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\r\n                var candidateType = null;\r\n                switch (tag) {\r\n                    case FunctionComponent:\r\n                    case SimpleMemoComponent:\r\n                    case ClassComponent:\r\n                        candidateType = type;\r\n                        break;\r\n                    case ForwardRef:\r\n                        candidateType = type.render;\r\n                        break;\r\n                }\r\n                if (resolveFamily === null) {\r\n                    throw new Error('Expected resolveFamily to be set during hot reload.');\r\n                }\r\n                var needsRender = false;\r\n                var needsRemount = false;\r\n                if (candidateType !== null) {\r\n                    var family = resolveFamily(candidateType);\r\n                    if (family !== undefined) {\r\n                        if (staleFamilies.has(family)) {\r\n                            needsRemount = true;\r\n                        }\r\n                        else if (updatedFamilies.has(family)) {\r\n                            if (tag === ClassComponent) {\r\n                                needsRemount = true;\r\n                            }\r\n                            else {\r\n                                needsRender = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (failedBoundaries !== null) {\r\n                    if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\r\n                        needsRemount = true;\r\n                    }\r\n                }\r\n                if (needsRemount) {\r\n                    fiber._debugNeedsRemount = true;\r\n                }\r\n                if (needsRemount || needsRender) {\r\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n                }\r\n                if (child !== null && !needsRemount) {\r\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\r\n                }\r\n                if (sibling !== null) {\r\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\r\n                }\r\n            }\r\n        }\r\n        var findHostInstancesForRefresh = function (root, families) {\r\n            {\r\n                var hostInstances = new Set();\r\n                var types = new Set(families.map(function (family) {\r\n                    return family.current;\r\n                }));\r\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\r\n                return hostInstances;\r\n            }\r\n        };\r\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\r\n            {\r\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\r\n                var candidateType = null;\r\n                switch (tag) {\r\n                    case FunctionComponent:\r\n                    case SimpleMemoComponent:\r\n                    case ClassComponent:\r\n                        candidateType = type;\r\n                        break;\r\n                    case ForwardRef:\r\n                        candidateType = type.render;\r\n                        break;\r\n                }\r\n                var didMatch = false;\r\n                if (candidateType !== null) {\r\n                    if (types.has(candidateType)) {\r\n                        didMatch = true;\r\n                    }\r\n                }\r\n                if (didMatch) {\r\n                    // We have a match. This only drills down to the closest host components.\r\n                    // There's no need to search deeper because for the purpose of giving\r\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\r\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\r\n                }\r\n                else {\r\n                    // If there's no match, maybe there will be one further down in the child tree.\r\n                    if (child !== null) {\r\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\r\n                    }\r\n                }\r\n                if (sibling !== null) {\r\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\r\n                }\r\n            }\r\n        }\r\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\r\n            {\r\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\r\n                if (foundHostInstances) {\r\n                    return;\r\n                } // If we didn't find any host children, fallback to closest host parent.\r\n                var node = fiber;\r\n                while (true) {\r\n                    switch (node.tag) {\r\n                        case HostComponent:\r\n                            hostInstances.add(node.stateNode);\r\n                            return;\r\n                        case HostPortal:\r\n                            hostInstances.add(node.stateNode.containerInfo);\r\n                            return;\r\n                        case HostRoot:\r\n                            hostInstances.add(node.stateNode.containerInfo);\r\n                            return;\r\n                    }\r\n                    if (node.return === null) {\r\n                        throw new Error('Expected to reach root first.');\r\n                    }\r\n                    node = node.return;\r\n                }\r\n            }\r\n        }\r\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\r\n            {\r\n                var node = fiber;\r\n                var foundHostInstances = false;\r\n                while (true) {\r\n                    if (node.tag === HostComponent) {\r\n                        // We got a match.\r\n                        foundHostInstances = true;\r\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\r\n                    }\r\n                    else if (node.child !== null) {\r\n                        node.child.return = node;\r\n                        node = node.child;\r\n                        continue;\r\n                    }\r\n                    if (node === fiber) {\r\n                        return foundHostInstances;\r\n                    }\r\n                    while (node.sibling === null) {\r\n                        if (node.return === null || node.return === fiber) {\r\n                            return foundHostInstances;\r\n                        }\r\n                        node = node.return;\r\n                    }\r\n                    node.sibling.return = node.return;\r\n                    node = node.sibling;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        var hasBadMapPolyfill;\r\n        {\r\n            hasBadMapPolyfill = false;\r\n            try {\r\n                var nonExtensibleObject = Object.preventExtensions({});\r\n                /* eslint-disable no-new */\r\n                new Map([[nonExtensibleObject, null]]);\r\n                new Set([nonExtensibleObject]);\r\n                /* eslint-enable no-new */\r\n            }\r\n            catch (e) {\r\n                // TODO: Consider warning about bad polyfills\r\n                hasBadMapPolyfill = true;\r\n            }\r\n        }\r\n        var debugCounter = 1;\r\n        function FiberNode(tag, pendingProps, key, mode) {\r\n            // Instance\r\n            this.tag = tag;\r\n            this.key = key;\r\n            this.elementType = null;\r\n            this.type = null;\r\n            this.stateNode = null; // Fiber\r\n            this.return = null;\r\n            this.child = null;\r\n            this.sibling = null;\r\n            this.index = 0;\r\n            this.ref = null;\r\n            this.pendingProps = pendingProps;\r\n            this.memoizedProps = null;\r\n            this.updateQueue = null;\r\n            this.memoizedState = null;\r\n            this.dependencies = null;\r\n            this.mode = mode; // Effects\r\n            this.flags = NoFlags;\r\n            this.nextEffect = null;\r\n            this.firstEffect = null;\r\n            this.lastEffect = null;\r\n            this.lanes = NoLanes;\r\n            this.childLanes = NoLanes;\r\n            this.alternate = null;\r\n            {\r\n                // Note: The following is done to avoid a v8 performance cliff.\r\n                //\r\n                // Initializing the fields below to smis and later updating them with\r\n                // double values will cause Fibers to end up having separate shapes.\r\n                // This behavior/bug has something to do with Object.preventExtension().\r\n                // Fortunately this only impacts DEV builds.\r\n                // Unfortunately it makes React unusably slow for some applications.\r\n                // To work around this, initialize the fields below with doubles.\r\n                //\r\n                // Learn more about this here:\r\n                // https://github.com/facebook/react/issues/14365\r\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\r\n                this.actualDuration = Number.NaN;\r\n                this.actualStartTime = Number.NaN;\r\n                this.selfBaseDuration = Number.NaN;\r\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\r\n                // This won't trigger the performance cliff mentioned above,\r\n                // and it simplifies other profiler code (including DevTools).\r\n                this.actualDuration = 0;\r\n                this.actualStartTime = -1;\r\n                this.selfBaseDuration = 0;\r\n                this.treeBaseDuration = 0;\r\n            }\r\n            {\r\n                // This isn't directly used but is handy for debugging internals:\r\n                this._debugID = debugCounter++;\r\n                this._debugSource = null;\r\n                this._debugOwner = null;\r\n                this._debugNeedsRemount = false;\r\n                this._debugHookTypes = null;\r\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\r\n                    Object.preventExtensions(this);\r\n                }\r\n            }\r\n        } // This is a constructor function, rather than a POJO constructor, still\r\n        // please ensure we do the following:\r\n        // 1) Nobody should add any instance methods on this. Instance methods can be\r\n        //    more difficult to predict when they get optimized and they are almost\r\n        //    never inlined properly in static compilers.\r\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\r\n        //    always know when it is a fiber.\r\n        // 3) We might want to experiment with using numeric keys since they are easier\r\n        //    to optimize in a non-JIT environment.\r\n        // 4) We can easily go from a constructor to a createFiber object literal if that\r\n        //    is faster.\r\n        // 5) It should be easy to port this to a C struct and keep a C implementation\r\n        //    compatible.\r\n        var createFiber = function (tag, pendingProps, key, mode) {\r\n            // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\r\n            return new FiberNode(tag, pendingProps, key, mode);\r\n        };\r\n        function shouldConstruct$1(Component) {\r\n            var prototype = Component.prototype;\r\n            return !!(prototype && prototype.isReactComponent);\r\n        }\r\n        function isSimpleFunctionComponent(type) {\r\n            return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;\r\n        }\r\n        function resolveLazyComponentTag(Component) {\r\n            if (typeof Component === 'function') {\r\n                return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\r\n            }\r\n            else if (Component !== undefined && Component !== null) {\r\n                var $$typeof = Component.$$typeof;\r\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\r\n                    return ForwardRef;\r\n                }\r\n                if ($$typeof === REACT_MEMO_TYPE) {\r\n                    return MemoComponent;\r\n                }\r\n            }\r\n            return IndeterminateComponent;\r\n        } // This is used to create an alternate fiber to do work on.\r\n        function createWorkInProgress(current, pendingProps) {\r\n            var workInProgress = current.alternate;\r\n            if (workInProgress === null) {\r\n                // We use a double buffering pooling technique because we know that we'll\r\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\r\n                // node that we're free to reuse. This is lazily created to avoid allocating\r\n                // extra objects for things that are never updated. It also allow us to\r\n                // reclaim the extra memory if needed.\r\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\r\n                workInProgress.elementType = current.elementType;\r\n                workInProgress.type = current.type;\r\n                workInProgress.stateNode = current.stateNode;\r\n                {\r\n                    // DEV-only fields\r\n                    workInProgress._debugID = current._debugID;\r\n                    workInProgress._debugSource = current._debugSource;\r\n                    workInProgress._debugOwner = current._debugOwner;\r\n                    workInProgress._debugHookTypes = current._debugHookTypes;\r\n                }\r\n                workInProgress.alternate = current;\r\n                current.alternate = workInProgress;\r\n            }\r\n            else {\r\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\r\n                workInProgress.type = current.type; // We already have an alternate.\r\n                // Reset the effect tag.\r\n                workInProgress.flags = NoFlags; // The effect list is no longer valid.\r\n                workInProgress.nextEffect = null;\r\n                workInProgress.firstEffect = null;\r\n                workInProgress.lastEffect = null;\r\n                {\r\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\r\n                    // This prevents time from endlessly accumulating in new commits.\r\n                    // This has the downside of resetting values for different priority renders,\r\n                    // But works for yielding (the common case) and should support resuming.\r\n                    workInProgress.actualDuration = 0;\r\n                    workInProgress.actualStartTime = -1;\r\n                }\r\n            }\r\n            workInProgress.childLanes = current.childLanes;\r\n            workInProgress.lanes = current.lanes;\r\n            workInProgress.child = current.child;\r\n            workInProgress.memoizedProps = current.memoizedProps;\r\n            workInProgress.memoizedState = current.memoizedState;\r\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\r\n            // it cannot be shared with the current fiber.\r\n            var currentDependencies = current.dependencies;\r\n            workInProgress.dependencies = currentDependencies === null ? null : {\r\n                lanes: currentDependencies.lanes,\r\n                firstContext: currentDependencies.firstContext\r\n            }; // These will be overridden during the parent's reconciliation\r\n            workInProgress.sibling = current.sibling;\r\n            workInProgress.index = current.index;\r\n            workInProgress.ref = current.ref;\r\n            {\r\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\r\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\r\n            }\r\n            {\r\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\r\n                switch (workInProgress.tag) {\r\n                    case IndeterminateComponent:\r\n                    case FunctionComponent:\r\n                    case SimpleMemoComponent:\r\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\r\n                        break;\r\n                    case ClassComponent:\r\n                        workInProgress.type = resolveClassForHotReloading(current.type);\r\n                        break;\r\n                    case ForwardRef:\r\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\r\n                        break;\r\n                }\r\n            }\r\n            return workInProgress;\r\n        } // Used to reuse a Fiber for a second pass.\r\n        function resetWorkInProgress(workInProgress, renderLanes) {\r\n            // This resets the Fiber to what createFiber or createWorkInProgress would\r\n            // have set the values to before during the first pass. Ideally this wouldn't\r\n            // be necessary but unfortunately many code paths reads from the workInProgress\r\n            // when they should be reading from current and writing to workInProgress.\r\n            // We assume pendingProps, index, key, ref, return are still untouched to\r\n            // avoid doing another reconciliation.\r\n            // Reset the effect tag but keep any Placement tags, since that's something\r\n            // that child fiber is setting, not the reconciliation.\r\n            workInProgress.flags &= Placement; // The effect list is no longer valid.\r\n            workInProgress.nextEffect = null;\r\n            workInProgress.firstEffect = null;\r\n            workInProgress.lastEffect = null;\r\n            var current = workInProgress.alternate;\r\n            if (current === null) {\r\n                // Reset to createFiber's initial values.\r\n                workInProgress.childLanes = NoLanes;\r\n                workInProgress.lanes = renderLanes;\r\n                workInProgress.child = null;\r\n                workInProgress.memoizedProps = null;\r\n                workInProgress.memoizedState = null;\r\n                workInProgress.updateQueue = null;\r\n                workInProgress.dependencies = null;\r\n                workInProgress.stateNode = null;\r\n                {\r\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\r\n                    // actual time across multiple render passes.\r\n                    workInProgress.selfBaseDuration = 0;\r\n                    workInProgress.treeBaseDuration = 0;\r\n                }\r\n            }\r\n            else {\r\n                // Reset to the cloned values that createWorkInProgress would've.\r\n                workInProgress.childLanes = current.childLanes;\r\n                workInProgress.lanes = current.lanes;\r\n                workInProgress.child = current.child;\r\n                workInProgress.memoizedProps = current.memoizedProps;\r\n                workInProgress.memoizedState = current.memoizedState;\r\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\r\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\r\n                // it cannot be shared with the current fiber.\r\n                var currentDependencies = current.dependencies;\r\n                workInProgress.dependencies = currentDependencies === null ? null : {\r\n                    lanes: currentDependencies.lanes,\r\n                    firstContext: currentDependencies.firstContext\r\n                };\r\n                {\r\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\r\n                    // actual time across multiple render passes.\r\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\r\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\r\n                }\r\n            }\r\n            return workInProgress;\r\n        }\r\n        function createHostRootFiber(tag) {\r\n            var mode;\r\n            if (tag === ConcurrentRoot) {\r\n                mode = ConcurrentMode | BlockingMode | StrictMode;\r\n            }\r\n            else if (tag === BlockingRoot) {\r\n                mode = BlockingMode | StrictMode;\r\n            }\r\n            else {\r\n                mode = NoMode;\r\n            }\r\n            if (isDevToolsPresent) {\r\n                // Always collect profile timings when DevTools are present.\r\n                // This enables DevTools to start capturing timing at any point–\r\n                // Without some nodes in the tree having empty base times.\r\n                mode |= ProfileMode;\r\n            }\r\n            return createFiber(HostRoot, null, null, mode);\r\n        }\r\n        function createFiberFromTypeAndProps(type, // React$ElementType\r\n        key, pendingProps, owner, mode, lanes) {\r\n            var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\r\n            var resolvedType = type;\r\n            if (typeof type === 'function') {\r\n                if (shouldConstruct$1(type)) {\r\n                    fiberTag = ClassComponent;\r\n                    {\r\n                        resolvedType = resolveClassForHotReloading(resolvedType);\r\n                    }\r\n                }\r\n                else {\r\n                    {\r\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\r\n                    }\r\n                }\r\n            }\r\n            else if (typeof type === 'string') {\r\n                fiberTag = HostComponent;\r\n            }\r\n            else {\r\n                getTag: switch (type) {\r\n                    case REACT_FRAGMENT_TYPE:\r\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\r\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\r\n                        fiberTag = Mode;\r\n                        mode |= DebugTracingMode;\r\n                        break;\r\n                    case REACT_STRICT_MODE_TYPE:\r\n                        fiberTag = Mode;\r\n                        mode |= StrictMode;\r\n                        break;\r\n                    case REACT_PROFILER_TYPE:\r\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\r\n                    case REACT_SUSPENSE_TYPE:\r\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\r\n                    case REACT_SUSPENSE_LIST_TYPE:\r\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\r\n                    case REACT_OFFSCREEN_TYPE:\r\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\r\n                    case REACT_LEGACY_HIDDEN_TYPE:\r\n                        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);\r\n                    case REACT_SCOPE_TYPE:\r\n                    // eslint-disable-next-line no-fallthrough\r\n                    default:\r\n                        {\r\n                            if (typeof type === 'object' && type !== null) {\r\n                                switch (type.$$typeof) {\r\n                                    case REACT_PROVIDER_TYPE:\r\n                                        fiberTag = ContextProvider;\r\n                                        break getTag;\r\n                                    case REACT_CONTEXT_TYPE:\r\n                                        // This is a consumer\r\n                                        fiberTag = ContextConsumer;\r\n                                        break getTag;\r\n                                    case REACT_FORWARD_REF_TYPE:\r\n                                        fiberTag = ForwardRef;\r\n                                        {\r\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\r\n                                        }\r\n                                        break getTag;\r\n                                    case REACT_MEMO_TYPE:\r\n                                        fiberTag = MemoComponent;\r\n                                        break getTag;\r\n                                    case REACT_LAZY_TYPE:\r\n                                        fiberTag = LazyComponent;\r\n                                        resolvedType = null;\r\n                                        break getTag;\r\n                                    case REACT_BLOCK_TYPE:\r\n                                        fiberTag = Block;\r\n                                        break getTag;\r\n                                }\r\n                            }\r\n                            var info = '';\r\n                            {\r\n                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n                                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\r\n                                }\r\n                                var ownerName = owner ? getComponentName(owner.type) : null;\r\n                                if (ownerName) {\r\n                                    info += '\\n\\nCheck the render method of `' + ownerName + '`.';\r\n                                }\r\n                            }\r\n                            {\r\n                                {\r\n                                    throw Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (type == null ? type : typeof type) + \".\" + info);\r\n                                }\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\r\n            fiber.elementType = type;\r\n            fiber.type = resolvedType;\r\n            fiber.lanes = lanes;\r\n            {\r\n                fiber._debugOwner = owner;\r\n            }\r\n            return fiber;\r\n        }\r\n        function createFiberFromElement(element, mode, lanes) {\r\n            var owner = null;\r\n            {\r\n                owner = element._owner;\r\n            }\r\n            var type = element.type;\r\n            var key = element.key;\r\n            var pendingProps = element.props;\r\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\r\n            {\r\n                fiber._debugSource = element._source;\r\n                fiber._debugOwner = element._owner;\r\n            }\r\n            return fiber;\r\n        }\r\n        function createFiberFromFragment(elements, mode, lanes, key) {\r\n            var fiber = createFiber(Fragment, elements, key, mode);\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\r\n            {\r\n                if (typeof pendingProps.id !== 'string') {\r\n                    error('Profiler must specify an \"id\" as a prop');\r\n                }\r\n            }\r\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.\r\n            fiber.elementType = REACT_PROFILER_TYPE;\r\n            fiber.type = REACT_PROFILER_TYPE;\r\n            fiber.lanes = lanes;\r\n            {\r\n                fiber.stateNode = {\r\n                    effectDuration: 0,\r\n                    passiveEffectDuration: 0\r\n                };\r\n            }\r\n            return fiber;\r\n        }\r\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\r\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.\r\n            // This needs to be fixed in getComponentName so that it relies on the tag\r\n            // instead.\r\n            fiber.type = REACT_SUSPENSE_TYPE;\r\n            fiber.elementType = REACT_SUSPENSE_TYPE;\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\r\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\r\n            {\r\n                // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.\r\n                // This needs to be fixed in getComponentName so that it relies on the tag\r\n                // instead.\r\n                fiber.type = REACT_SUSPENSE_LIST_TYPE;\r\n            }\r\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\r\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.\r\n            // This needs to be fixed in getComponentName so that it relies on the tag\r\n            // instead.\r\n            {\r\n                fiber.type = REACT_OFFSCREEN_TYPE;\r\n            }\r\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {\r\n            var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.\r\n            // This needs to be fixed in getComponentName so that it relies on the tag\r\n            // instead.\r\n            {\r\n                fiber.type = REACT_LEGACY_HIDDEN_TYPE;\r\n            }\r\n            fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromText(content, mode, lanes) {\r\n            var fiber = createFiber(HostText, content, null, mode);\r\n            fiber.lanes = lanes;\r\n            return fiber;\r\n        }\r\n        function createFiberFromHostInstanceForDeletion() {\r\n            var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.\r\n            fiber.elementType = 'DELETED';\r\n            fiber.type = 'DELETED';\r\n            return fiber;\r\n        }\r\n        function createFiberFromPortal(portal, mode, lanes) {\r\n            var pendingProps = portal.children !== null ? portal.children : [];\r\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\r\n            fiber.lanes = lanes;\r\n            fiber.stateNode = {\r\n                containerInfo: portal.containerInfo,\r\n                pendingChildren: null,\r\n                // Used by persistent updates\r\n                implementation: portal.implementation\r\n            };\r\n            return fiber;\r\n        } // Used for stashing WIP properties to replay failed work in DEV.\r\n        function assignFiberPropertiesInDEV(target, source) {\r\n            if (target === null) {\r\n                // This Fiber's initial properties will always be overwritten.\r\n                // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\r\n                target = createFiber(IndeterminateComponent, null, null, NoMode);\r\n            } // This is intentionally written as a list of all properties.\r\n            // We tried to use Object.assign() instead but this is called in\r\n            // the hottest path, and Object.assign() was too slow:\r\n            // https://github.com/facebook/react/issues/12502\r\n            // This code is DEV-only so size is not a concern.\r\n            target.tag = source.tag;\r\n            target.key = source.key;\r\n            target.elementType = source.elementType;\r\n            target.type = source.type;\r\n            target.stateNode = source.stateNode;\r\n            target.return = source.return;\r\n            target.child = source.child;\r\n            target.sibling = source.sibling;\r\n            target.index = source.index;\r\n            target.ref = source.ref;\r\n            target.pendingProps = source.pendingProps;\r\n            target.memoizedProps = source.memoizedProps;\r\n            target.updateQueue = source.updateQueue;\r\n            target.memoizedState = source.memoizedState;\r\n            target.dependencies = source.dependencies;\r\n            target.mode = source.mode;\r\n            target.flags = source.flags;\r\n            target.nextEffect = source.nextEffect;\r\n            target.firstEffect = source.firstEffect;\r\n            target.lastEffect = source.lastEffect;\r\n            target.lanes = source.lanes;\r\n            target.childLanes = source.childLanes;\r\n            target.alternate = source.alternate;\r\n            {\r\n                target.actualDuration = source.actualDuration;\r\n                target.actualStartTime = source.actualStartTime;\r\n                target.selfBaseDuration = source.selfBaseDuration;\r\n                target.treeBaseDuration = source.treeBaseDuration;\r\n            }\r\n            target._debugID = source._debugID;\r\n            target._debugSource = source._debugSource;\r\n            target._debugOwner = source._debugOwner;\r\n            target._debugNeedsRemount = source._debugNeedsRemount;\r\n            target._debugHookTypes = source._debugHookTypes;\r\n            return target;\r\n        }\r\n        function FiberRootNode(containerInfo, tag, hydrate) {\r\n            this.tag = tag;\r\n            this.containerInfo = containerInfo;\r\n            this.pendingChildren = null;\r\n            this.current = null;\r\n            this.pingCache = null;\r\n            this.finishedWork = null;\r\n            this.timeoutHandle = noTimeout;\r\n            this.context = null;\r\n            this.pendingContext = null;\r\n            this.hydrate = hydrate;\r\n            this.callbackNode = null;\r\n            this.callbackPriority = NoLanePriority;\r\n            this.eventTimes = createLaneMap(NoLanes);\r\n            this.expirationTimes = createLaneMap(NoTimestamp);\r\n            this.pendingLanes = NoLanes;\r\n            this.suspendedLanes = NoLanes;\r\n            this.pingedLanes = NoLanes;\r\n            this.expiredLanes = NoLanes;\r\n            this.mutableReadLanes = NoLanes;\r\n            this.finishedLanes = NoLanes;\r\n            this.entangledLanes = NoLanes;\r\n            this.entanglements = createLaneMap(NoLanes);\r\n            {\r\n                this.mutableSourceEagerHydrationData = null;\r\n            }\r\n            {\r\n                this.interactionThreadID = tracing.unstable_getThreadID();\r\n                this.memoizedInteractions = new Set();\r\n                this.pendingInteractionMap = new Map();\r\n            }\r\n            {\r\n                switch (tag) {\r\n                    case BlockingRoot:\r\n                        this._debugRootType = 'createBlockingRoot()';\r\n                        break;\r\n                    case ConcurrentRoot:\r\n                        this._debugRootType = 'createRoot()';\r\n                        break;\r\n                    case LegacyRoot:\r\n                        this._debugRootType = 'createLegacyRoot()';\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {\r\n            var root = new FiberRootNode(containerInfo, tag, hydrate);\r\n            // stateNode is any.\r\n            var uninitializedFiber = createHostRootFiber(tag);\r\n            root.current = uninitializedFiber;\r\n            uninitializedFiber.stateNode = root;\r\n            initializeUpdateQueue(uninitializedFiber);\r\n            return root;\r\n        }\r\n        // This ensures that the version used for server rendering matches the one\r\n        // that is eventually read during hydration.\r\n        // If they don't match there's a potential tear and a full deopt render is required.\r\n        function registerMutableSourceForHydration(root, mutableSource) {\r\n            var getVersion = mutableSource._getVersion;\r\n            var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\r\n            // Retaining it forever may interfere with GC.\r\n            if (root.mutableSourceEagerHydrationData == null) {\r\n                root.mutableSourceEagerHydrationData = [mutableSource, version];\r\n            }\r\n            else {\r\n                root.mutableSourceEagerHydrationData.push(mutableSource, version);\r\n            }\r\n        }\r\n        function createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\r\n        implementation) {\r\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\r\n            return {\r\n                // This tag allow us to uniquely identify this as a React Portal\r\n                $$typeof: REACT_PORTAL_TYPE,\r\n                key: key == null ? null : '' + key,\r\n                children: children,\r\n                containerInfo: containerInfo,\r\n                implementation: implementation\r\n            };\r\n        }\r\n        var didWarnAboutNestedUpdates;\r\n        var didWarnAboutFindNodeInStrictMode;\r\n        {\r\n            didWarnAboutNestedUpdates = false;\r\n            didWarnAboutFindNodeInStrictMode = {};\r\n        }\r\n        function getContextForSubtree(parentComponent) {\r\n            if (!parentComponent) {\r\n                return emptyContextObject;\r\n            }\r\n            var fiber = get(parentComponent);\r\n            var parentContext = findCurrentUnmaskedContext(fiber);\r\n            if (fiber.tag === ClassComponent) {\r\n                var Component = fiber.type;\r\n                if (isContextProvider(Component)) {\r\n                    return processChildContext(fiber, Component, parentContext);\r\n                }\r\n            }\r\n            return parentContext;\r\n        }\r\n        function findHostInstanceWithWarning(component, methodName) {\r\n            {\r\n                var fiber = get(component);\r\n                if (fiber === undefined) {\r\n                    if (typeof component.render === 'function') {\r\n                        {\r\n                            {\r\n                                throw Error(\"Unable to find node on an unmounted component.\");\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        {\r\n                            {\r\n                                throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + Object.keys(component));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var hostFiber = findCurrentHostFiber(fiber);\r\n                if (hostFiber === null) {\r\n                    return null;\r\n                }\r\n                if (hostFiber.mode & StrictMode) {\r\n                    var componentName = getComponentName(fiber.type) || 'Component';\r\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\r\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\r\n                        var previousFiber = current;\r\n                        try {\r\n                            setCurrentFiber(hostFiber);\r\n                            if (fiber.mode & StrictMode) {\r\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\r\n                            }\r\n                            else {\r\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\r\n                            }\r\n                        }\r\n                        finally {\r\n                            // Ideally this should reset to previous but this shouldn't be called in\r\n                            // render and there's another warning for that anyway.\r\n                            if (previousFiber) {\r\n                                setCurrentFiber(previousFiber);\r\n                            }\r\n                            else {\r\n                                resetCurrentFiber();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return hostFiber.stateNode;\r\n            }\r\n        }\r\n        function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {\r\n            return createFiberRoot(containerInfo, tag, hydrate);\r\n        }\r\n        function updateContainer(element, container, parentComponent, callback) {\r\n            {\r\n                onScheduleRoot(container, element);\r\n            }\r\n            var current$1 = container.current;\r\n            var eventTime = requestEventTime();\r\n            {\r\n                // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\r\n                if ('undefined' !== typeof jest) {\r\n                    warnIfUnmockedScheduler(current$1);\r\n                    warnIfNotScopedWithMatchingAct(current$1);\r\n                }\r\n            }\r\n            var lane = requestUpdateLane(current$1);\r\n            var context = getContextForSubtree(parentComponent);\r\n            if (container.context === null) {\r\n                container.context = context;\r\n            }\r\n            else {\r\n                container.pendingContext = context;\r\n            }\r\n            {\r\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\r\n                    didWarnAboutNestedUpdates = true;\r\n                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');\r\n                }\r\n            }\r\n            var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\r\n            // being called \"element\".\r\n            update.payload = {\r\n                element: element\r\n            };\r\n            callback = callback === undefined ? null : callback;\r\n            if (callback !== null) {\r\n                {\r\n                    if (typeof callback !== 'function') {\r\n                        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\r\n                    }\r\n                }\r\n                update.callback = callback;\r\n            }\r\n            enqueueUpdate(current$1, update);\r\n            scheduleUpdateOnFiber(current$1, lane, eventTime);\r\n            return lane;\r\n        }\r\n        function getPublicRootInstance(container) {\r\n            var containerFiber = container.current;\r\n            if (!containerFiber.child) {\r\n                return null;\r\n            }\r\n            switch (containerFiber.child.tag) {\r\n                case HostComponent:\r\n                    return getPublicInstance(containerFiber.child.stateNode);\r\n                default:\r\n                    return containerFiber.child.stateNode;\r\n            }\r\n        }\r\n        function markRetryLaneImpl(fiber, retryLane) {\r\n            var suspenseState = fiber.memoizedState;\r\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\r\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\r\n            }\r\n        } // Increases the priority of thennables when they resolve within this boundary.\r\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\r\n            markRetryLaneImpl(fiber, retryLane);\r\n            var alternate = fiber.alternate;\r\n            if (alternate) {\r\n                markRetryLaneImpl(alternate, retryLane);\r\n            }\r\n        }\r\n        function attemptUserBlockingHydration$1(fiber) {\r\n            if (fiber.tag !== SuspenseComponent) {\r\n                // We ignore HostRoots here because we can't increase\r\n                // their priority and they should not suspend on I/O,\r\n                // since you have to wrap anything that might suspend in\r\n                // Suspense.\r\n                return;\r\n            }\r\n            var eventTime = requestEventTime();\r\n            var lane = InputDiscreteHydrationLane;\r\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            markRetryLaneIfNotHydrated(fiber, lane);\r\n        }\r\n        function attemptContinuousHydration$1(fiber) {\r\n            if (fiber.tag !== SuspenseComponent) {\r\n                // We ignore HostRoots here because we can't increase\r\n                // their priority and they should not suspend on I/O,\r\n                // since you have to wrap anything that might suspend in\r\n                // Suspense.\r\n                return;\r\n            }\r\n            var eventTime = requestEventTime();\r\n            var lane = SelectiveHydrationLane;\r\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            markRetryLaneIfNotHydrated(fiber, lane);\r\n        }\r\n        function attemptHydrationAtCurrentPriority$1(fiber) {\r\n            if (fiber.tag !== SuspenseComponent) {\r\n                // We ignore HostRoots here because we can't increase\r\n                // their priority other than synchronously flush it.\r\n                return;\r\n            }\r\n            var eventTime = requestEventTime();\r\n            var lane = requestUpdateLane(fiber);\r\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\r\n            markRetryLaneIfNotHydrated(fiber, lane);\r\n        }\r\n        function runWithPriority$2(priority, fn) {\r\n            try {\r\n                setCurrentUpdateLanePriority(priority);\r\n                return fn();\r\n            }\r\n            finally {\r\n            }\r\n        }\r\n        function findHostInstanceWithNoPortals(fiber) {\r\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\r\n            if (hostFiber === null) {\r\n                return null;\r\n            }\r\n            if (hostFiber.tag === FundamentalComponent) {\r\n                return hostFiber.stateNode.instance;\r\n            }\r\n            return hostFiber.stateNode;\r\n        }\r\n        var shouldSuspendImpl = function (fiber) {\r\n            return false;\r\n        };\r\n        function shouldSuspend(fiber) {\r\n            return shouldSuspendImpl(fiber);\r\n        }\r\n        var overrideHookState = null;\r\n        var overrideHookStateDeletePath = null;\r\n        var overrideHookStateRenamePath = null;\r\n        var overrideProps = null;\r\n        var overridePropsDeletePath = null;\r\n        var overridePropsRenamePath = null;\r\n        var scheduleUpdate = null;\r\n        var setSuspenseHandler = null;\r\n        {\r\n            var copyWithDeleteImpl = function (obj, path, index) {\r\n                var key = path[index];\r\n                var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);\r\n                if (index + 1 === path.length) {\r\n                    if (Array.isArray(updated)) {\r\n                        updated.splice(key, 1);\r\n                    }\r\n                    else {\r\n                        delete updated[key];\r\n                    }\r\n                    return updated;\r\n                } // $FlowFixMe number or string is fine here\r\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\r\n                return updated;\r\n            };\r\n            var copyWithDelete = function (obj, path) {\r\n                return copyWithDeleteImpl(obj, path, 0);\r\n            };\r\n            var copyWithRenameImpl = function (obj, oldPath, newPath, index) {\r\n                var oldKey = oldPath[index];\r\n                var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);\r\n                if (index + 1 === oldPath.length) {\r\n                    var newKey = newPath[index]; // $FlowFixMe number or string is fine here\r\n                    updated[newKey] = updated[oldKey];\r\n                    if (Array.isArray(updated)) {\r\n                        updated.splice(oldKey, 1);\r\n                    }\r\n                    else {\r\n                        delete updated[oldKey];\r\n                    }\r\n                }\r\n                else {\r\n                    // $FlowFixMe number or string is fine here\r\n                    updated[oldKey] = copyWithRenameImpl(// $FlowFixMe number or string is fine here\r\n                    obj[oldKey], oldPath, newPath, index + 1);\r\n                }\r\n                return updated;\r\n            };\r\n            var copyWithRename = function (obj, oldPath, newPath) {\r\n                if (oldPath.length !== newPath.length) {\r\n                    warn('copyWithRename() expects paths of the same length');\r\n                    return;\r\n                }\r\n                else {\r\n                    for (var i = 0; i < newPath.length - 1; i++) {\r\n                        if (oldPath[i] !== newPath[i]) {\r\n                            warn('copyWithRename() expects paths to be the same except for the deepest key');\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\r\n            };\r\n            var copyWithSetImpl = function (obj, path, index, value) {\r\n                if (index >= path.length) {\r\n                    return value;\r\n                }\r\n                var key = path[index];\r\n                var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); // $FlowFixMe number or string is fine here\r\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\r\n                return updated;\r\n            };\r\n            var copyWithSet = function (obj, path, value) {\r\n                return copyWithSetImpl(obj, path, 0, value);\r\n            };\r\n            var findHook = function (fiber, id) {\r\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\r\n                // This may change in the future with e.g. nested hooks.\r\n                var currentHook = fiber.memoizedState;\r\n                while (currentHook !== null && id > 0) {\r\n                    currentHook = currentHook.next;\r\n                    id--;\r\n                }\r\n                return currentHook;\r\n            }; // Support DevTools editable values for useState and useReducer.\r\n            overrideHookState = function (fiber, id, path, value) {\r\n                var hook = findHook(fiber, id);\r\n                if (hook !== null) {\r\n                    var newState = copyWithSet(hook.memoizedState, path, value);\r\n                    hook.memoizedState = newState;\r\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\r\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n                    // (There's no appropriate action type for DevTools overrides.)\r\n                    // As a result though, React will see the scheduled update as a noop and bailout.\r\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n                    fiber.memoizedProps = _assign({}, fiber.memoizedProps);\r\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n                }\r\n            };\r\n            overrideHookStateDeletePath = function (fiber, id, path) {\r\n                var hook = findHook(fiber, id);\r\n                if (hook !== null) {\r\n                    var newState = copyWithDelete(hook.memoizedState, path);\r\n                    hook.memoizedState = newState;\r\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\r\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n                    // (There's no appropriate action type for DevTools overrides.)\r\n                    // As a result though, React will see the scheduled update as a noop and bailout.\r\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n                    fiber.memoizedProps = _assign({}, fiber.memoizedProps);\r\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n                }\r\n            };\r\n            overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {\r\n                var hook = findHook(fiber, id);\r\n                if (hook !== null) {\r\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\r\n                    hook.memoizedState = newState;\r\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\r\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\r\n                    // (There's no appropriate action type for DevTools overrides.)\r\n                    // As a result though, React will see the scheduled update as a noop and bailout.\r\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\r\n                    fiber.memoizedProps = _assign({}, fiber.memoizedProps);\r\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n                }\r\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\r\n            overrideProps = function (fiber, path, value) {\r\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\r\n                if (fiber.alternate) {\r\n                    fiber.alternate.pendingProps = fiber.pendingProps;\r\n                }\r\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n            };\r\n            overridePropsDeletePath = function (fiber, path) {\r\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\r\n                if (fiber.alternate) {\r\n                    fiber.alternate.pendingProps = fiber.pendingProps;\r\n                }\r\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n            };\r\n            overridePropsRenamePath = function (fiber, oldPath, newPath) {\r\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\r\n                if (fiber.alternate) {\r\n                    fiber.alternate.pendingProps = fiber.pendingProps;\r\n                }\r\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n            };\r\n            scheduleUpdate = function (fiber) {\r\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\r\n            };\r\n            setSuspenseHandler = function (newShouldSuspendImpl) {\r\n                shouldSuspendImpl = newShouldSuspendImpl;\r\n            };\r\n        }\r\n        function findHostInstanceByFiber(fiber) {\r\n            var hostFiber = findCurrentHostFiber(fiber);\r\n            if (hostFiber === null) {\r\n                return null;\r\n            }\r\n            return hostFiber.stateNode;\r\n        }\r\n        function emptyFindFiberByHostInstance(instance) {\r\n            return null;\r\n        }\r\n        function getCurrentFiberForDevTools() {\r\n            return current;\r\n        }\r\n        function injectIntoDevTools(devToolsConfig) {\r\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\r\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\n            return injectInternals({\r\n                bundleType: devToolsConfig.bundleType,\r\n                version: devToolsConfig.version,\r\n                rendererPackageName: devToolsConfig.rendererPackageName,\r\n                rendererConfig: devToolsConfig.rendererConfig,\r\n                overrideHookState: overrideHookState,\r\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\r\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\r\n                overrideProps: overrideProps,\r\n                overridePropsDeletePath: overridePropsDeletePath,\r\n                overridePropsRenamePath: overridePropsRenamePath,\r\n                setSuspenseHandler: setSuspenseHandler,\r\n                scheduleUpdate: scheduleUpdate,\r\n                currentDispatcherRef: ReactCurrentDispatcher,\r\n                findHostInstanceByFiber: findHostInstanceByFiber,\r\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\r\n                // React Refresh\r\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\r\n                scheduleRefresh: scheduleRefresh,\r\n                scheduleRoot: scheduleRoot,\r\n                setRefreshHandler: setRefreshHandler,\r\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\r\n                getCurrentFiber: getCurrentFiberForDevTools\r\n            });\r\n        }\r\n        function ReactDOMRoot(container, options) {\r\n            this._internalRoot = createRootImpl(container, ConcurrentRoot, options);\r\n        }\r\n        function ReactDOMBlockingRoot(container, tag, options) {\r\n            this._internalRoot = createRootImpl(container, tag, options);\r\n        }\r\n        ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {\r\n            var root = this._internalRoot;\r\n            {\r\n                if (typeof arguments[1] === 'function') {\r\n                    error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');\r\n                }\r\n                var container = root.containerInfo;\r\n                if (container.nodeType !== COMMENT_NODE) {\r\n                    var hostInstance = findHostInstanceWithNoPortals(root.current);\r\n                    if (hostInstance) {\r\n                        if (hostInstance.parentNode !== container) {\r\n                            error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + \"root.unmount() to empty a root's container.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            updateContainer(children, root, null, null);\r\n        };\r\n        ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {\r\n            {\r\n                if (typeof arguments[0] === 'function') {\r\n                    error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');\r\n                }\r\n            }\r\n            var root = this._internalRoot;\r\n            var container = root.containerInfo;\r\n            updateContainer(null, root, null, function () {\r\n                unmarkContainerAsRoot(container);\r\n            });\r\n        };\r\n        function createRootImpl(container, tag, options) {\r\n            // Tag is either LegacyRoot or Concurrent Root\r\n            var hydrate = options != null && options.hydrate === true;\r\n            var hydrationCallbacks = options != null && options.hydrationOptions || null;\r\n            var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;\r\n            var root = createContainer(container, tag, hydrate);\r\n            markContainerAsRoot(root.current, container);\r\n            var containerNodeType = container.nodeType;\r\n            {\r\n                var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\r\n                listenToAllSupportedEvents(rootContainerElement);\r\n            }\r\n            if (mutableSources) {\r\n                for (var i = 0; i < mutableSources.length; i++) {\r\n                    var mutableSource = mutableSources[i];\r\n                    registerMutableSourceForHydration(root, mutableSource);\r\n                }\r\n            }\r\n            return root;\r\n        }\r\n        function createLegacyRoot(container, options) {\r\n            return new ReactDOMBlockingRoot(container, LegacyRoot, options);\r\n        }\r\n        function isValidContainer(node) {\r\n            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\r\n        }\r\n        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\r\n        var topLevelUpdateWarnings;\r\n        var warnedAboutHydrateAPI = false;\r\n        {\r\n            topLevelUpdateWarnings = function (container) {\r\n                if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\r\n                    var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\r\n                    if (hostInstance) {\r\n                        if (hostInstance.parentNode !== container) {\r\n                            error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\r\n                        }\r\n                    }\r\n                }\r\n                var isRootRenderedBySomeReact = !!container._reactRootContainer;\r\n                var rootEl = getReactRootElementInContainer(container);\r\n                var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\r\n                if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\r\n                    error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\r\n                }\r\n                if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {\r\n                    error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\r\n                }\r\n            };\r\n        }\r\n        function getReactRootElementInContainer(container) {\r\n            if (!container) {\r\n                return null;\r\n            }\r\n            if (container.nodeType === DOCUMENT_NODE) {\r\n                return container.documentElement;\r\n            }\r\n            else {\r\n                return container.firstChild;\r\n            }\r\n        }\r\n        function shouldHydrateDueToLegacyHeuristic(container) {\r\n            var rootElement = getReactRootElementInContainer(container);\r\n            return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\r\n        }\r\n        function legacyCreateRootFromDOMContainer(container, forceHydrate) {\r\n            var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.\r\n            if (!shouldHydrate) {\r\n                var warned = false;\r\n                var rootSibling;\r\n                while (rootSibling = container.lastChild) {\r\n                    {\r\n                        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\r\n                            warned = true;\r\n                            error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\r\n                        }\r\n                    }\r\n                    container.removeChild(rootSibling);\r\n                }\r\n            }\r\n            {\r\n                if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\r\n                    warnedAboutHydrateAPI = true;\r\n                    warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v18. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\r\n                }\r\n            }\r\n            return createLegacyRoot(container, shouldHydrate ? {\r\n                hydrate: true\r\n            } : undefined);\r\n        }\r\n        function warnOnInvalidCallback$1(callback, callerName) {\r\n            {\r\n                if (callback !== null && typeof callback !== 'function') {\r\n                    error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\r\n                }\r\n            }\r\n        }\r\n        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\r\n            {\r\n                topLevelUpdateWarnings(container);\r\n                warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');\r\n            } // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\r\n            // member of intersection type.\" Whyyyyyy.\r\n            var root = container._reactRootContainer;\r\n            var fiberRoot;\r\n            if (!root) {\r\n                // Initial mount\r\n                root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\r\n                fiberRoot = root._internalRoot;\r\n                if (typeof callback === 'function') {\r\n                    var originalCallback = callback;\r\n                    callback = function () {\r\n                        var instance = getPublicRootInstance(fiberRoot);\r\n                        originalCallback.call(instance);\r\n                    };\r\n                } // Initial mount should not be batched.\r\n                unbatchedUpdates(function () {\r\n                    updateContainer(children, fiberRoot, parentComponent, callback);\r\n                });\r\n            }\r\n            else {\r\n                fiberRoot = root._internalRoot;\r\n                if (typeof callback === 'function') {\r\n                    var _originalCallback = callback;\r\n                    callback = function () {\r\n                        var instance = getPublicRootInstance(fiberRoot);\r\n                        _originalCallback.call(instance);\r\n                    };\r\n                } // Update\r\n                updateContainer(children, fiberRoot, parentComponent, callback);\r\n            }\r\n            return getPublicRootInstance(fiberRoot);\r\n        }\r\n        function findDOMNode(componentOrElement) {\r\n            {\r\n                var owner = ReactCurrentOwner$3.current;\r\n                if (owner !== null && owner.stateNode !== null) {\r\n                    var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\r\n                    if (!warnedAboutRefsInRender) {\r\n                        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');\r\n                    }\r\n                    owner.stateNode._warnedAboutRefsInRender = true;\r\n                }\r\n            }\r\n            if (componentOrElement == null) {\r\n                return null;\r\n            }\r\n            if (componentOrElement.nodeType === ELEMENT_NODE) {\r\n                return componentOrElement;\r\n            }\r\n            {\r\n                return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\r\n            }\r\n        }\r\n        function hydrate(element, container, callback) {\r\n            if (!isValidContainer(container)) {\r\n                {\r\n                    throw Error(\"Target container is not a DOM element.\");\r\n                }\r\n            }\r\n            {\r\n                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\r\n                if (isModernRoot) {\r\n                    error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');\r\n                }\r\n            } // TODO: throw or warn if we couldn't hydrate?\r\n            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\r\n        }\r\n        function render(element, container, callback) {\r\n            if (!isValidContainer(container)) {\r\n                {\r\n                    throw Error(\"Target container is not a DOM element.\");\r\n                }\r\n            }\r\n            {\r\n                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\r\n                if (isModernRoot) {\r\n                    error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');\r\n                }\r\n            }\r\n            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\r\n        }\r\n        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\r\n            if (!isValidContainer(containerNode)) {\r\n                {\r\n                    throw Error(\"Target container is not a DOM element.\");\r\n                }\r\n            }\r\n            if (!(parentComponent != null && has(parentComponent))) {\r\n                {\r\n                    throw Error(\"parentComponent must be a valid React Component\");\r\n                }\r\n            }\r\n            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\r\n        }\r\n        function unmountComponentAtNode(container) {\r\n            if (!isValidContainer(container)) {\r\n                {\r\n                    throw Error(\"unmountComponentAtNode(...): Target container is not a DOM element.\");\r\n                }\r\n            }\r\n            {\r\n                var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\r\n                if (isModernRoot) {\r\n                    error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');\r\n                }\r\n            }\r\n            if (container._reactRootContainer) {\r\n                {\r\n                    var rootEl = getReactRootElementInContainer(container);\r\n                    var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\r\n                    if (renderedByDifferentReact) {\r\n                        error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\r\n                    }\r\n                } // Unmount should not be batched.\r\n                unbatchedUpdates(function () {\r\n                    legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\r\n                        // $FlowFixMe This should probably use `delete container._reactRootContainer`\r\n                        container._reactRootContainer = null;\r\n                        unmarkContainerAsRoot(container);\r\n                    });\r\n                }); // If you call unmountComponentAtNode twice in quick succession, you'll\r\n                // get `true` twice. That's probably fine?\r\n                return true;\r\n            }\r\n            else {\r\n                {\r\n                    var _rootEl = getReactRootElementInContainer(container);\r\n                    var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.\r\n                    var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\r\n                    if (hasNonRootReactChild) {\r\n                        error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);\r\n        setAttemptContinuousHydration(attemptContinuousHydration$1);\r\n        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);\r\n        setAttemptHydrationAtPriority(runWithPriority$2);\r\n        var didWarnAboutUnstableCreatePortal = false;\r\n        {\r\n            if (typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype\r\n                Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype\r\n                Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\r\n                error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');\r\n            }\r\n        }\r\n        setRestoreImplementation(restoreControlledState$3);\r\n        setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);\r\n        function createPortal$1(children, container) {\r\n            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\r\n            if (!isValidContainer(container)) {\r\n                {\r\n                    throw Error(\"Target container is not a DOM element.\");\r\n                }\r\n            } // TODO: pass ReactDOM portal implementation as third argument\r\n            // $FlowFixMe The Flow type is opaque but there's no way to actually create it.\r\n            return createPortal(children, container, null, key);\r\n        }\r\n        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\r\n            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);\r\n        }\r\n        function unstable_createPortal(children, container) {\r\n            var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\r\n            {\r\n                if (!didWarnAboutUnstableCreatePortal) {\r\n                    didWarnAboutUnstableCreatePortal = true;\r\n                    warn('The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 18+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\r\n                }\r\n            }\r\n            return createPortal$1(children, container, key);\r\n        }\r\n        var Internals = {\r\n            // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.\r\n            // This is an array for better minification.\r\n            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects,\r\n                IsThisRendererActing]\r\n        };\r\n        var foundDevTools = injectIntoDevTools({\r\n            findFiberByHostInstance: getClosestInstanceFromNode,\r\n            bundleType: 1,\r\n            version: ReactVersion,\r\n            rendererPackageName: 'react-dom'\r\n        });\r\n        {\r\n            if (!foundDevTools && canUseDOM && window.top === window.self) {\r\n                // If we're in Chrome or Firefox, provide a download link if not installed.\r\n                if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\r\n                    var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.\r\n                    if (/^(https?|file):$/.test(protocol)) {\r\n                        // eslint-disable-next-line react-internal/no-production-logging\r\n                        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\r\n        exports.createPortal = createPortal$1;\r\n        exports.findDOMNode = findDOMNode;\r\n        exports.flushSync = flushSync;\r\n        exports.hydrate = hydrate;\r\n        exports.render = render;\r\n        exports.unmountComponentAtNode = unmountComponentAtNode;\r\n        exports.unstable_batchedUpdates = batchedUpdates$1;\r\n        exports.unstable_createPortal = unstable_createPortal;\r\n        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;\r\n        exports.version = ReactVersion;\r\n    })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/NjFiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztHQU9HO0FBRVU7QUFFYixJQUFJLElBQXFDLEVBQUU7SUFDekMsQ0FBQztRQUNILFlBQVksQ0FBQztRQUViLElBQUksS0FBSyxHQUFHLG1CQUFPLENBQUMsNENBQU8sQ0FBQyxDQUFDO1FBQzdCLElBQUksT0FBTyxHQUFHLG1CQUFPLENBQUMsNERBQWUsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksU0FBUyxHQUFHLG1CQUFPLENBQUMsb0RBQVcsQ0FBQyxDQUFDO1FBQ3JDLElBQUksT0FBTyxHQUFHLG1CQUFPLENBQUMsOERBQW1CLENBQUMsQ0FBQztRQUUzQyxJQUFJLG9CQUFvQixHQUFHLEtBQUssQ0FBQyxrREFBa0QsQ0FBQztRQUVwRiwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBUyxJQUFJLENBQUMsTUFBTTtZQUNsQjtnQkFDRSxLQUFLLElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRTtvQkFDMUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2xDO2dCQUVELFlBQVksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3BDO1FBQ0gsQ0FBQztRQUNELFNBQVMsS0FBSyxDQUFDLE1BQU07WUFDbkI7Z0JBQ0UsS0FBSyxJQUFJLEtBQUss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LEdBQUcsNkNBQTZDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLGtCQUFrQixDQUFDLENBQUM7cUJBQy9TO2lCQUNGO2FBQ0Y7U0FDRjtRQUVELE9BQU8sQ0FBQyxrREFBa0QsR0FBRyxTQUFTLENBQUM7UUFDdkUsT0FBTyxDQUFDLFlBQVksR0FBRyxjQUFjLENBQUM7UUFDdEMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDbEMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDOUIsT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDMUIsT0FBTyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDeEIsT0FBTyxDQUFDLHNCQUFzQixHQUFHLHNCQUFzQixDQUFDO1FBQ3hELE9BQU8sQ0FBQyx1QkFBdUIsR0FBRyxnQkFBZ0IsQ0FBQztRQUNuRCxPQUFPLENBQUMscUJBQXFCLEdBQUcscUJBQXFCLENBQUM7UUFDdEQsT0FBTyxDQUFDLG1DQUFtQyxHQUFHLDBCQUEwQixDQUFDO1FBQ3pFLE9BQU8sQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDO0lBQzdCLENBQUMsQ0FBQyxFQUFFLENBQUM7Q0FDTiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG52YXIgdHJhY2luZyA9IHJlcXVpcmUoJ3NjaGVkdWxlci90cmFjaW5nJyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuaWYgKCFSZWFjdCkge1xuICB7XG4gICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS5cIiApO1xuICB9XG59XG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBGdW5kYW1lbnRhbENvbXBvbmVudCA9IDIwO1xudmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG52YXIgQmxvY2sgPSAyMjtcbnZhciBPZmZzY3JlZW5Db21wb25lbnQgPSAyMztcbnZhciBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSAyNDtcblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlRnVuZGFtZW50YWxBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG52YXIgZW5hYmxlTmV3UmVjb25jaWxlciA9IGZhbHNlOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIHdoaWxlIHVubW91bnRpbmcgKG9yIGFmdGVyIGluIHRoZSBjYXNlIG9mIHBhc3NpdmUgZWZmZWN0cylcbnZhciB3YXJuQWJvdXRTdHJpbmdSZWZzID0gZmFsc2U7XG5cbnZhciBhbGxOYXRpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cblxuXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSAge30gOyAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgJ0NhcHR1cmUnLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdKSB7XG4gICAgICBlcnJvcignRXZlbnRSZWdpc3RyeTogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIGFsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTtcbiAgfVxufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbykge1xuICB7XG4gICAgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCBwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBmdWxseSBkaXNhYmxlZCBqYXZhc2NyaXB0OiBVUkxzLCBhbmQgaWZcbiAgICAgICAgLy8gdGhlIGh5ZHJhdGlvbiBpcyBzdWNjZXNzZnVsIG9mIGEgamF2YXNjcmlwdDogVVJMLCB3ZVxuICAgICAgICAvLyBzdGlsbCB3YW50IHRvIHdhcm4gb24gdGhlIGNsaWVudC5cbiAgICAgICAgc2FuaXRpemVVUkwoJycgKyBleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTikge1xuICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH0gLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG5cblxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgb2JqZWN0IGlzIGFuIG9wYXF1ZSByZWZlcmVuY2UgSUQsIGl0J3MgZXhwZWN0ZWQgdGhhdFxuICAgIC8vIHRoZSBuZXh0IHByb3AgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHNlcnZlciB2YWx1ZSwgc28ganVzdCByZXR1cm5cbiAgICAvLyBleHBlY3RlZFxuXG5cbiAgICBpZiAoaXNPcGFxdWVIeWRyYXRpbmdPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuXG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHByb3BlcnR5SW5mbyA9PT0gbnVsbCkge1xuICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICB2YXIgX2F0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuXG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIC8vIElmIGF0dHJpYnV0ZSB0eXBlIGlzIGJvb2xlYW4sIHdlIGtub3cgZm9yIHN1cmUgaXQgd29uJ3QgYmUgYW4gZXhlY3V0aW9uIHNpbmtcbiAgICAgIC8vIGFuZCB3ZSB3b24ndCByZXF1aXJlIFRydXN0ZWQgVHlwZSBoZXJlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgc2FuaXRpemVVUkwoYXR0cmlidXRlVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQmxvY2s6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUuX3JlbmRlcik7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgZG8ge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgY3VycmVudCA9IG51bGw7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBvd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICBjdXJyZW50ID0gbnVsbDtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gIHtcbiAgICBpc1JlbmRlcmluZyA9IHJlbmRlcmluZztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SXNSZW5kZXJpbmcoKSB7XG4gIHtcbiAgICByZXR1cm4gaXNSZW5kZXJpbmc7XG4gIH1cbn1cblxuLy8gRmxvdyBkb2VzIG5vdCBhbGxvdyBzdHJpbmcgY29uY2F0ZW5hdGlvbiBvZiBtb3N0IG5vbi1zdHJpbmcgdHlwZXMuIFRvIHdvcmtcbi8vIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHdlIHVzZSBhbiBvcGFxdWUgdHlwZSB0aGF0IGNhbiBvbmx5IGJlIG9idGFpbmVkIGJ5XG4vLyBwYXNzaW5nIHRoZSB2YWx1ZSB0aHJvdWdoIGdldFRvU3RyaW5nVmFsdWUgZmlyc3QuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTsgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0ID0gZGVzY3JpcHRvci5zZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTsgLy8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbiAgLy8gYnV0IGl0IHRyaWdnZXJzIGEgYnVnIGluIElFMTEgYW5kIEVkZ2UgMTQvMTUuXG4gIC8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlXG4gIH0pO1xuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG5cblxuICBub2RlLl92YWx1ZVRyYWNrZXIgPSB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7IC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuXG4gIGlmICghdHJhY2tlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IHRyYWNrZXIuZ2V0VmFsdWUoKTtcbiAgdmFyIG5leHRWYWx1ZSA9IGdldFZhbHVlRnJvbU5vZGUobm9kZSk7XG5cbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykge1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG5cbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0JywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsID8gJycgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG5cbiAgICBpZiAoIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gdW5kZWZpbmVkIHRvICcgKyAnYSBkZWZpbmVkIHZhbHVlLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSBhIGRlZmluZWQgdG8gJyArICd1bmRlZmluZWQsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuICB2YXIgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycgfHwgLy8gV2UgZXhwbGljaXRseSB3YW50IHRvIGNvZXJjZSB0byBudW1iZXIgaGVyZSBpZiBwb3NzaWJsZS5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnKSB7XG4gICAgLy8gU3VibWl0L3Jlc2V0IGlucHV0cyBuZWVkIHRoZSBhdHRyaWJ1dGUgcmVtb3ZlZCBjb21wbGV0ZWx5IHRvIGF2b2lkXG4gICAgLy8gYmxhbmstdGV4dCBidXR0b25zLlxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIGNvbWVzIGZyb20gYSBjYXNjYWRlIG9mXG4gICAgLy8gcHJvcGVydGllczpcbiAgICAvLyAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMy4gT3RoZXJ3aXNlIHRoZXJlIHNob3VsZCBiZSBubyBjaGFuZ2VcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBpdCBvbmx5IGNoYW5nZXMgd2hlbiBpdCBuZWVkc1xuICAgIC8vIHRvIGJlIHJlbW92ZWQsIHN1Y2ggYXMgdHJhbnNpdGlvbmluZyBmcm9tIGEgY2hlY2tib3ggaW50byBhIHRleHQgaW5wdXRcbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcywgaXNIeWRyYXRpbmcpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50OyAvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICB2YXIgaXNCdXR0b24gPSB0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnOyAvLyBBdm9pZCBzZXR0aW5nIHZhbHVlIGF0dHJpYnV0ZSBvbiBzdWJtaXQvcmVzZXQgaW5wdXRzIGFzIGl0IG92ZXJyaWRlcyB0aGVcbiAgICAvLyBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLiBTZWU6ICMxMjg3MlxuXG4gICAgaWYgKGlzQnV0dG9uICYmIChwcm9wcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLnZhbHVlID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsVmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG5cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgc2hvdWxkIHVzZVxuICAgICAgICAvLyB0aGUgd3JhcHBlclN0YXRlLl9pbml0aWFsVmFsdWUgcHJvcGVydHkuIFRoaXMgdXNlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAzLiBBbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgc3luY2hyb25pemVkIHRvIHRoZSBwcm9wZXJ0eSxcbiAgICAgIC8vIHNvIHdlIGFzc2lnbiBkZWZhdWx0VmFsdWUgdG8gdGhlIHNhbWUgdGhpbmcgYXMgdGhlIHZhbHVlIHByb3BlcnR5XG4gICAgICAvLyBhc3NpZ25tZW50IHN0ZXAgYWJvdmUuXG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gIH0gLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuXG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG5cbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgYm90aCB0aGUgY2hlY2tlZCBwcm9wZXJ0eSBhbmRcbiAgICAvLyBhdHRyaWJ1dGUgYXJlIGFzc2lnbmVkIGF0IHRoZSBzYW1lIHRpbWUgdXNpbmcgZGVmYXVsdENoZWNrZWQuIFRoaXMgdXNlczpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIGNoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAyLiBUaGUgZGVmYXVsdENoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAzLiBPdGhlcndpc2UsIGZhbHNlXG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIW5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcbiAgfVxuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB1cGRhdGVXcmFwcGVyKG5vZGUsIHByb3BzKTtcbiAgdXBkYXRlTmFtZWRDb3VzaW5zKG5vZGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTmFtZWRDb3VzaW5zKHJvb3ROb2RlLCBwcm9wcykge1xuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG5cbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9IC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG5cblxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG5cbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cblxuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtcblxuICAgICAgaWYgKCFvdGhlclByb3BzKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcblxuXG4gICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpOyAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cblxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufSAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbi8vXG4vLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZShub2RlLCB0eXBlLCB2YWx1ZSkge1xuICBpZiAoIC8vIEZvY3VzZWQgbnVtYmVyIGlucHV0cyBzeW5jaHJvbml6ZSBvbiBibHVyLiBTZWUgQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAgdHlwZSAhPT0gJ251bWJlcicgfHwgZ2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpICE9PSBub2RlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRDaGlsZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbi4gV2UnbGwgd2FybiBpZiB0aGV5IGFyZSBpbnZhbGlkXG4gIC8vIGR1cmluZyB2YWxpZGF0ZVByb3BzKCkgd2hpY2ggcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgd291bGQgdGhyb3cgb24gbm9uLWVsZW1lbnQgb2JqZWN0cy5cbiAgLy8gRWxlbWVudHMgYXJlIHN0cmluZ2lmaWVkICh3aGljaCBpcyBub3JtYWxseSBpcnJlbGV2YW50XG4gIC8vIGJ1dCBtYXR0ZXJzIGZvciA8ZmJ0PikuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkOyAvLyBOb3RlOiB3ZSBkb24ndCB3YXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZS5cbiAgICAvLyBJbnN0ZWFkLCB0aGlzIGlzIGRvbmUgc2VwYXJhdGVseSBiZWxvdyBzbyB0aGF0XG4gICAgLy8gaXQgaGFwcGVucyBkdXJpbmcgdGhlIGh5ZHJhdGlvbiBjb2RlIHBhdGggdG9vLlxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBjb2RlIHBhdGggYWJvdmUsIGJ1dCBydW5zIGZvciBoeWRyYXRpb24gdG9vLlxuICAgIC8vIFdhcm4gYWJvdXQgaW52YWxpZCBjaGlsZHJlbiBoZXJlIHNvIHRoYXQgY2xpZW50IGFuZCBoeWRyYXRpb24gYXJlIGNvbnNpc3RlbnQuXG4gICAgLy8gVE9ETzogdGhpcyBzZWVtcyBsaWtlIGl0IGNvdWxkIGNhdXNlIGEgREVWLW9ubHkgdGhyb3cgZm9yIGh5ZHJhdGlvblxuICAgIC8vIGlmIGNoaWxkcmVuIGNvbnRhaW5zIGEgbm9uLWVsZW1lbnQgb2JqZWN0LiBXZSBzaG91bGQgdHJ5IHRvIGF2b2lkIHRoYXQuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcgJiYgcHJvcHMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZENoaWxkKSB7XG4gICAgICAgICAgZGlkV2FybkludmFsaWRDaGlsZCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG5cblxuICAgIGlmIChwcm9wcy5zZWxlY3RlZCAhPSBudWxsICYmICFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSkpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgfSwgcHJvcHMpO1xuXG4gIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICBpZiAoY29udGVudCkge1xuICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE7XG5cbntcbiAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpKTtcblxuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAoIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcImBkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LlwiICk7XG4gICAgfVxuICB9IC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuXG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSlcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYSB0ZXh0YXJlYSB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuXG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlOyAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuXG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgaWYgKCEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIjx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7IC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5cbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgJiYgbm9kZS5kZWZhdWx0VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cblxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50OyAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cblxuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09ICcnICYmIHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2Zykge1xuXG4gICAgaWYgKCEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAgICAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAgICAgLy8gdGhlIHRhcmdldCBub2RlXG4gICAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwudmFsdWVPZigpLnRvU3RyaW5nKCkgKyAnPC9zdmc+JztcbiAgICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vLyBMaXN0IGRlcml2ZWQgZnJvbSBHZWNrbyBzb3VyY2UgY29kZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzRlNjM4ZWZjNzEvbGF5b3V0L3N0eWxlL3Rlc3QvcHJvcGVydHlfZGF0YWJhc2UuanNcbnZhciBzaG9ydGhhbmRUb0xvbmdoYW5kID0ge1xuICBhbmltYXRpb246IFsnYW5pbWF0aW9uRGVsYXknLCAnYW5pbWF0aW9uRGlyZWN0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uJywgJ2FuaW1hdGlvbkZpbGxNb2RlJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FuaW1hdGlvbk5hbWUnLCAnYW5pbWF0aW9uUGxheVN0YXRlJywgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIGJhY2tncm91bmQ6IFsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCAnYmFja2dyb3VuZENsaXAnLCAnYmFja2dyb3VuZENvbG9yJywgJ2JhY2tncm91bmRJbWFnZScsICdiYWNrZ3JvdW5kT3JpZ2luJywgJ2JhY2tncm91bmRQb3NpdGlvblgnLCAnYmFja2dyb3VuZFBvc2l0aW9uWScsICdiYWNrZ3JvdW5kUmVwZWF0JywgJ2JhY2tncm91bmRTaXplJ10sXG4gIGJhY2tncm91bmRQb3NpdGlvbjogWydiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknXSxcbiAgYm9yZGVyOiBbJ2JvcmRlckJvdHRvbUNvbG9yJywgJ2JvcmRlckJvdHRvbVN0eWxlJywgJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlUmVwZWF0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VTb3VyY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCcsICdib3JkZXJUb3BDb2xvcicsICdib3JkZXJUb3BTdHlsZScsICdib3JkZXJUb3BXaWR0aCddLFxuICBib3JkZXJCbG9ja0VuZDogWydib3JkZXJCbG9ja0VuZENvbG9yJywgJ2JvcmRlckJsb2NrRW5kU3R5bGUnLCAnYm9yZGVyQmxvY2tFbmRXaWR0aCddLFxuICBib3JkZXJCbG9ja1N0YXJ0OiBbJ2JvcmRlckJsb2NrU3RhcnRDb2xvcicsICdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCAnYm9yZGVyQmxvY2tTdGFydFdpZHRoJ10sXG4gIGJvcmRlckJvdHRvbTogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCddLFxuICBib3JkZXJDb2xvcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJUb3BDb2xvciddLFxuICBib3JkZXJJbWFnZTogWydib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnXSxcbiAgYm9yZGVySW5saW5lRW5kOiBbJ2JvcmRlcklubGluZUVuZENvbG9yJywgJ2JvcmRlcklubGluZUVuZFN0eWxlJywgJ2JvcmRlcklubGluZUVuZFdpZHRoJ10sXG4gIGJvcmRlcklubGluZVN0YXJ0OiBbJ2JvcmRlcklubGluZVN0YXJ0Q29sb3InLCAnYm9yZGVySW5saW5lU3RhcnRTdHlsZScsICdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sXG4gIGJvcmRlckxlZnQ6IFsnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnXSxcbiAgYm9yZGVyUmFkaXVzOiBbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCAnYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMnLCAnYm9yZGVyVG9wTGVmdFJhZGl1cycsICdib3JkZXJUb3BSaWdodFJhZGl1cyddLFxuICBib3JkZXJSaWdodDogWydib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCddLFxuICBib3JkZXJTdHlsZTogWydib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyUmlnaHRTdHlsZScsICdib3JkZXJUb3BTdHlsZSddLFxuICBib3JkZXJUb3A6IFsnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyV2lkdGg6IFsnYm9yZGVyQm90dG9tV2lkdGgnLCAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgY29sdW1uUnVsZTogWydjb2x1bW5SdWxlQ29sb3InLCAnY29sdW1uUnVsZVN0eWxlJywgJ2NvbHVtblJ1bGVXaWR0aCddLFxuICBjb2x1bW5zOiBbJ2NvbHVtbkNvdW50JywgJ2NvbHVtbldpZHRoJ10sXG4gIGZsZXg6IFsnZmxleEJhc2lzJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnXSxcbiAgZmxleEZsb3c6IFsnZmxleERpcmVjdGlvbicsICdmbGV4V3JhcCddLFxuICBmb250OiBbJ2ZvbnRGYW1pbHknLCAnZm9udEZlYXR1cmVTZXR0aW5ncycsICdmb250S2VybmluZycsICdmb250TGFuZ3VhZ2VPdmVycmlkZScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbicsICdmb250V2VpZ2h0JywgJ2xpbmVIZWlnaHQnXSxcbiAgZm9udFZhcmlhbnQ6IFsnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbiddLFxuICBnYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkOiBbJ2dyaWRBdXRvQ29sdW1ucycsICdncmlkQXV0b0Zsb3cnLCAnZ3JpZEF1dG9Sb3dzJywgJ2dyaWRUZW1wbGF0ZUFyZWFzJywgJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCAnZ3JpZFRlbXBsYXRlUm93cyddLFxuICBncmlkQXJlYTogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCcsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkQ29sdW1uOiBbJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblN0YXJ0J10sXG4gIGdyaWRDb2x1bW5HYXA6IFsnY29sdW1uR2FwJ10sXG4gIGdyaWRHYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkUm93OiBbJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1N0YXJ0J10sXG4gIGdyaWRSb3dHYXA6IFsncm93R2FwJ10sXG4gIGdyaWRUZW1wbGF0ZTogWydncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgbGlzdFN0eWxlOiBbJ2xpc3RTdHlsZUltYWdlJywgJ2xpc3RTdHlsZVBvc2l0aW9uJywgJ2xpc3RTdHlsZVR5cGUnXSxcbiAgbWFyZ2luOiBbJ21hcmdpbkJvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0JywgJ21hcmdpblRvcCddLFxuICBtYXJrZXI6IFsnbWFya2VyRW5kJywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCddLFxuICBtYXNrOiBbJ21hc2tDbGlwJywgJ21hc2tDb21wb3NpdGUnLCAnbWFza0ltYWdlJywgJ21hc2tNb2RlJywgJ21hc2tPcmlnaW4nLCAnbWFza1Bvc2l0aW9uWCcsICdtYXNrUG9zaXRpb25ZJywgJ21hc2tSZXBlYXQnLCAnbWFza1NpemUnXSxcbiAgbWFza1Bvc2l0aW9uOiBbJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWSddLFxuICBvdXRsaW5lOiBbJ291dGxpbmVDb2xvcicsICdvdXRsaW5lU3R5bGUnLCAnb3V0bGluZVdpZHRoJ10sXG4gIG92ZXJmbG93OiBbJ292ZXJmbG93WCcsICdvdmVyZmxvd1knXSxcbiAgcGFkZGluZzogWydwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nVG9wJ10sXG4gIHBsYWNlQ29udGVudDogWydhbGlnbkNvbnRlbnQnLCAnanVzdGlmeUNvbnRlbnQnXSxcbiAgcGxhY2VJdGVtczogWydhbGlnbkl0ZW1zJywgJ2p1c3RpZnlJdGVtcyddLFxuICBwbGFjZVNlbGY6IFsnYWxpZ25TZWxmJywgJ2p1c3RpZnlTZWxmJ10sXG4gIHRleHREZWNvcmF0aW9uOiBbJ3RleHREZWNvcmF0aW9uQ29sb3InLCAndGV4dERlY29yYXRpb25MaW5lJywgJ3RleHREZWNvcmF0aW9uU3R5bGUnXSxcbiAgdGV4dEVtcGhhc2lzOiBbJ3RleHRFbXBoYXNpc0NvbG9yJywgJ3RleHRFbXBoYXNpc1N0eWxlJ10sXG4gIHRyYW5zaXRpb246IFsndHJhbnNpdGlvbkRlbGF5JywgJ3RyYW5zaXRpb25EdXJhdGlvbicsICd0cmFuc2l0aW9uUHJvcGVydHknLCAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIHdvcmRXcmFwOiBbJ292ZXJmbG93V3JhcCddXG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbHVlRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xufVxuLyoqXG4gKiBHaXZlbiB7Y29sb3I6ICdyZWQnLCBvdmVyZmxvdzogJ2hpZGRlbid9IHJldHVybnMge1xuICogICBjb2xvcjogJ2NvbG9yJyxcbiAqICAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3cnLFxuICogICBvdmVyZmxvd1k6ICdvdmVyZmxvdycsXG4gKiB9LiBUaGlzIGNhbiBiZSByZWFkIGFzIFwidGhlIG92ZXJmbG93WSBwcm9wZXJ0eSB3YXMgc2V0IGJ5IHRoZSBvdmVyZmxvd1xuICogc2hvcnRoYW5kXCIuIFRoYXQgaXMsIHRoZSB2YWx1ZXMgYXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGVhY2ggd2FzIGRlcml2ZWQgZnJvbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgdmFyIGV4cGFuZGVkID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciBsb25naGFuZHMgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleV0gfHwgW2tleV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdoYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXSA9IGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG4vKipcbiAqIFdoZW4gbWl4aW5nIHNob3J0aGFuZCBhbmQgbG9uZ2hhbmQgcHJvcGVydHkgbmFtZXMsIHdlIHdhcm4gZHVyaW5nIHVwZGF0ZXMgaWZcbiAqIHdlIGV4cGVjdCBhbiBpbmNvcnJlY3QgcmVzdWx0IHRvIG9jY3VyLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YXJuIGZvcjpcbiAqXG4gKiBVcGRhdGluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBvdmVyd3JpdHRlbik6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2JheicsIGZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICdiYXonXG4gKiBSZW1vdmluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBsb3N0IHRvbyk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJydcbiAqIFJlbW92aW5nIGEgbG9uZ2hhbmQgcHJvcGVydHkgKHNob3VsZCByZXZlcnQgdG8gc2hvcnRoYW5kOyBkb2Vzbid0KTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnZm9vJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udFZhcmlhbnQgPSAnJ1xuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFN0eWxlcykge1xuICB7XG4gICAgaWYgKCFuZXh0U3R5bGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuZGVkVXBkYXRlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO1xuICAgIHZhciBleHBhbmRlZFN0eWxlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChuZXh0U3R5bGVzKTtcbiAgICB2YXIgd2FybmVkQWJvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHBhbmRlZFVwZGF0ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgICAgdmFyIGNvcnJlY3RPcmlnaW5hbEtleSA9IGV4cGFuZGVkU3R5bGVzW2tleV07XG5cbiAgICAgIGlmIChjb3JyZWN0T3JpZ2luYWxLZXkgJiYgb3JpZ2luYWxLZXkgIT09IGNvcnJlY3RPcmlnaW5hbEtleSkge1xuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG9yaWdpbmFsS2V5ICsgJywnICsgY29ycmVjdE9yaWdpbmFsS2V5O1xuXG4gICAgICAgIGlmICh3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmVkQWJvdXRbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclcyBhIHN0eWxlIHByb3BlcnR5IGR1cmluZyByZXJlbmRlciAoJXMpIHdoZW4gYSAnICsgJ2NvbmZsaWN0aW5nIHByb3BlcnR5IGlzIHNldCAoJXMpIGNhbiBsZWFkIHRvIHN0eWxpbmcgYnVncy4gVG8gJyArIFwiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiICsgJ2ZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggJyArICdzZXBhcmF0ZSB2YWx1ZXMuJywgaXNWYWx1ZUVtcHR5KHN0eWxlVXBkYXRlc1tvcmlnaW5hbEtleV0pID8gJ1JlbW92aW5nJyA6ICdVcGRhdGluZycsIG9yaWdpbmFsS2V5LCBjb3JyZWN0T3JpZ2luYWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggdGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciBJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSA9IDE7XG52YXIgSVNfTk9OX0RFTEVHQVRFRCA9IDEgPDwgMTtcbnZhciBJU19DQVBUVVJFX1BIQVNFID0gMSA8PCAyO1xudmFyIElTX1JFUExBWUVEID0gMSA8PCA0O1xuLy8gc2V0IHRvIExFR0FDWV9GQl9TVVBQT1JULiBMRUdBQ1lfRkJfU1VQUE9SVCBvbmx5IGdldHMgc2V0IHdoZW5cbi8vIHdlIGNhbGwgd2lsbERlZmVyTGF0ZXJGb3JMZWdhY3lGQlN1cHBvcnQsIHRodXMgbm90IGJhaWxpbmcgb3V0XG4vLyB3aWxsIHJlc3VsdCBpbiBlbmRsZXNzIGN5Y2xlcyBsaWtlIGFuIGluZmluaXRlIGxvb3AuXG4vLyBXZSBhbHNvIGRvbid0IHdhbnQgdG8gZGVmZXIgZHVyaW5nIGV2ZW50IHJlcGxheWluZy5cblxudmFyIFNIT1VMRF9OT1RfUFJPQ0VTU19QT0xZRklMTF9FVkVOVF9QTFVHSU5TID0gSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgfCBJU19OT05fREVMRUdBVEVEIHwgSVNfQ0FQVFVSRV9QSEFTRTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93OyAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG5cbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfSAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuXG5cbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciByZXN0b3JlSW1wbCA9IG51bGw7XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcblxuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoISh0eXBlb2YgcmVzdG9yZUltcGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGVOb2RlID0gaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGU7IC8vIEd1YXJkIGFnYWluc3QgRmliZXIgYmVpbmcgdW5tb3VudGVkLlxuXG4gIGlmIChzdGF0ZU5vZGUpIHtcbiAgICB2YXIgX3Byb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gICAgcmVzdG9yZUltcGwoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgX3Byb3BzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oaW1wbCkge1xuICByZXN0b3JlSW1wbCA9IGltcGw7XG59XG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG5cbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cbi8vIERlZmF1bHRzXG5cbnZhciBiYXRjaGVkVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGJvb2trZWVwaW5nKSB7XG4gIHJldHVybiBmbihib29ra2VlcGluZyk7XG59O1xuXG52YXIgZGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICByZXR1cm4gZm4oYSwgYiwgYywgZCk7XG59O1xuXG52YXIgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IGJhdGNoZWRVcGRhdGVzSW1wbDtcbnZhciBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xudmFyIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmluaXNoRXZlbnRIYW5kbGVyKCkge1xuICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG5cbiAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgLy8gSWYgYSBjb250cm9sbGVkIGV2ZW50IHdhcyBmaXJlZCwgd2UgbWF5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2ZcbiAgICAvLyB0aGUgRE9NIG5vZGUgYmFjayB0byB0aGUgY29udHJvbGxlZCB2YWx1ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBSZWFjdFxuICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwoKTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xuICB9XG5cbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGJhdGNoZWRVcGRhdGVzSW1wbChmbiwgYm9va2tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gZmFsc2U7XG4gICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMoZm4sIGEsIGIpIHtcbiAgaWYgKGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH1cblxuICBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbChmbiwgYSwgYik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZJc0luc2lkZUV2ZW50SGFuZGxlciA9IGlzSW5zaWRlRXZlbnRIYW5kbGVyO1xuICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGlzY3JldGVVcGRhdGVzSW1wbChmbiwgYSwgYiwgYywgZCk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXI7XG5cbiAgICBpZiAoIWlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQodGltZVN0YW1wKSB7XG4gIHtcbiAgICBpZiAoIWlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oX2JhdGNoZWRVcGRhdGVzSW1wbCwgX2Rpc2NyZXRlVXBkYXRlc0ltcGwsIF9mbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwsIF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCkge1xuICBiYXRjaGVkVXBkYXRlc0ltcGwgPSBfYmF0Y2hlZFVwZGF0ZXNJbXBsO1xuICBkaXNjcmV0ZVVwZGF0ZXNJbXBsID0gX2Rpc2NyZXRlVXBkYXRlc0ltcGw7XG4gIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IF9mbHVzaERpc2NyZXRlVXBkYXRlc0ltcGw7XG4gIGJhdGNoZWRFdmVudFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRFdmVudFVwZGF0ZXNJbXBsO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRW50ZXInOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG5cbiAgaWYgKHN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gIGlmIChwcm9wcyA9PT0gbnVsbCkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG52YXIgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0IGV2ZW50cyB3aXRoIHBhc3NpdmUgbGlzdGVuZXJzXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG5cbmlmIChjYW5Vc2VET00pIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyAkRmxvd0ZpeE1lOiBJZ25vcmUgRmxvdyBjb21wbGFpbmluZyBhYm91dCBuZWVkaW5nIGEgdmFsdWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kO1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVuaW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2KG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG4gICAgICAvLyB3aGVuIHdlIGNhbGwgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKS4gSG93ZXZlciB0aGlzIGNhbiBjYXVzZSBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9yczogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzM0ODJcbiAgICAgIC8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cbiAgICAgIGlmICghKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgZGVmaW5lZCBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gaW4gYSB0ZXN0IGVudmlyb25tZW50IGlmIGEgY29tcG9uZW50IHNjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgdGhlIGVuZCBvZiB5b3VyIHRlc3QgKGFuZCBlbnN1cmUgdGhhdCBhbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMgZ2V0IGNhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgdG8gYmUgYXN5bmNocm9ub3VzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgdmFyIGRpZENhbGwgPSBmYWxzZTsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlOyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdmFsdWUgb2Ygd2luZG93LmV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlc2V0IGl0XG4gICAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcbiAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdC5cblxuICAgICAgdmFyIHdpbmRvd0V2ZW50ID0gd2luZG93LmV2ZW50OyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgZGVzY3JpcHRvciBvZiB3aW5kb3cuZXZlbnQgdG8gcmVzdG9yZSBpdCBhZnRlciBldmVudFxuICAgICAgLy8gZGlzcGF0Y2hpbmc6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2ODhcblxuICAgICAgdmFyIHdpbmRvd0V2ZW50RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LCAnZXZlbnQnKTtcblxuICAgICAgZnVuY3Rpb24gcmVzdG9yZUFmdGVyRGlzcGF0Y2goKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBXZSBjaGVjayBmb3Igd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpIHRvIHByZXZlbnQgdGhlXG4gICAgICAgIC8vIHdpbmRvdy5ldmVudCBhc3NpZ25tZW50IGluIGJvdGggSUUgPD0gMTAgYXMgdGhleSB0aHJvdyBhbiBlcnJvclxuICAgICAgICAvLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCB3aW5kb3cuZXZlbnQuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuZXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSkge1xuICAgICAgICAgIHdpbmRvdy5ldmVudCA9IHdpbmRvd0V2ZW50O1xuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG5cblxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICBkaWRDYWxsID0gdHJ1ZTtcbiAgICAgICAgcmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9IC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG5cblxuICAgICAgdmFyIGVycm9yOyAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cblxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgLy8gU29tZSBvdGhlciBlcnJvciBoYW5kbGVyIGhhcyBwcmV2ZW50ZWQgZGVmYXVsdC5cbiAgICAgICAgICAvLyBCcm93c2VycyBzaWxlbmNlIHRoZSBlcnJvciByZXBvcnQgaWYgdGhpcyBoYXBwZW5zLlxuICAgICAgICAgIC8vIFdlJ2xsIHJlbWVtYmVyIHRoaXMgdG8gbGF0ZXIgZGVjaWRlIHdoZXRoZXIgdG8gbG9nIGl0IG9yIG5vdC5cbiAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlcnJvci5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7Ly8gSWdub3JlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG5cblxuICAgICAgdmFyIGV2dFR5cGUgPSBcInJlYWN0LVwiICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpOyAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG5cbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKHdpbmRvd0V2ZW50RGVzY3JpcHRvcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnZXZlbnQnLCB3aW5kb3dFdmVudERlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlkQ2FsbCAmJiBkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGhhc0Vycm9yID0gZmFsc2U7XG4gIGNhdWdodEVycm9yID0gbnVsbDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAqIFRPRE86IFNlZSBpZiBjYXVnaHRFcnJvciBhbmQgcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICBpZiAoIWhhc1JldGhyb3dFcnJvcikge1xuICAgICAgaGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgIHJldGhyb3dFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuXG5mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSByZXRocm93RXJyb3I7XG4gICAgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG4gIHJldHVybiBoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImNsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9GbGFncyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBQZXJmb3JtZWRXb3JrID1cbi8qICAgICAgICAgICAgICAgICovXG4xOyAvLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cblxudmFyIFBsYWNlbWVudCA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgVXBkYXRlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPVxuLyogICAgICAgICAgICovXG42O1xudmFyIERlbGV0aW9uID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjg7XG52YXIgQ29udGVudFJlc2V0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ2FsbGJhY2sgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgRGlkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBQYXNzaXZlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7IC8vIFRPRE8gKGVmZmVjdHMpIFJlbW92ZSB0aGlzIGJpdCBvbmNlIHRoZSBuZXcgcmVjb25jaWxlciBpcyBzeW5jZWQgdG8gdGhlIG9sZC5cblxudmFyIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldiA9XG4vKiAgICAgKi9cbjgxOTI7XG52YXIgSHlkcmF0aW5nID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBIeWRyYXRpbmdBbmRVcGRhdGUgPVxuLyogICAgICAgICAgICovXG4xMDI4OyAvLyBQYXNzaXZlICYgVXBkYXRlICYgQ2FsbGJhY2sgJiBSZWYgJiBTbmFwc2hvdFxuXG52YXIgTGlmZWN5Y2xlRWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAqL1xuOTMyOyAvLyBVbmlvbiBvZiBhbGwgaG9zdCBlZmZlY3RzXG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4yMDQ3OyAvLyBUaGVzZSBhcmUgbm90IHJlYWxseSBzaWRlIGVmZmVjdHMsIGJ1dCB3ZSBzdGlsbCByZXVzZSB0aGlzIGZpZWxkLlxuXG52YXIgSW5jb21wbGV0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBTaG91bGRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjE2Mzg0OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihmaWJlcikge1xuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdXNwZW5zZVN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgc3VzcGVuc2VTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lckZyb21GaWJlcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Um9vdCA/IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlci50eXBlKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmICghKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgIGlmICghKG5lYXJlc3RNb3VudGVkICE9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShhLmFsdGVybmF0ZSA9PT0gYikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmICghKGEudGFnID09PSBIb3N0Um9vdCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG5cbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cblxuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZG9lc0ZpYmVyQ29udGFpbihwYXJlbnRGaWJlciwgY2hpbGRGaWJlcikge1xuICB2YXIgbm9kZSA9IGNoaWxkRmliZXI7XG4gIHZhciBwYXJlbnRGaWJlckFsdGVybmF0ZSA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnRGaWJlciB8fCBub2RlID09PSBwYXJlbnRGaWJlckFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgYXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbiA9IGZuO1xufVxudmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZnVuY3Rpb24gc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShmbikge1xuICBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eSA9IGZuO1xufSAvLyBUT0RPOiBVcGdyYWRlIHRoaXMgZGVmaW5pdGlvbiBvbmNlIHdlJ3JlIG9uIGEgbmV3ZXIgdmVyc2lvbiBvZiBGbG93IHRoYXRcbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIFRoZSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMgdG8gYmUgcmVwbGF5ZWQuXG5cbnZhciBxdWV1ZWREaXNjcmV0ZUV2ZW50cyA9IFtdOyAvLyBJbmRpY2F0ZXMgaWYgYW55IGNvbnRpbnVvdXMgZXZlbnQgdGFyZ2V0cyBhcmUgbm9uLW51bGwgZm9yIGVhcmx5IGJhaWxvdXQuXG4vLyBpZiB0aGUgbGFzdCB0YXJnZXQgd2FzIGRlaHlkcmF0ZWQuXG5cbnZhciBxdWV1ZWRGb2N1cyA9IG51bGw7XG52YXIgcXVldWVkRHJhZyA9IG51bGw7XG52YXIgcXVldWVkTW91c2UgPSBudWxsOyAvLyBGb3IgcG9pbnRlciBldmVudHMgdGhlcmUgY2FuIGJlIG9uZSBsYXRlc3QgZXZlbnQgcGVyIHBvaW50ZXJJZC5cblxudmFyIHF1ZXVlZFBvaW50ZXJzID0gbmV3IE1hcCgpO1xudmFyIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcyA9IG5ldyBNYXAoKTsgLy8gV2UgY291bGQgY29uc2lkZXIgcmVwbGF5aW5nIHNlbGVjdGlvbmNoYW5nZSBhbmQgdG91Y2htb3ZlcyB0b28uXG5cbnZhciBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMgPSBbXTtcbmZ1bmN0aW9uIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkge1xuICByZXR1cm4gcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMDtcbn1cbnZhciBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMgPSBbJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoc3RhcnQnLCAnYXV4Y2xpY2snLCAnZGJsY2xpY2snLCAncG9pbnRlcmNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVydXAnLCAnZHJhZ2VuZCcsICdkcmFnc3RhcnQnLCAnZHJvcCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnN0YXJ0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnaW5wdXQnLCAndGV4dElucHV0JywgLy8gSW50ZW50aW9uYWxseSBjYW1lbENhc2Vcbidjb3B5JywgJ2N1dCcsICdwYXN0ZScsICdjbGljaycsICdjaGFuZ2UnLCAnY29udGV4dG1lbnUnLCAncmVzZXQnLCAnc3VibWl0J107XG5mdW5jdGlvbiBpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGV2ZW50VHlwZSkge1xuICByZXR1cm4gZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzLmluZGV4T2YoZXZlbnRUeXBlKSA+IC0xO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBibG9ja2VkT246IGJsb2NrZWRPbixcbiAgICBkb21FdmVudE5hbWU6IGRvbUV2ZW50TmFtZSxcbiAgICBldmVudFN5c3RlbUZsYWdzOiBldmVudFN5c3RlbUZsYWdzIHwgSVNfUkVQTEFZRUQsXG4gICAgbmF0aXZlRXZlbnQ6IG5hdGl2ZUV2ZW50LFxuICAgIHRhcmdldENvbnRhaW5lcnM6IFt0YXJnZXRDb250YWluZXJdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1ZXVlRGlzY3JldGVFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB2YXIgcXVldWVkRXZlbnQgPSBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5wdXNoKHF1ZXVlZEV2ZW50KTtcbn0gLy8gUmVzZXRzIHRoZSByZXBsYXlpbmcgZm9yIHRoaXMgdHlwZSBvZiBjb250aW51b3VzIGV2ZW50IHRvIG5vIGV2ZW50LlxuXG5mdW5jdGlvbiBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgY2FzZSAnZHJhZ2xlYXZlJzpcbiAgICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgIHF1ZXVlZE1vdXNlID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgICAge1xuICAgICAgICB2YXIgcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVycy5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5kZWxldGUoX3BvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoZXhpc3RpbmdRdWV1ZWRFdmVudCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKGV4aXN0aW5nUXVldWVkRXZlbnQgPT09IG51bGwgfHwgZXhpc3RpbmdRdWV1ZWRFdmVudC5uYXRpdmVFdmVudCAhPT0gbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgcXVldWVkRXZlbnQgPSBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuXG4gICAgaWYgKGJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9maWJlcjIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mIHRoaXMgdGFyZ2V0LlxuICAgICAgICBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihfZmliZXIyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWVkRXZlbnQ7XG4gIH0gLy8gSWYgd2UgaGF2ZSBhbHJlYWR5IHF1ZXVlZCB0aGlzIGV4YWN0IGV2ZW50LCB0aGVuIGl0J3MgYmVjYXVzZVxuICAvLyB0aGUgZGlmZmVyZW50IGV2ZW50IHN5c3RlbXMgaGF2ZSBkaWZmZXJlbnQgRE9NIGV2ZW50IGxpc3RlbmVycy5cbiAgLy8gV2UgY2FuIGFjY3VtdWxhdGUgdGhlIGZsYWdzLCBhbmQgdGhlIHRhcmdldENvbnRhaW5lcnMsIGFuZFxuICAvLyBzdG9yZSBhIHNpbmdsZSBldmVudCB0byBiZSByZXBsYXllZC5cblxuXG4gIGV4aXN0aW5nUXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncyB8PSBldmVudFN5c3RlbUZsYWdzO1xuICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IGV4aXN0aW5nUXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICBpZiAodGFyZ2V0Q29udGFpbmVyICE9PSBudWxsICYmIHRhcmdldENvbnRhaW5lcnMuaW5kZXhPZih0YXJnZXRDb250YWluZXIpID09PSAtMSkge1xuICAgIHRhcmdldENvbnRhaW5lcnMucHVzaCh0YXJnZXRDb250YWluZXIpO1xuICB9XG5cbiAgcmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gVGhlc2Ugc2V0IHJlbGF0ZWRUYXJnZXQgdG8gbnVsbCBiZWNhdXNlIHRoZSByZXBsYXllZCBldmVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgd2VcbiAgLy8gbW92ZWQgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cgKG5vIHRhcmdldCkgb250byB0aGUgdGFyZ2V0IG9uY2UgaXQgaHlkcmF0ZXMuXG4gIC8vIEluc3RlYWQgb2YgbXV0YXRpbmcgd2UgY291bGQgY2xvbmUgdGhlIGV2ZW50LlxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAge1xuICAgICAgICB2YXIgZm9jdXNFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICBxdWV1ZWRGb2N1cyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRm9jdXMsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGZvY3VzRXZlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBkcmFnRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRHJhZyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRHJhZywgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgZHJhZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgbW91c2VFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICBxdWV1ZWRNb3VzZSA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkTW91c2UsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG1vdXNlRXZlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgcG9pbnRlcklkID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuc2V0KHBvaW50ZXJJZCwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVycy5nZXQocG9pbnRlcklkKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBwb2ludGVyRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlckV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHZhciBfcG9pbnRlcklkMiA9IF9wb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuc2V0KF9wb2ludGVySWQyLCBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQoX3BvaW50ZXJJZDIpIHx8IG51bGwsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIF9wb2ludGVyRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIENoZWNrIGlmIHRoaXMgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gUmV0dXJucyB0cnVlIGlmIGl0J3MgdW5ibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQocXVldWVkVGFyZ2V0KSB7XG4gIC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gc2hhcmVzIGEgbG90IG9mIGxvZ2ljIHdpdGggYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudC5cbiAgLy8gVHJ5IHRvIHVuaWZ5IHRoZW0uIEl0J3MgYSBiaXQgdHJpY2t5IHNpbmNlIGl0IHdvdWxkIHJlcXVpcmUgdHdvIHJldHVyblxuICAvLyB2YWx1ZXMuXG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocXVldWVkVGFyZ2V0LnRhcmdldCk7XG5cbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgdGFnID0gbmVhcmVzdE1vdW50ZWQudGFnO1xuXG4gICAgICBpZiAodGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSdyZSBibG9ja2VkIG9uIGh5ZHJhdGluZyB0aGlzIGJvdW5kYXJ5LlxuICAgICAgICAgIC8vIEluY3JlYXNlIGl0cyBwcmlvcml0eS5cbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gaW5zdGFuY2U7XG4gICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocXVldWVkVGFyZ2V0LmxhbmVQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShxdWV1ZWRUYXJnZXQucHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTsgLy8gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgYSB3YXkgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mXG4gICAgICAgICAgLy8gYSByb290IG90aGVyIHRoYW4gc3luYy5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IHF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgd2hpbGUgKHRhcmdldENvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHZhciB0YXJnZXRDb250YWluZXIgPSB0YXJnZXRDb250YWluZXJzWzBdO1xuICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChxdWV1ZWRFdmVudC5kb21FdmVudE5hbWUsIHF1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcXVldWVkRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgaWYgKG5leHRCbG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuIFRyeSBhZ2FpbiBsYXRlci5cbiAgICAgIHZhciBfZmliZXIzID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKTtcblxuICAgICAgaWYgKF9maWJlcjMgIT09IG51bGwpIHtcbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMyk7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgIHRhcmdldENvbnRhaW5lcnMuc2hpZnQoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAocXVldWVkRXZlbnQsIGtleSwgbWFwKSB7XG4gIGlmIChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSkge1xuICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlVbmJsb2NrZWRFdmVudHMoKSB7XG4gIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSBmYWxzZTsgLy8gRmlyc3QgcmVwbGF5IGRpc2NyZXRlIGV2ZW50cy5cblxuICB3aGlsZSAocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBuZXh0RGlzY3JldGVFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzWzBdO1xuXG4gICAgaWYgKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbiAgICAgIC8vIEluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIGJvdW5kYXJ5IHRvIHVuYmxvY2tcbiAgICAgIC8vIHRoZSBuZXh0IGRpc2NyZXRlIGV2ZW50LlxuICAgICAgdmFyIF9maWJlcjQgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24oX2ZpYmVyNCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRDb250YWluZXJzID0gbmV4dERpc2NyZXRlRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICAgIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0YXJnZXRDb250YWluZXIgPSB0YXJnZXRDb250YWluZXJzWzBdO1xuICAgICAgdmFyIG5leHRCbG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KG5leHREaXNjcmV0ZUV2ZW50LmRvbUV2ZW50TmFtZSwgbmV4dERpc2NyZXRlRXZlbnQuZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuZXh0RGlzY3JldGVFdmVudC5uYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuIFRyeSBhZ2FpbiBsYXRlci5cbiAgICAgICAgbmV4dERpc2NyZXRlRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFRoaXMgdGFyZ2V0IGNvbnRhaW5lciB3YXMgc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQuIFRyeSB0aGUgbmV4dC5cblxuXG4gICAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UndmUgc3VjY2Vzc2Z1bGx5IHJlcGxheWVkIHRoZSBmaXJzdCBldmVudC4gTGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAgIHF1ZXVlZERpc2NyZXRlRXZlbnRzLnNoaWZ0KCk7XG4gICAgfVxuICB9IC8vIE5leHQgcmVwbGF5IGFueSBjb250aW51b3VzIGV2ZW50cy5cblxuXG4gIGlmIChxdWV1ZWRGb2N1cyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEZvY3VzKSkge1xuICAgIHF1ZXVlZEZvY3VzID0gbnVsbDtcbiAgfVxuXG4gIGlmIChxdWV1ZWREcmFnICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRHJhZykpIHtcbiAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgfVxuXG4gIGlmIChxdWV1ZWRNb3VzZSAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZE1vdXNlKSkge1xuICAgIHF1ZXVlZE1vdXNlID0gbnVsbDtcbiAgfVxuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpIHtcbiAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcblxuICAgIGlmICghaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCkge1xuICAgICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IHRydWU7IC8vIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYXR0ZW1wdCByZXBsYXlpbmcgYXMgbWFueSBldmVudHMgYXMgYXJlXG4gICAgICAvLyBub3cgdW5ibG9ja2VkLiBUaGlzIGZpcnN0IG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB1bmJsb2NrZWQgeWV0LlxuICAgICAgLy8gV2UgY291bGQgY2hlY2sgaXQgZWFybHkgdG8gYXZvaWQgc2NoZWR1bGluZyBhbiB1bm5lY2Vzc2FyeSBjYWxsYmFjay5cblxuICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LCByZXBsYXlVbmJsb2NrZWRFdmVudHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeUlmQmxvY2tlZE9uKHVuYmxvY2tlZCkge1xuICAvLyBNYXJrIGFueXRoaW5nIHRoYXQgd2FzIGJsb2NrZWQgb24gdGhpcyBhcyBubyBsb25nZXIgYmxvY2tlZFxuICAvLyBhbmQgZWxpZ2libGUgZm9yIGEgcmVwbGF5LlxuICBpZiAocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXSwgdW5ibG9ja2VkKTsgLy8gVGhpcyBpcyBhIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgZWFjaCBib3VuZGFyeSB0aGF0IGNvbW1pdHMuIEkgdGhpbmsgaXQnc1xuICAgIC8vIHdvcnRoIGl0IGJlY2F1c2Ugd2UgZXhwZWN0IHZlcnkgZmV3IGRpc2NyZXRlIGV2ZW50cyB0byBxdWV1ZSB1cCBhbmQgb25jZVxuICAgIC8vIHdlIGFyZSBhY3R1YWxseSBmdWxseSB1bmJsb2NrZWQgaXQgd2lsbCBiZSBmYXN0IHRvIHJlcGxheSB0aGVtLlxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlZEV2ZW50ID0gcXVldWVkRGlzY3JldGVFdmVudHNbaV07XG5cbiAgICAgIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWV1ZWRGb2N1cyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRGb2N1cywgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIGlmIChxdWV1ZWREcmFnICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkTW91c2UsIHVuYmxvY2tlZCk7XG4gIH1cblxuICB2YXIgdW5ibG9jayA9IGZ1bmN0aW9uIChxdWV1ZWRFdmVudCkge1xuICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCk7XG4gIH07XG5cbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcXVldWVkVGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW19pXTtcblxuICAgIGlmIChxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBuZXh0RXhwbGljaXRUYXJnZXQgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbMF07XG5cbiAgICBpZiAobmV4dEV4cGxpY2l0VGFyZ2V0LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQobmV4dEV4cGxpY2l0VGFyZ2V0KTtcblxuICAgICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UncmUgdW5ibG9ja2VkLlxuICAgICAgICBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIERpc2NyZXRlRXZlbnQgPSAwO1xudmFyIFVzZXJCbG9ja2luZ0V2ZW50ID0gMTtcbnZhciBDb250aW51b3VzRXZlbnQgPSAyO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICByZXR1cm4gcHJlZml4ZXM7XG59XG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cblxudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xuXG52YXIgc3R5bGUgPSB7fTtcbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7IC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cblxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9IC8vIFNhbWUgYXMgYWJvdmVcblxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxudmFyIEFOSU1BVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyk7XG52YXIgQU5JTUFUSU9OX0lURVJBVElPTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKTtcbnZhciBBTklNQVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKTtcbnZhciBUUkFOU0lUSU9OX0VORCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJyk7XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoKTtcbnZhciBldmVudFByaW9yaXRpZXMgPSBuZXcgTWFwKCk7IC8vIFdlIHN0b3JlIG1vc3Qgb2YgdGhlIGV2ZW50cyBpbiB0aGlzIG1vZHVsZSBpbiBwYWlycyBvZiB0d28gc3RyaW5ncyBzbyB3ZSBjYW4gcmUtdXNlXG4vLyB0aGUgY29kZSByZXF1aXJlZCB0byBhcHBseSB0aGUgc2FtZSBsb2dpYyBmb3IgZXZlbnQgcHJpb3JpdGl6YXRpb24gYW5kIHRoYXQgb2YgdGhlXG4vLyBTaW1wbGVFdmVudFBsdWdpbi4gVGhpcyBjb21wbGljYXRlcyB0aGluZ3Mgc2xpZ2h0bHksIGJ1dCB0aGUgYWltIGlzIHRvIHJlZHVjZSBjb2RlXG4vLyBkdXBsaWNhdGlvbiAoZm9yIHdoaWNoIHRoZXJlIHdvdWxkIGJlIHF1aXRlIGEgYml0KS4gRm9yIHRoZSBldmVudHMgdGhhdCBhcmUgbm90IG5lZWRlZFxuLy8gZm9yIHRoZSBTaW1wbGVFdmVudFBsdWdpbiAob3RoZXJEaXNjcmV0ZUV2ZW50cykgd2UgcHJvY2VzcyB0aGVtIHNlcGFyYXRlbHkgYXMgYW5cbi8vIGFycmF5IG9mIHRvcCBsZXZlbCBldmVudHMuXG4vLyBMYXN0bHksIHdlIGlnbm9yZSBwcmV0dGllciBzbyB3ZSBjYW4ga2VlcCB0aGUgZm9ybWF0dGluZyBzYW5lLlxuLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnY2FuY2VsJywgJ2NhbmNlbCcsICdjbGljaycsICdjbGljaycsICdjbG9zZScsICdjbG9zZScsICdjb250ZXh0bWVudScsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2NvcHknLCAnY3V0JywgJ2N1dCcsICdhdXhjbGljaycsICdhdXhDbGljaycsICdkYmxjbGljaycsICdkb3VibGVDbGljaycsIC8vIENhcmVmdWwhXG4nZHJhZ2VuZCcsICdkcmFnRW5kJywgJ2RyYWdzdGFydCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkcm9wJywgJ2ZvY3VzaW4nLCAnZm9jdXMnLCAvLyBDYXJlZnVsIVxuJ2ZvY3Vzb3V0JywgJ2JsdXInLCAvLyBDYXJlZnVsIVxuJ2lucHV0JywgJ2lucHV0JywgJ2ludmFsaWQnLCAnaW52YWxpZCcsICdrZXlkb3duJywgJ2tleURvd24nLCAna2V5cHJlc3MnLCAna2V5UHJlc3MnLCAna2V5dXAnLCAna2V5VXAnLCAnbW91c2Vkb3duJywgJ21vdXNlRG93bicsICdtb3VzZXVwJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGFzdGUnLCAncGF1c2UnLCAncGF1c2UnLCAncGxheScsICdwbGF5JywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlckNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVyRG93bicsICdwb2ludGVydXAnLCAncG9pbnRlclVwJywgJ3JhdGVjaGFuZ2UnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdyZXNldCcsICdzZWVrZWQnLCAnc2Vla2VkJywgJ3N1Ym1pdCcsICdzdWJtaXQnLCAndG91Y2hjYW5jZWwnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hlbmQnLCAndG91Y2hFbmQnLCAndG91Y2hzdGFydCcsICd0b3VjaFN0YXJ0JywgJ3ZvbHVtZWNoYW5nZScsICd2b2x1bWVDaGFuZ2UnXTtcbnZhciBvdGhlckRpc2NyZXRlRXZlbnRzID0gWydjaGFuZ2UnLCAnc2VsZWN0aW9uY2hhbmdlJywgJ3RleHRJbnB1dCcsICdjb21wb3NpdGlvbnN0YXJ0JywgJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9udXBkYXRlJ107XG5cblxudmFyIHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2RyYWcnLCAnZHJhZycsICdkcmFnZW50ZXInLCAnZHJhZ0VudGVyJywgJ2RyYWdleGl0JywgJ2RyYWdFeGl0JywgJ2RyYWdsZWF2ZScsICdkcmFnTGVhdmUnLCAnZHJhZ292ZXInLCAnZHJhZ092ZXInLCAnbW91c2Vtb3ZlJywgJ21vdXNlTW92ZScsICdtb3VzZW91dCcsICdtb3VzZU91dCcsICdtb3VzZW92ZXInLCAnbW91c2VPdmVyJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJvdXQnLCAncG9pbnRlck91dCcsICdwb2ludGVyb3ZlcicsICdwb2ludGVyT3ZlcicsICdzY3JvbGwnLCAnc2Nyb2xsJywgJ3RvZ2dsZScsICd0b2dnbGUnLCAndG91Y2htb3ZlJywgJ3RvdWNoTW92ZScsICd3aGVlbCcsICd3aGVlbCddOyAvLyBwcmV0dGllci1pZ25vcmVcblxudmFyIGNvbnRpbnVvdXNQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydhYm9ydCcsICdhYm9ydCcsIEFOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnLCBBTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnLCAnY2FucGxheScsICdjYW5QbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ2NhblBsYXlUaHJvdWdoJywgJ2R1cmF0aW9uY2hhbmdlJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2Vycm9yJywgJ2dvdHBvaW50ZXJjYXB0dXJlJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2xvYWQnLCAnbG9hZCcsICdsb2FkZWRkYXRhJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ2xvYWRTdGFydCcsICdsb3N0cG9pbnRlcmNhcHR1cmUnLCAnbG9zdFBvaW50ZXJDYXB0dXJlJywgJ3BsYXlpbmcnLCAncGxheWluZycsICdwcm9ncmVzcycsICdwcm9ncmVzcycsICdzZWVraW5nJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAnc3VzcGVuZCcsICd0aW1ldXBkYXRlJywgJ3RpbWVVcGRhdGUnLCBUUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnLCAnd2FpdGluZycsICd3YWl0aW5nJ107XG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICpcbiAqIGludG9cbiAqXG4gKiB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoW1xuICogICBbJ2Fib3J0JywgJ29uQWJvcnQnXSxcbiAqIF0pO1xuICpcbiAqIGFuZCByZWdpc3RlcnMgdGhlbS5cbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICAvLyBBcyB0aGUgZXZlbnQgdHlwZXMgYXJlIGluIHBhaXJzIG9mIHR3bywgd2UgbmVlZCB0byBpdGVyYXRlXG4gIC8vIHRocm91Z2ggaW4gdHdvcy4gVGhlIGV2ZW50cyBhcmUgaW4gcGFpcnMgb2YgdHdvIHRvIHNhdmUgY29kZVxuICAvLyBhbmQgaW1wcm92ZSBpbml0IHBlcmYgb2YgcHJvY2Vzc2luZyB0aGlzIGFycmF5LCBhcyBpdCB3aWxsXG4gIC8vIHJlc3VsdCBpbiBmYXIgZmV3ZXIgb2JqZWN0IGFsbG9jYXRpb25zIGFuZCBwcm9wZXJ0eSBhY2Nlc3Nlc1xuICAvLyBpZiB3ZSBvbmx5IHVzZSB0aHJlZSBhcnJheXMgdG8gcHJvY2VzcyBhbGwgdGhlIGNhdGVnb3JpZXMgb2ZcbiAgLy8gaW5zdGVhZCBvZiB0dXBsZXMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUeXBlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB0b3BFdmVudCA9IGV2ZW50VHlwZXNbaV07XG4gICAgdmFyIGV2ZW50ID0gZXZlbnRUeXBlc1tpICsgMV07XG4gICAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gICAgdmFyIHJlYWN0TmFtZSA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICAgIGV2ZW50UHJpb3JpdGllcy5zZXQodG9wRXZlbnQsIHByaW9yaXR5KTtcbiAgICB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcy5zZXQodG9wRXZlbnQsIHJlYWN0TmFtZSk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlYWN0TmFtZSwgW3RvcEV2ZW50XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RXZlbnRQcmlvcml0aWVzKGV2ZW50VHlwZXMsIHByaW9yaXR5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50UHJpb3JpdGllcy5zZXQoZXZlbnRUeXBlc1tpXSwgcHJpb3JpdHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKSB7XG4gIHZhciBwcmlvcml0eSA9IGV2ZW50UHJpb3JpdGllcy5nZXQoZG9tRXZlbnROYW1lKTsgLy8gRGVmYXVsdCB0byBhIENvbnRpbnVvdXNFdmVudC4gTm90ZTogd2UgbWlnaHRcbiAgLy8gd2FudCB0byB3YXJuIGlmIHdlIGNhbid0IGRldGVjdCB0aGUgcHJpb3JpdHlcbiAgLy8gZm9yIHRoZSBldmVudC5cblxuICByZXR1cm4gcHJpb3JpdHkgPT09IHVuZGVmaW5lZCA/IENvbnRpbnVvdXNFdmVudCA6IHByaW9yaXR5O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVFdmVudHMoKSB7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKGRpc2NyZXRlRXZlbnRQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luLCBEaXNjcmV0ZUV2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXModXNlckJsb2NraW5nUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgVXNlckJsb2NraW5nRXZlbnQpO1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgQ29udGludW91c0V2ZW50KTtcbiAgc2V0RXZlbnRQcmlvcml0aWVzKG90aGVyRGlzY3JldGVFdmVudHMsIERpc2NyZXRlRXZlbnQpO1xufVxuXG52YXIgU2NoZWR1bGVyX25vdyA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG5cbntcbiAgLy8gUHJvdmlkZSBleHBsaWNpdCBlcnJvciBtZXNzYWdlIHdoZW4gcHJvZHVjdGlvbitwcm9maWxpbmcgYnVuZGxlIG9mIGUuZy5cbiAgLy8gcmVhY3QtZG9tIGlzIHVzZWQgd2l0aCBwcm9kdWN0aW9uIChub24tcHJvZmlsaW5nKSBidW5kbGUgb2ZcbiAgLy8gc2NoZWR1bGVyL3RyYWNpbmdcbiAgaWYgKCEodHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZiAhPSBudWxsICYmIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCAhPSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gcnVuIHRoZSBwcm9maWxpbmcgdmVyc2lvbiBvZiBhIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgYHJlYWN0LWRvbS9wcm9maWxpbmdgKSB3aXRob3V0IGFsc28gcmVwbGFjaW5nIHRoZSBgc2NoZWR1bGVyL3RyYWNpbmdgIG1vZHVsZSB3aXRoIGBzY2hlZHVsZXIvdHJhY2luZy1wcm9maWxpbmdgLiBZb3VyIGJ1bmRsZXIgbWlnaHQgaGF2ZSBhIHNldHRpbmcgZm9yIGFsaWFzaW5nIGJvdGggbW9kdWxlcy4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcHJvZmlsaW5nXCIgKTtcbiAgICB9XG4gIH1cbn1cbi8vIGFzY2VuZGluZyBudW1iZXJzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gbGlrZSBudW1iZXJzLiBUaGV5IHN0YXJ0IGF0IDkwIHRvXG4vLyBhdm9pZCBjbGFzaGluZyB3aXRoIFNjaGVkdWxlcidzIHByaW9yaXRpZXMuXG5cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDk5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSA5NztcbnZhciBMb3dQcmlvcml0eSA9IDk2O1xudmFyIElkbGVQcmlvcml0eSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5ID0gOTA7XG52YXIgaW5pdGlhbFRpbWVNcyA9IFNjaGVkdWxlcl9ub3coKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cblxudmFyIFN5bmNMYW5lUHJpb3JpdHkgPSAxNTtcbnZhciBTeW5jQmF0Y2hlZExhbmVQcmlvcml0eSA9IDE0O1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSAxMztcbnZhciBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5ID0gMTI7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTE7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5ID0gMTA7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDk7XG52YXIgRGVmYXVsdExhbmVQcmlvcml0eSA9IDg7XG52YXIgVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5ID0gNztcbnZhciBUcmFuc2l0aW9uUHJpb3JpdHkgPSA2O1xudmFyIFJldHJ5TGFuZVByaW9yaXR5ID0gNTtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA0O1xudmFyIElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSAzO1xudmFyIElkbGVMYW5lUHJpb3JpdHkgPSAyO1xudmFyIE9mZnNjcmVlbkxhbmVQcmlvcml0eSA9IDE7XG52YXIgTm9MYW5lUHJpb3JpdHkgPSAwO1xudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIFN5bmNCYXRjaGVkTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAqL1xuNDtcbnZhciBJbnB1dERpc2NyZXRlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yNDtcbnZhciBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAqL1xuMzI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAqL1xuMTkyO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBEZWZhdWx0TGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjM1ODQ7XG52YXIgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjQwOTY7XG52YXIgVHJhbnNpdGlvbkxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE4NjExMjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG42MjkxNDU2MDtcbnZhciBTb21lUmV0cnlMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzQyMTc3Mjc7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIElkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgwNTMwNjM2ODtcbnZhciBPZmZzY3JlZW5MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4xMDczNzQxODI0O1xudmFyIE5vVGltZXN0YW1wID0gLTE7XG5mdW5jdGlvbiBzZXRDdXJyZW50VXBkYXRlTGFuZVByaW9yaXR5KG5ld0xhbmVQcmlvcml0eSkge1xufSAvLyBcIlJlZ2lzdGVyc1wiIHVzZWQgdG8gXCJyZXR1cm5cIiBtdWx0aXBsZSB2YWx1ZXNcbi8vIFVzZWQgYnkgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMgYW5kIGdldE5leHRMYW5lczpcblxudmFyIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAgaWYgKChTeW5jTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH1cblxuICBpZiAoKFN5bmNCYXRjaGVkTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcbiAgfVxuXG4gIGlmICgoSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlucHV0RGlzY3JldGVMYW5lcyA9IElucHV0RGlzY3JldGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpbnB1dERpc2NyZXRlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0RGlzY3JldGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0RGlzY3JldGVMYW5lcztcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlucHV0Q29udGludW91c0xhbmVzID0gSW5wdXRDb250aW51b3VzTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXRDb250aW51b3VzTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gaW5wdXRDb250aW51b3VzTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgRGVmYXVsdEh5ZHJhdGlvbkxhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0SHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBEZWZhdWx0SHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0TGFuZXMgPSBEZWZhdWx0TGFuZXMgJiBsYW5lcztcblxuICBpZiAoZGVmYXVsdExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBkZWZhdWx0TGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25MYW5lcyA9IFRyYW5zaXRpb25MYW5lcyAmIGxhbmVzO1xuXG4gIGlmICh0cmFuc2l0aW9uTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFRyYW5zaXRpb25Qcmlvcml0eTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkxhbmVzO1xuICB9XG5cbiAgdmFyIHJldHJ5TGFuZXMgPSBSZXRyeUxhbmVzICYgbGFuZXM7XG5cbiAgaWYgKHJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFJldHJ5TGFuZVByaW9yaXR5O1xuICAgIHJldHVybiByZXRyeUxhbmVzO1xuICB9XG5cbiAgaWYgKGxhbmVzICYgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSkge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIElkbGVIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSWRsZUh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgaWRsZUxhbmVzID0gSWRsZUxhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlkbGVMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSWRsZUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gaWRsZUxhbmVzO1xuICB9XG5cbiAgaWYgKChPZmZzY3JlZW5MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG4gIH1cblxuICB7XG4gICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9IC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSwgYnV0IGFzIGEgZmFsbGJhY2ssIHJldHVybiB0aGUgZW50aXJlIGJpdG1hc2suXG5cblxuICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG4gIHJldHVybiBsYW5lcztcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVyUHJpb3JpdHlUb0xhbmVQcmlvcml0eShzY2hlZHVsZXJQcmlvcml0eUxldmVsKSB7XG4gIHN3aXRjaCAoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgLy8gVE9ETzogSGFuZGxlIExvd1NjaGVkdWxlclByaW9yaXR5LCBzb21laG93LiBNYXliZSB0aGUgc2FtZSBsYW5lIGFzIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBEZWZhdWx0TGFuZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZUxhbmVQcmlvcml0eTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTm9MYW5lUHJpb3JpdHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobGFuZVByaW9yaXR5KSB7XG4gIHN3aXRjaCAobGFuZVByaW9yaXR5KSB7XG4gICAgY2FzZSBTeW5jTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICBjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eTpcbiAgICBjYXNlIFRyYW5zaXRpb25Qcmlvcml0eTpcbiAgICBjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vcm1hbFByaW9yaXR5O1xuXG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHk7XG5cbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICAvLyBFYXJseSBiYWlsb3V0IGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrIGxlZnQuXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcblxuICBpZiAocGVuZGluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBuZXh0TGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgbmV4dExhbmVQcmlvcml0eSA9IE5vTGFuZVByaW9yaXR5O1xuICB2YXIgZXhwaXJlZExhbmVzID0gcm9vdC5leHBpcmVkTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIENoZWNrIGlmIGFueSB3b3JrIGhhcyBleHBpcmVkLlxuXG4gIGlmIChleHBpcmVkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBuZXh0TGFuZXMgPSBleHBpcmVkTGFuZXM7XG4gICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0xhbmVQcmlvcml0eTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG4gICAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG4gICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgICBpZiAobm9uSWRsZVBlbmRpbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgdmFyIG5vbklkbGVVbmJsb2NrZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVVuYmxvY2tlZExhbmVzKTtcbiAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vbklkbGVQaW5nZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiBwaW5nZWRMYW5lcztcblxuICAgICAgICBpZiAobm9uSWRsZVBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICAgIHZhciB1bmJsb2NrZWRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgaWYgKHVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpO1xuICAgICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoYWJsZSBpZiB3ZSdyZSBzdXNwZW5kZWRcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIGhpZ2hlciBwcmlvcml0eSBsYW5lcywgd2UnbGwgaW5jbHVkZSB0aGVtIGV2ZW4gaWYgdGhleVxuICAvLyBhcmUgc3VzcGVuZGVkLlxuXG5cbiAgbmV4dExhbmVzID0gcGVuZGluZ0xhbmVzICYgZ2V0RXF1YWxPckhpZ2hlclByaW9yaXR5TGFuZXMobmV4dExhbmVzKTsgLy8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbiAgLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG4gIC8vIGhpZ2hlciBwcmlvcml0eS5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh3aXBMYW5lcyk7XG4gICAgdmFyIHdpcExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuXG4gICAgaWYgKG5leHRMYW5lUHJpb3JpdHkgPD0gd2lwTGFuZVByaW9yaXR5KSB7XG4gICAgICByZXR1cm4gd2lwTGFuZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gbmV4dExhbmVQcmlvcml0eTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IEV4cGlyYXRpb24gaGV1cmlzdGljIGlzIGNvbnN0YW50IHBlciBsYW5lLCBzbyBjb3VsZCB1c2UgYSBtYXAuXG4gIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmUpO1xuICB2YXIgcHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICBpZiAocHJpb3JpdHkgPj0gSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5KSB7XG4gICAgLy8gVXNlciBpbnRlcmFjdGlvbnMgc2hvdWxkIGV4cGlyZSBzbGlnaHRseSBtb3JlIHF1aWNrbHkuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuIFdoZW5cbiAgICAvLyB3ZSBtYWRlIGl0IGxhcmdlciwgYSBwcm9kdWN0IG1ldHJpYyBpbiB3d3cgcmVncmVzc2VkLCBzdWdnZXN0aW5nIHRoZXJlJ3NcbiAgICAvLyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2Ygc3luY2hyb25vdXNcbiAgICAvLyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGVcbiAgICAvLyBzdGFydmF0aW9uLiBIb3dldmVyLCB0aGlzIHNjZW5hcmlvIHN1cHBvcnRzIHRoZSBpZGVhIHRoYXQgZXhwaXJhdGlvblxuICAgIC8vIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvbiBkb2VzIGhhcHBlbi5cbiAgICAvL1xuICAgIC8vIEFsc28gbm90ZSB0aGF0LCBpbiB0aGUgY2FzZSBvZiB1c2VyIGlucHV0IHNwZWNpZmljYWxseSwgdGhpcyB3aWxsIHNvb24gbm9cbiAgICAvLyBsb25nZXIgYmUgYW4gaXNzdWUgYmVjYXVzZSB3ZSBwbGFuIHRvIG1ha2UgdXNlciBpbnB1dCBzeW5jaHJvbm91cyBieVxuICAgIC8vIGRlZmF1bHQgKHVudGlsIHlvdSBlbnRlciBgc3RhcnRUcmFuc2l0aW9uYCwgb2YgY291cnNlLilcbiAgICAvL1xuICAgIC8vIElmIHdlcmVuJ3QgcGxhbm5pbmcgdG8gbWFrZSB0aGVzZSB1cGRhdGVzIHN5bmNocm9ub3VzIHNvb24gYW55d2F5LCBJXG4gICAgLy8gd291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG51bWJlciBhIGNvbmZpZ3VyYWJsZSBwYXJhbWV0ZXIuXG4gICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICB9IGVsc2UgaWYgKHByaW9yaXR5ID49IFRyYW5zaXRpb25Qcmlvcml0eSkge1xuICAgIHJldHVybiBjdXJyZW50VGltZSArIDUwMDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gQW55dGhpbmcgaWRsZSBwcmlvcml0eSBvciBsb3dlciBzaG91bGQgbmV2ZXIgZXhwaXJlLlxuICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuZnVuY3Rpb24gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCkge1xuICB2YXIgZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiA9IHJvb3QucGVuZGluZ0xhbmVzICYgfk9mZnNjcmVlbkxhbmU7XG5cbiAgaWYgKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm4gZXZlcnl0aGluZ0J1dE9mZnNjcmVlbjtcbiAgfVxuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICYgT2Zmc2NyZWVuTGFuZSkge1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAgcmV0dXJuIE5vTGFuZXM7XG59XG5mdW5jdGlvbiByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpIHtcbiAgcmV0dXJuIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgYSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFVwZGF0ZUxhbmUobGFuZVByaW9yaXR5LCB3aXBMYW5lcykge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgTm9MYW5lUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBTeW5jTGFuZTtcblxuICAgIGNhc2UgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0JhdGNoZWRMYW5lO1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5OlxuICAgICAge1xuICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dERpc2NyZXRlTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICAgIGlmIChfbGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5LCB3aXBMYW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmU7XG4gICAgICB9XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMiA9IHBpY2tBcmJpdHJhcnlMYW5lKElucHV0Q29udGludW91c0xhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUyID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBTaGlmdCB0byB0aGUgbmV4dCBwcmlvcml0eSBsZXZlbFxuICAgICAgICAgIHJldHVybiBmaW5kVXBkYXRlTGFuZShEZWZhdWx0TGFuZVByaW9yaXR5LCB3aXBMYW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUyO1xuICAgICAgfVxuXG4gICAgY2FzZSBEZWZhdWx0TGFuZVByaW9yaXR5OlxuICAgICAge1xuICAgICAgICB2YXIgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUzID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBJZiBhbGwgdGhlIGRlZmF1bHQgbGFuZXMgYXJlIGFscmVhZHkgYmVpbmcgd29ya2VkIG9uLCBsb29rIGZvciBhXG4gICAgICAgICAgLy8gbGFuZSBpbiB0aGUgdHJhbnNpdGlvbiByYW5nZS5cbiAgICAgICAgICBfbGFuZTMgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgICAvLyBBbGwgdGhlIHRyYW5zaXRpb24gbGFuZXMgYXJlIHRha2VuLCB0b28uIFRoaXMgc2hvdWxkIGJlIHZlcnlcbiAgICAgICAgICAgIC8vIHJhcmUsIGJ1dCBhcyBhIGxhc3QgcmVzb3J0LCBwaWNrIGEgZGVmYXVsdCBsYW5lLiBUaGlzIHdpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gdGhlIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcyByZW5kZXIuXG4gICAgICAgICAgICBfbGFuZTMgPSBwaWNrQXJiaXRyYXJ5TGFuZShEZWZhdWx0TGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbGFuZTM7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYW5zaXRpb25Qcmlvcml0eTogLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFRyYW5zaXRpb25MYW5lIGluc3RlYWRcblxuICAgIGNhc2UgUmV0cnlMYW5lUHJpb3JpdHk6XG4gICAgICAvLyBTaG91bGQgYmUgaGFuZGxlZCBieSBmaW5kUmV0cnlMYW5lIGluc3RlYWRcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlTGFuZVByaW9yaXR5OlxuICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJZGxlTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICBpZiAobGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJZGxlTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFuZTtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIHVwZGF0ZSBwcmlvcml0eTogXCIgKyBsYW5lUHJpb3JpdHkgKyBcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgIH1cbiAgfVxufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFRyYW5zaXRpb25MYW5lKHdpcExhbmVzLCBwZW5kaW5nTGFuZXMpIHtcbiAgLy8gRmlyc3QgbG9vayBmb3IgbGFuZXMgdGhhdCBhcmUgY29tcGxldGVseSB1bmNsYWltZWQsIGkuZS4gaGF2ZSBub1xuICAvLyBwZW5kaW5nIHdvcmsuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfnBlbmRpbmdMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIElmIGFsbCBsYW5lcyBoYXZlIHBlbmRpbmcgd29yaywgbG9vayBmb3IgYSBsYW5lIHRoYXQgaXNuJ3QgY3VycmVudGx5XG4gICAgLy8gYmVpbmcgd29ya2VkIG9uLlxuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgLy8gSWYgZXZlcnl0aGluZyBpcyBiZWluZyB3b3JrZWQgb24sIHBpY2sgYW55IGxhbmUuIFRoaXMgaGFzIHRoZVxuICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIHB1cmUgZnVuY3Rpb24sIHNvIHRoYXQgaXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgbGFuZSBmb3IgZ2l2ZW4gaW5wdXRzLlxuXG5mdW5jdGlvbiBmaW5kUmV0cnlMYW5lKHdpcExhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIGBmaW5kVXBkYXRlTGFuZWAgZGVzaWduZWQgc3BlY2lmaWNhbGx5IGZvciBTdXNwZW5zZVxuICAvLyBcInJldHJpZXNcIiDigJQgYSBzcGVjaWFsIHVwZGF0ZSB0aGF0IGF0dGVtcHRzIHRvIGZsaXAgYSBTdXNwZW5zZSBib3VuZGFyeVxuICAvLyBmcm9tIGl0cyBwbGFjZWhvbGRlciBzdGF0ZSB0byBpdHMgcHJpbWFyeS9yZXNvbHZlZCBzdGF0ZS5cbiAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzICYgfndpcExhbmVzKTtcblxuICBpZiAobGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFJldHJ5TGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcbiAgcmV0dXJuIGxhbmVzICYgLWxhbmVzO1xufVxuXG5mdW5jdGlvbiBnZXRMb3dlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcbiAgLy8gVGhpcyBmaW5kcyB0aGUgbW9zdCBzaWduaWZpY2FudCBub24temVybyBiaXQuXG4gIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICByZXR1cm4gaW5kZXggPCAwID8gTm9MYW5lcyA6IDEgPDwgaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAoZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSA8PCAxKSAtIDE7XG59XG5cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBnZXRzIGlubGluZWQuIE9ubHkgZXhpc3RzIHNvIHRvIGNvbW11bmljYXRlIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbiAgLy8gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSBiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBmZXdlc3Qgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKSB7XG4gIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbGFuZVRvSW5kZXgobGFuZSkge1xuICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLCBiKSB7XG4gIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhIHwgYjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiBzZXQgJiB+c3Vic2V0O1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZUxhbmUsIGV2ZW50VGltZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBUT0RPOiBUaGVvcmV0aWNhbGx5LCBhbnkgdXBkYXRlIHRvIGFueSBsYW5lIGNhbiB1bmJsb2NrIGFueSBvdGhlciBsYW5lLiBCdXRcbiAgLy8gaXQncyBub3QgcHJhY3RpY2FsIHRvIHRyeSBldmVyeSBzaW5nbGUgcG9zc2libGUgY29tYmluYXRpb24uIFdlIG5lZWQgYVxuICAvLyBoZXVyaXN0aWMgdG8gZGVjaWRlIHdoaWNoIGxhbmVzIHRvIGF0dGVtcHQgdG8gcmVuZGVyLCBhbmQgaW4gd2hpY2ggYmF0Y2hlcy5cbiAgLy8gRm9yIG5vdywgd2UgdXNlIHRoZSBzYW1lIGhldXJpc3RpYyBhcyBpbiB0aGUgb2xkIEV4cGlyYXRpb25UaW1lcyBtb2RlbDpcbiAgLy8gcmV0cnkgYW55IGxhbmUgYXQgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHksIGJ1dCBkb24ndCB0cnkgdXBkYXRlcyBhdCBoaWdoZXJcbiAgLy8gcHJpb3JpdHkgd2l0aG91dCBhbHNvIGluY2x1ZGluZyB0aGUgbG93ZXIgcHJpb3JpdHkgdXBkYXRlcy4gVGhpcyB3b3JrcyB3ZWxsXG4gIC8vIHdoZW4gY29uc2lkZXJpbmcgdXBkYXRlcyBhY3Jvc3MgZGlmZmVyZW50IHByaW9yaXR5IGxldmVscywgYnV0IGlzbid0XG4gIC8vIHN1ZmZpY2llbnQgZm9yIHVwZGF0ZXMgd2l0aGluIHRoZSBzYW1lIHByaW9yaXR5LCBzaW5jZSB3ZSB3YW50IHRvIHRyZWF0XG4gIC8vIHRob3NlIHVwZGF0ZXMgYXMgcGFyYWxsZWwuXG4gIC8vIFVuc3VzcGVuZCBhbnkgdXBkYXRlIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LlxuXG4gIHZhciBoaWdoZXJQcmlvcml0eUxhbmVzID0gdXBkYXRlTGFuZSAtIDE7IC8vIFR1cm5zIDBiMTAwMCBpbnRvIDBiMDExMVxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSBoaWdoZXJQcmlvcml0eUxhbmVzO1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgodXBkYXRlTGFuZSk7IC8vIFdlIGNhbiBhbHdheXMgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRpbWVzdGFtcCBiZWNhdXNlIHdlIHByZWZlciB0aGUgbW9zdFxuICAvLyByZWNlbnQgZXZlbnQsIGFuZCB3ZSBhc3N1bWUgdGltZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5cbiAgZXZlbnRUaW1lc1tpbmRleF0gPSBldmVudFRpbWU7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcykge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcywgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya0Rpc2NyZXRlVXBkYXRlc0V4cGlyZWQocm9vdCkge1xuICByb290LmV4cGlyZWRMYW5lcyB8PSBJbnB1dERpc2NyZXRlTGFuZXMgJiByb290LnBlbmRpbmdMYW5lcztcbn1cbmZ1bmN0aW9uIGhhc0Rpc2NyZXRlTGFuZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIElucHV0RGlzY3JldGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzIHw9IHVwZGF0ZUxhbmUgJiByb290LnBlbmRpbmdMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXZlbnRUaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXM7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgbGFuZXMgPSBlbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuIE9ubHkgdXNlZCBvbiBsYW5lcywgc28gYXNzdW1lIGlucHV0IGlzIGFuIGludGVnZXIuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKGxhbmVzKSB7XG4gIGlmIChsYW5lcyA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2cobGFuZXMpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHdvdWxkIHVzZSBkeW5hbWljIGRpc3BhdGNoIGZvclxudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgcnVuV2l0aFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTsgLy8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xuXG52YXIgX2VuYWJsZWQgPSB0cnVlOyAvLyBUaGlzIGlzIGV4cG9ydGVkIGluIEZCIGJ1aWxkcyBmb3IgdXNlIGJ5IGxlZ2FjeSBGQiBsYXllciBpbmZyYS5cbi8vIFdlJ2QgbGlrZSB0byByZW1vdmUgdGhpcyBidXQgaXQncyBub3QgY2xlYXIgaWYgdGhpcyBpcyBzYWZlLlxuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBldmVudFByaW9yaXR5ID0gZ2V0RXZlbnRQcmlvcml0eUZvclBsdWdpblN5c3RlbShkb21FdmVudE5hbWUpO1xuICB2YXIgbGlzdGVuZXJXcmFwcGVyO1xuXG4gIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgIGNhc2UgRGlzY3JldGVFdmVudDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRGlzY3JldGVFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBVc2VyQmxvY2tpbmdFdmVudDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoVXNlckJsb2NraW5nVXBkYXRlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRpbnVvdXNFdmVudDpcbiAgICBkZWZhdWx0OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hFdmVudDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyV3JhcHBlci5iaW5kKG51bGwsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB7XG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJZk5lZWRlZChuYXRpdmVFdmVudC50aW1lU3RhbXApO1xuICB9XG5cbiAgZGlzY3JldGVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVXNlckJsb2NraW5nVXBkYXRlKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5KFVzZXJCbG9ja2luZ1ByaW9yaXR5JDEsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFsbG93UmVwbGF5ID0gdHJ1ZTtcblxuICB7XG4gICAgLy8gVE9ETzogcmVwbGF5aW5nIGNhcHR1cmUgcGhhc2UgZXZlbnRzIGlzIGN1cnJlbnRseSBicm9rZW5cbiAgICAvLyBiZWNhdXNlIHdlIHVzZWQgdG8gZG8gaXQgZHVyaW5nIHRvcC1sZXZlbCBuYXRpdmUgYnViYmxlIGhhbmRsZXJzXG4gICAgLy8gYnV0IG5vdyB3ZSB1c2UgZGlmZmVyZW50IGJ1YmJsZSBhbmQgY2FwdHVyZSBoYW5kbGVycy5cbiAgICAvLyBJbiBlYWdlciBtb2RlLCB3ZSBhdHRhY2ggY2FwdHVyZSBsaXN0ZW5lcnMgZWFybHksIHNvIHdlIG5lZWRcbiAgICAvLyB0byBmaWx0ZXIgdGhlbSBvdXQgdW50aWwgd2UgZml4IHRoZSBsb2dpYyB0byBoYW5kbGUgdGhlbSBjb3JyZWN0bHkuXG4gICAgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIG91dHNpZGUgdGhlIGZsYWcgYnV0IEkgcHV0IGl0IGluc2lkZSB0byByZWR1Y2Ugcmlzay5cbiAgICBhbGxvd1JlcGxheSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgPT09IDA7XG4gIH1cblxuICBpZiAoYWxsb3dSZXBsYXkgJiYgaGFzUXVldWVkRGlzY3JldGVFdmVudHMoKSAmJiBpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMsIGFuZCB0aGlzIGlzIGFub3RoZXIgZGlzY3JldGVcbiAgICAvLyBldmVudCwgdGhlbiB3ZSBjYW4ndCBkaXNwYXRjaCBpdCByZWdhcmRsZXNzIG9mIGl0cyB0YXJnZXQsIHNpbmNlIHRoZXlcbiAgICAvLyBuZWVkIHRvIGRpc3BhdGNoIGluIG9yZGVyLlxuICAgIHF1ZXVlRGlzY3JldGVFdmVudChudWxsLCAvLyBGbGFncyB0aGF0IHdlJ3JlIG5vdCBhY3R1YWxseSBibG9ja2VkIG9uIGFueXRoaW5nIGFzIGZhciBhcyB3ZSBrbm93LlxuICAgIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICBpZiAoYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQgdGhpcyBldmVudC5cbiAgICBpZiAoYWxsb3dSZXBsYXkpIHtcbiAgICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgaWYgKGlzUmVwbGF5YWJsZURpc2NyZXRlRXZlbnQoZG9tRXZlbnROYW1lKSkge1xuICAgICAgLy8gVGhpcyB0aGlzIHRvIGJlIHJlcGxheWVkIGxhdGVyIG9uY2UgdGhlIHRhcmdldCBpcyBhdmFpbGFibGUuXG4gICAgICBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2UgbmVlZCB0byBjbGVhciBvbmx5IGlmIHdlIGRpZG4ndCBxdWV1ZSBiZWNhdXNlXG4gICAgLy8gcXVldWVpbmcgaXMgYWNjdW1tdWxhdGl2ZS5cblxuXG4gICAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcbiAgfSAvLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbiAgLy8gaW4gY2FzZSB0aGUgZXZlbnQgc3lzdGVtIG5lZWRzIHRvIHRyYWNlIGl0LlxuXG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIG51bGwsIHRhcmdldENvbnRhaW5lcik7XG59IC8vIEF0dGVtcHQgZGlzcGF0Y2hpbmcgYW4gZXZlbnQuIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG5cbmZ1bmN0aW9uIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRPRE86IFdhcm4gaWYgX2VuYWJsZWQgaXMgZmFsc2UuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHRyZWUgaGFzIGJlZW4gdW5tb3VudGVkIGFscmVhZHkuIERpc3BhdGNoIHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUXVldWUgdGhlIGV2ZW50IHRvIGJlIHJlcGxheWVkIGxhdGVyLiBBYm9ydCBkaXNwYXRjaGluZyBzaW5jZSB3ZVxuICAgICAgICAgIC8vIGRvbid0IHdhbnQgdGhpcyBldmVudCBkaXNwYXRjaGVkIHR3aWNlIHRocm91Z2ggdGhlIGV2ZW50IHN5c3RlbS5cbiAgICAgICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBkaXNjcmV0ZSBldmVudCBpbiB0aGUgcXVldWUuIFNjaGVkdWxlIGFuIGluY3JlYXNlZFxuICAgICAgICAgIC8vIHByaW9yaXR5IGZvciB0aGlzIGJvdW5kYXJ5LlxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIHNvbWV0aGluZyB3ZW50IHdyb25nIGJ1dCB0byBhdm9pZCBibG9ja2luZ1xuICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLCBkaXNwYXRjaCB0aGUgZXZlbnQgd2l0aG91dCBhIHRhcmdldC5cbiAgICAgICAgLy8gVE9ETzogV2Fybi5cblxuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGhhcHBlbnMgZHVyaW5nIGEgcmVwbGF5IHNvbWV0aGluZyB3ZW50IHdyb25nIGFuZCBpdCBtaWdodCBibG9ja1xuICAgICAgICAgIC8vIHRoZSB3aG9sZSBzeXN0ZW0uXG4gICAgICAgICAgcmV0dXJuIGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAobmVhcmVzdE1vdW50ZWQgIT09IHRhcmdldEluc3QpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgICAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgICAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKTsgLy8gV2UncmUgbm90IGJsb2NrZWQgb24gYW55dGhpbmcuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9KTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICByb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIHN0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNldCgpIHtcbiAgcm9vdCA9IG51bGw7XG4gIHN0YXJ0VGV4dCA9IG51bGw7XG4gIGZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG5cbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTsgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfSAvLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4gIC8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cblxuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9IC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuXG5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYSBmYWN0b3J5IHNvIHRoYXQgd2UgaGF2ZSBkaWZmZXJlbnQgcmV0dXJuZWQgY29uc3RydWN0b3JzLlxuLy8gSWYgd2UgaGFkIGEgc2luZ2xlIGNvbnN0cnVjdG9yLCBpdCB3b3VsZCBiZSBtZWdhbW9ycGhpYyBhbmQgZW5naW5lcyB3b3VsZCBkZW9wdC5cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAgICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAgICpcbiAgICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAgICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gICAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAgICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAgICpcbiAgICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICAgKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICAgKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gICAqL1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLCByZWFjdEV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW19wcm9wTmFtZV07XG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdGhpc1tfcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuXG4gICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkgey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcblxuICByZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgZXZlbnRQaGFzZTogMCxcbiAgYnViYmxlczogMCxcbiAgY2FuY2VsYWJsZTogMCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gIGlzVHJ1c3RlZDogMFxufTtcbnZhciBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICB2aWV3OiAwLFxuICBkZXRhaWw6IDBcbn0pO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpO1xudmFyIGxhc3RNb3ZlbWVudFg7XG52YXIgbGFzdE1vdmVtZW50WTtcbnZhciBsYXN0TW91c2VFdmVudDtcblxuZnVuY3Rpb24gdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCkge1xuICAgIGlmIChsYXN0TW91c2VFdmVudCAmJiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IGV2ZW50LnNjcmVlblggLSBsYXN0TW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gMDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSAwO1xuICAgIH1cblxuICAgIGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBzY3JlZW5YOiAwLFxuICBzY3JlZW5ZOiAwLFxuICBjbGllbnRYOiAwLFxuICBjbGllbnRZOiAwLFxuICBwYWdlWDogMCxcbiAgcGFnZVk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiAwLFxuICBidXR0b25zOiAwLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgfSxcbiAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFg7XG4gICAgfVxuXG4gICAgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpO1xuICAgIHJldHVybiBsYXN0TW92ZW1lbnRYO1xuICB9LFxuICBtb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICgnbW92ZW1lbnRZJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WTtcbiAgICB9IC8vIERvbid0IG5lZWQgdG8gY2FsbCB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSgpIGhlcmVcbiAgICAvLyBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGFscmVhZHkgcnVuIHdoZW4gbW92ZW1lbnRYXG4gICAgLy8gd2FzIGNvcGllZC5cblxuXG4gICAgcmV0dXJuIGxhc3RNb3ZlbWVudFk7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIERyYWdFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YVRyYW5zZmVyOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHJlbGF0ZWRUYXJnZXQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG5cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGFuaW1hdGlvbk5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG5cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xuXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGE6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbi8vIEhhcHBlbnMgdG8gc2hhcmUgdGhlIHNhbWUgbGlzdCBmb3Igbm93LlxuXG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG5cbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH0gLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuXG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTsgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59OyAvLyBPbGRlciBicm93c2VycyAoU2FmYXJpIDw9IDEwLCBpT1MgU2FmYXJpIDw9IDEwLjIpIGRvIG5vdCBzdXBwb3J0XG4vLyBnZXRNb2RpZmllclN0YXRlLiBJZiBnZXRNb2RpZmllclN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG1hcCBpdCB0byBhIHNldCBvZlxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudC4gSW4gdGhpcyBjYXNlLCBMb2NrLWtleXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuXG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBjb2RlOiAwLFxuICBsb2NhdGlvbjogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgcmVwZWF0OiAwLFxuICBsb2NhbGU6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xuXG52YXIgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBwb2ludGVySWQ6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHByZXNzdXJlOiAwLFxuICB0YW5nZW50aWFsUHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiAwLFxuICBpc1ByaW1hcnk6IDBcbn0pO1xuXG52YXIgU3ludGhldGljUG9pbnRlckV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoUG9pbnRlckV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xuXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgdG91Y2hlczogMCxcbiAgdGFyZ2V0VG91Y2hlczogMCxcbiAgY2hhbmdlZFRvdWNoZXM6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufSk7XG5cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG5cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBwcm9wZXJ0eU5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogMCxcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IDBcbn0pO1xuXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxuXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcblxuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59IC8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG5cblxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlOyAvLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkJlZm9yZUlucHV0JywgWydjb21wb3NpdGlvbmVuZCcsICdrZXlwcmVzcycsICd0ZXh0SW5wdXQnLCAncGFzdGUnXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsIFsnY29tcG9zaXRpb25lbmQnLCAnZm9jdXNvdXQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdtb3VzZWRvd24nXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblN0YXJ0JywgWydjb21wb3NpdGlvbnN0YXJ0JywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25VcGRhdGUnLCBbJ2NvbXBvc2l0aW9udXBkYXRlJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xufSAvLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG5cblxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cblxuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJiAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25TdGFydCc7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25FbmQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb251cGRhdGUnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uVXBkYXRlJztcbiAgfVxufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcblxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59IC8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cblxuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gJ29uQ29tcG9zaXRpb25TdGFydCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uRW5kJztcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSAnb25Db21wb3NpdGlvblN0YXJ0Jykge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25FbmQnKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgZXZlbnRUeXBlKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsIGRvbUV2ZW50TmFtZSwgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcblxuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTsgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICdjb21wb3NpdGlvbmVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cblxuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgJ29uQmVmb3JlSW5wdXQnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsICdiZWZvcmVpbnB1dCcsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG4gICAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KSB7XG4gIGlmICghY2FuVXNlRE9NKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDEoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25DaGFuZ2UnLCBbJ2NoYW5nZScsICdjbGljaycsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2lucHV0JywgJ2tleWRvd24nLCAna2V5dXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCAnb25DaGFuZ2UnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoJ29uQ2hhbmdlJywgJ2NoYW5nZScsIG51bGwsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG5cblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOyAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cblxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSkge1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuXG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG5cblxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3VzaW4nKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn0gLy8gRm9yIElFOCBhbmQgSUU5LlxuXG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2tleXVwJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdpbnB1dCcgfHwgZG9tRXZlbnROYW1lID09PSAnY2hhbmdlJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCAnbnVtYmVyJywgbm9kZS52YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcblxuICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gIH1cblxuICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCk7XG5cbiAgICBpZiAoaW5zdCkge1xuICAgICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICB9IC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCkge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvbk1vdXNlRW50ZXInLCBbJ21vdXNlb3V0JywgJ21vdXNlb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUxlYXZlJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uUG9pbnRlckVudGVyJywgWydwb2ludGVyb3V0JywgJ3BvaW50ZXJvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJMZWF2ZScsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbn1cbi8qKlxuICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBpc092ZXJFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3ZlcicgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm92ZXInO1xuICB2YXIgaXNPdXRFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JztcblxuICBpZiAoaXNPdmVyRXZlbnQgJiYgKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19SRVBMQVlFRCkgPT09IDApIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIG92ZXIgZXZlbnQgd2l0aCBhIHRhcmdldCwgd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGRpc3BhdGNoZWRcbiAgICAvLyB0aGUgZXZlbnQgaW4gdGhlIG91dCBldmVudCBvZiB0aGUgb3RoZXIgdGFyZ2V0LiBJZiB0aGlzIGlzIHJlcGxheWVkLFxuICAgIC8vIHRoZW4gaXQncyBiZWNhdXNlIHdlIGNvdWxkbid0IGRpc3BhdGNoIGFnYWluc3QgdGhpcyB0YXJnZXQgcHJldmlvdXNseVxuICAgIC8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgbm93IGluc3RlYWQuXG4gICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50O1xuXG4gICAgaWYgKHJlbGF0ZWQpIHtcbiAgICAgIC8vIElmIHRoZSByZWxhdGVkIG5vZGUgaXMgbWFuYWdlZCBieSBSZWFjdCwgd2UgY2FuIGFzc3VtZSB0aGF0IHdlIGhhdmVcbiAgICAgIC8vIGFscmVhZHkgZGlzcGF0Y2hlZCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMgZHVyaW5nIGl0cyBtb3VzZW91dC5cbiAgICAgIGlmIChnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSB8fCBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChyZWxhdGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc091dEV2ZW50ICYmICFpc092ZXJFdmVudCkge1xuICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgd2luOyAvLyBUT0RPOiB3aHkgaXMgdGhpcyBudWxsYWJsZSBpbiB0aGUgdHlwZXMgYnV0IHdlIHJlYWQgZnJvbSBpdD9cblxuICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcblxuICAgIGlmIChkb2MpIHtcbiAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZyb207XG4gIHZhciB0bztcblxuICBpZiAoaXNPdXRFdmVudCkge1xuICAgIHZhciBfcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuXG4gICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgdG8gPSBfcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKF9yZWxhdGVkKSA6IG51bGw7XG5cbiAgICBpZiAodG8gIT09IG51bGwpIHtcbiAgICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIodG8pO1xuXG4gICAgICBpZiAodG8gIT09IG5lYXJlc3RNb3VudGVkIHx8IHRvLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiB0by50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHRvID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICBmcm9tID0gbnVsbDtcbiAgICB0byA9IHRhcmdldEluc3Q7XG4gIH1cblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gIHZhciBsZWF2ZUV2ZW50VHlwZSA9ICdvbk1vdXNlTGVhdmUnO1xuICB2YXIgZW50ZXJFdmVudFR5cGUgPSAnb25Nb3VzZUVudGVyJztcbiAgdmFyIGV2ZW50VHlwZVByZWZpeCA9ICdtb3VzZSc7XG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJykge1xuICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudDtcbiAgICBsZWF2ZUV2ZW50VHlwZSA9ICdvblBvaW50ZXJMZWF2ZSc7XG4gICAgZW50ZXJFdmVudFR5cGUgPSAnb25Qb2ludGVyRW50ZXInO1xuICAgIGV2ZW50VHlwZVByZWZpeCA9ICdwb2ludGVyJztcbiAgfVxuXG4gIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7XG4gIHZhciBsZWF2ZSA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IobGVhdmVFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdsZWF2ZScsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuICB2YXIgZW50ZXIgPSBudWxsOyAvLyBXZSBzaG91bGQgb25seSBwcm9jZXNzIHRoaXMgbmF0aXZlRXZlbnQgaWYgd2UgYXJlIHByb2Nlc3NpbmdcbiAgLy8gdGhlIGZpcnN0IGFuY2VzdG9yLiBOZXh0IHRpbWUsIHdlIHdpbGwgaWdub3JlIHRoZSBldmVudC5cblxuICB2YXIgbmF0aXZlVGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobmF0aXZlVGFyZ2V0SW5zdCA9PT0gdGFyZ2V0SW5zdCkge1xuICAgIHZhciBlbnRlckV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihlbnRlckV2ZW50VHlwZSwgZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJywgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXJFdmVudC50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXJFdmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgZW50ZXIgPSBlbnRlckV2ZW50O1xuICB9XG5cbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVUd29QaGFzZUxpc3RlbmVycyhkaXNwYXRjaFF1ZXVlLCBsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGhhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhb2JqZWN0SXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gb3V0ZXJOb2RlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0OyAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG5cblxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5cblxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cblxuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgLy8gRWRnZSBmYWlscyB3aXRoIFwiT2JqZWN0IGV4cGVjdGVkXCIgaW4gc29tZSBzY2VuYXJpb3MuXG4gIC8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4gIC8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuXG4gIGlmICghd2luLmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpOyAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50ICYmIGNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZS5cbiAgICAvLyBTYWZhcmkgd2lsbCBzaG93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGFjY2VzcyByZXN1bHRzIGluIFwiQmxvY2tlZCBhIGZyYW1lIHdpdGggb3JpZ2luXCIuIGUuZzpcbiAgICAvLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIC8vIEEgc2FmZXR5IHdheSBpcyB0byBhY2Nlc3Mgb25lIG9mIHRoZSBjcm9zcyBvcmlnaW4gcHJvcGVydGllczogV2luZG93IG9yIExvY2F0aW9uXG4gICAgLy8gV2hpY2ggbWlnaHQgcmVzdWx0IGluIFwiU2VjdXJpdHlFcnJvclwiIERPTSBFeGNlcHRpb24gYW5kIGl0IGlzIGNvbXBhdGlibGUgdG8gU2FmYXJpLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbiAgICByZXR1cm4gdHlwZW9mIGlmcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKSB7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgaWYgKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KHdpbi5kb2N1bWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAndGV4dCcgfHwgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fCBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8IGVsZW0udHlwZSA9PT0gJ3VybCcgfHwgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG5cbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH0gLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcblxuXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbjtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uU2VsZWN0JywgWydmb2N1c291dCcsICdjb250ZXh0bWVudScsICdkcmFnZW5kJywgJ2ZvY3VzaW4nLCAna2V5ZG93bicsICdrZXl1cCcsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdzZWxlY3Rpb25jaGFuZ2UnXSk7XG59XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldERvY3VtZW50KGV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBldmVudFRhcmdldC53aW5kb3cgPT09IGV2ZW50VGFyZ2V0ID8gZXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IGV2ZW50VGFyZ2V0IDogZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbn1cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgdmFyIGRvYyA9IGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuXG5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO1xuXG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCAnb25TZWxlY3QnKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvblNlbGVjdCcsICdzZWxlY3QnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgICBldmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuXG4gIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cblxuICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnbW91c2V1cCc6XG4gICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBicmVhaztcbiAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgIC8vXG4gICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cblxuICAgIGNhc2UgJ3NlbGVjdGlvbmNoYW5nZSc6XG4gICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSAna2V5ZG93bic6XG4gICAgY2FzZSAna2V5dXAnOlxuICAgICAgY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgcmVhY3ROYW1lID0gdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuZ2V0KGRvbUV2ZW50TmFtZSk7XG5cbiAgaWYgKHJlYWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICB2YXIgcmVhY3RFdmVudFR5cGUgPSBkb21FdmVudE5hbWU7XG5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgY2FzZSAna2V5ZG93bic6XG4gICAgY2FzZSAna2V5dXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICByZWFjdEV2ZW50VHlwZSA9ICdmb2N1cyc7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICByZWFjdEV2ZW50VHlwZSA9ICdibHVyJztcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlZm9yZWJsdXInOlxuICAgIGNhc2UgJ2FmdGVyYmx1cic6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjbGljayc6XG4gICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgY2FzZSAnYXV4Y2xpY2snOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgY2FzZSAnbW91c2V1cCc6IC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RyYWcnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgY2FzZSAnZHJhZ2V4aXQnOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgY2FzZSAnZHJhZ292ZXInOlxuICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgY2FzZSAnZHJvcCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQU5JTUFUSU9OX0VORDpcbiAgICBjYXNlIEFOSU1BVElPTl9JVEVSQVRJT046XG4gICAgY2FzZSBBTklNQVRJT05fU1RBUlQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUUkFOU0lUSU9OX0VORDpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NvcHknOlxuICAgIGNhc2UgJ2N1dCc6XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2dvdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdsb3N0cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAge1xuICAgIC8vIFNvbWUgZXZlbnRzIGRvbid0IGJ1YmJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAvLyBJbiB0aGUgcGFzdCwgUmVhY3QgaGFzIGFsd2F5cyBidWJibGVkIHRoZW0sIGJ1dCB0aGlzIGNhbiBiZSBzdXJwcmlzaW5nLlxuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHRyeSBhbGlnbmluZyBjbG9zZXIgdG8gdGhlIGJyb3dzZXIgYmVoYXZpb3IgYnkgbm90IGJ1YmJsaW5nXG4gICAgLy8gdGhlbSBpbiBSZWFjdCBlaXRoZXIuIFdlJ2xsIHN0YXJ0IGJ5IG5vdCBidWJibGluZyBvblNjcm9sbCwgYW5kIHRoZW4gZXhwYW5kLlxuICAgIHZhciBhY2N1bXVsYXRlVGFyZ2V0T25seSA9ICFpbkNhcHR1cmVQaGFzZSAmJiAvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYWRkIGFsbCBldmVudHMgZnJvbVxuICAgIC8vIG5vbkRlbGVnYXRlZEV2ZW50cyBsaXN0IGluIERPTVBsdWdpbkV2ZW50U3lzdGVtLlxuICAgIC8vIFRoZW4gd2UgY2FuIHJlbW92ZSB0aGlzIHNwZWNpYWwgbGlzdC5cbiAgICAvLyBUaGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlIHRoYXQgY2FuIHdhaXQgdW50aWwgUmVhY3QgMTguXG4gICAgZG9tRXZlbnROYW1lID09PSAnc2Nyb2xsJztcblxuICAgIHZhciBfbGlzdGVuZXJzID0gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnQudHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KTtcblxuICAgIGlmIChfbGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgY3JlYXRlIGV2ZW50IGxhemlseS5cbiAgICAgIHZhciBfZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBfZXZlbnQsXG4gICAgICAgIGxpc3RlbmVyczogX2xpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE86IHJlbW92ZSB0b3AtbGV2ZWwgc2lkZSBlZmZlY3QuXG5yZWdpc3RlclNpbXBsZUV2ZW50cygpO1xucmVnaXN0ZXJFdmVudHMkMigpO1xucmVnaXN0ZXJFdmVudHMkMSgpO1xucmVnaXN0ZXJFdmVudHMkMygpO1xucmVnaXN0ZXJFdmVudHMoKTtcblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgLy8gVE9ETzogd2Ugc2hvdWxkIHJlbW92ZSB0aGUgY29uY2VwdCBvZiBhIFwiU2ltcGxlRXZlbnRQbHVnaW5cIi5cbiAgLy8gVGhpcyBpcyB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZXZlbnQgc3lzdGVtLiBBbGxcbiAgLy8gdGhlIG90aGVyIHBsdWdpbnMgYXJlIGVzc2VudGlhbGx5IHBvbHlmaWxscy4gU28gdGhlIHBsdWdpblxuICAvLyBzaG91bGQgcHJvYmFibHkgYmUgaW5saW5lZCBzb21ld2hlcmUgYW5kIGhhdmUgaXRzIGxvZ2ljXG4gIC8vIGJlIGNvcmUgdGhlIHRvIGV2ZW50IHN5c3RlbS4gVGhpcyB3b3VsZCBwb3RlbnRpYWxseSBhbGxvd1xuICAvLyB1cyB0byBzaGlwIGJ1aWxkcyBvZiBSZWFjdCB3aXRob3V0IHRoZSBwb2x5ZmlsbGVkIHBsdWdpbnMgYmVsb3cuXG4gIGV4dHJhY3RFdmVudHMkNChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncyk7XG4gIHZhciBzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zID0gKGV2ZW50U3lzdGVtRmxhZ3MgJiBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUykgPT09IDA7IC8vIFdlIGRvbid0IHByb2Nlc3MgdGhlc2UgZXZlbnRzIHVubGVzcyB3ZSBhcmUgaW4gdGhlXG4gIC8vIGV2ZW50J3MgbmF0aXZlIFwiYnViYmxlXCIgcGhhc2UsIHdoaWNoIG1lYW5zIHRoYXQgd2UncmVcbiAgLy8gbm90IGluIHRoZSBjYXB0dXJlIHBoYXNlLiBUaGF0J3MgYmVjYXVzZSB3ZSBlbXVsYXRlXG4gIC8vIHRoZSBjYXB0dXJlIHBoYXNlIGhlcmUgc3RpbGwuIFRoaXMgaXMgYSB0cmFkZS1vZmYsXG4gIC8vIGJlY2F1c2UgaW4gYW4gaWRlYWwgd29ybGQgd2Ugd291bGQgbm90IGVtdWxhdGUgYW5kIHVzZVxuICAvLyB0aGUgcGhhc2VzIHByb3Blcmx5LCBsaWtlIHdlIGRvIHdpdGggdGhlIFNpbXBsZUV2ZW50XG4gIC8vIHBsdWdpbi4gSG93ZXZlciwgdGhlIHBsdWdpbnMgYmVsb3cgZWl0aGVyIGV4cGVjdFxuICAvLyBlbXVsYXRpb24gKEVudGVyTGVhdmUpIG9yIHVzZSBzdGF0ZSBsb2NhbGl6ZWQgdG8gdGhhdFxuICAvLyBwbHVnaW4gKEJlZm9yZUlucHV0LCBDaGFuZ2UsIFNlbGVjdCkuIFRoZSBzdGF0ZSBpblxuICAvLyB0aGVzZSBtb2R1bGVzIGNvbXBsaWNhdGVzIHRoaW5ncywgYXMgeW91J2xsIGVzc2VudGlhbGx5XG4gIC8vIGdldCB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBwaGFzZSBldmVudCBtaWdodCBjaGFuZ2VcbiAgLy8gc3RhdGUsIG9ubHkgZm9yIHRoZSBmb2xsb3dpbmcgYnViYmxlIGV2ZW50IHRvIGNvbWUgaW5cbiAgLy8gbGF0ZXIgYW5kIG5vdCB0cmlnZ2VyIGFueXRoaW5nIGFzIHRoZSBzdGF0ZSBub3dcbiAgLy8gaW52YWxpZGF0ZXMgdGhlIGhldXJpc3RpY3Mgb2YgdGhlIGV2ZW50IHBsdWdpbi4gV2VcbiAgLy8gY291bGQgYWx0ZXIgYWxsIHRoZXNlIHBsdWdpbnMgdG8gd29yayBpbiBzdWNoIHdheXMsIGJ1dFxuICAvLyB0aGF0IG1pZ2h0IGNhdXNlIG90aGVyIHVua25vd24gc2lkZS1lZmZlY3RzIHRoYXQgd2VcbiAgLy8gY2FuJ3QgZm9yc2VlIHJpZ2h0IG5vdy5cblxuICBpZiAoc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucykge1xuICAgIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncyk7XG4gICAgZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGV4dHJhY3RFdmVudHMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICB9XG59IC8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG5cblxudmFyIG1lZGlhRXZlbnRUeXBlcyA9IFsnYWJvcnQnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdsb2FkZWRkYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZWNoYW5nZScsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd2b2x1bWVjaGFuZ2UnLCAnd2FpdGluZyddOyAvLyBXZSBzaG91bGQgbm90IGRlbGVnYXRlIHRoZXNlIGV2ZW50cyB0byB0aGUgY29udGFpbmVyLCBidXQgcmF0aGVyXG4vLyBzZXQgdGhlbSBvbiB0aGUgYWN0dWFsIHRhcmdldCBlbGVtZW50IGl0c2VsZi4gVGhpcyBpcyBwcmltYXJpbHlcbi8vIGJlY2F1c2UgdGhlc2UgZXZlbnRzIGRvIG5vdCBjb25zaXN0ZW50bHkgYnViYmxlIGluIHRoZSBET00uXG5cbnZhciBub25EZWxlZ2F0ZWRFdmVudHMgPSBuZXcgU2V0KFsnY2FuY2VsJywgJ2Nsb3NlJywgJ2ludmFsaWQnLCAnbG9hZCcsICdzY3JvbGwnLCAndG9nZ2xlJ10uY29uY2F0KG1lZGlhRXZlbnRUeXBlcykpO1xuXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcHJldmlvdXNJbnN0YW5jZTtcblxuICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICBmb3IgKHZhciBpID0gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IGRpc3BhdGNoTGlzdGVuZXJzW2ldLFxuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcblxuICAgICAgaWYgKGluc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRfaSA9IGRpc3BhdGNoTGlzdGVuZXJzW19pXSxcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsXG4gICAgICAgICAgX2N1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBfbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kubGlzdGVuZXI7XG5cbiAgICAgIGlmIChfaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgX2xpc3RlbmVyLCBfY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgICBldmVudCA9IF9kaXNwYXRjaFF1ZXVlJGkuZXZlbnQsXG4gICAgICAgIGxpc3RlbmVycyA9IF9kaXNwYXRjaFF1ZXVlJGkubGlzdGVuZXJzO1xuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBsaXN0ZW5lcnMsIGluQ2FwdHVyZVBoYXNlKTsgLy8gIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICB9IC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuXG5cbiAgcmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBleHRyYWN0RXZlbnRzJDUoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEVsZW1lbnQpIHtcbiAgdmFyIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXRFbGVtZW50KTtcbiAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBkb21FdmVudE5hbWUsIElTX05PTl9ERUxFR0FURUQsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cbnZhciBsaXN0ZW5pbmdNYXJrZXIgPSAnX3JlYWN0TGlzdGVuaW5nJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGRvbid0IGl0ZXJhdGUgdGhyb3VnaCBldmVudHNcbiAgICAgIC8vIGZvciB0aGUgc2FtZSBwb3J0YWwgY29udGFpbmVyIG9yIHJvb3Qgbm9kZSBtb3JlIHRoYW4gb25jZS5cbiAgICAgIC8vIFRPRE86IG9uY2Ugd2UgcmVtb3ZlIHRoZSBmbGFnLCB3ZSBtYXkgYmUgYWJsZSB0byBhbHNvXG4gICAgICAvLyByZW1vdmUgc29tZSBvZiB0aGUgYm9va2tlZXBpbmcgbWFwcyB1c2VkIGZvciBsYXppbmVzcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdID0gdHJ1ZTtcbiAgICBhbGxOYXRpdmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRXZlbnROYW1lKSB7XG4gICAgICBpZiAoIW5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgZmFsc2UsIHJvb3RDb250YWluZXJFbGVtZW50LCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIHRydWUsIHJvb3RDb250YWluZXJFbGVtZW50LCBudWxsKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsIHJvb3RDb250YWluZXJFbGVtZW50LCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBldmVudFN5c3RlbUZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICB2YXIgdGFyZ2V0ID0gcm9vdENvbnRhaW5lckVsZW1lbnQ7IC8vIHNlbGVjdGlvbmNoYW5nZSBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnRcbiAgLy8gb3RoZXJ3aXNlIGl0IHdvbid0IGNhcHR1cmUgaW5jb21pbmcgZXZlbnRzIHRoYXQgYXJlIG9ubHlcbiAgLy8gdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCBkaXJlY3RseS5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyAmJiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIH0gLy8gSWYgdGhlIGV2ZW50IGNhbiBiZSBkZWxlZ2F0ZWQgKG9yIGlzIGNhcHR1cmUgcGhhc2UpLCB3ZSBjYW5cbiAgLy8gcmVnaXN0ZXIgaXQgdG8gdGhlIHJvb3QgY29udGFpbmVyLiBPdGhlcndpc2UsIHdlIHNob3VsZFxuICAvLyByZWdpc3RlciB0aGUgZXZlbnQgdG8gdGhlIHRhcmdldCBlbGVtZW50IGFuZCBtYXJrIGl0IGFzXG4gIC8vIGEgbm9uLWRlbGVnYXRlZCBldmVudC5cblxuXG4gIGlmICh0YXJnZXRFbGVtZW50ICE9PSBudWxsICYmICFpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgIC8vIEZvciBhbGwgbm9uLWRlbGVnYXRlZCBldmVudHMsIGFwYXJ0IGZyb20gc2Nyb2xsLCB3ZSBhdHRhY2hcbiAgICAvLyB0aGVpciBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJlc3BlY3RpdmUgZWxlbWVudHMgdGhhdCB0aGVpclxuICAgIC8vIGV2ZW50cyBmaXJlIG9uLiBUaGF0IG1lYW5zIHdlIGNhbiBza2lwIHRoaXMgc3RlcCwgYXMgZXZlbnRcbiAgICAvLyBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHByZXZpb3VzbHkuIEhvd2V2ZXIsIHdlXG4gICAgLy8gc3BlY2lhbCBjYXNlIHRoZSBzY3JvbGwgZXZlbnQgYmVjYXVzZSB0aGUgcmVhbGl0eSBpcyB0aGF0IGFueVxuICAgIC8vIGVsZW1lbnQgY2FuIHNjcm9sbC5cbiAgICAvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYXBwbHkgdGhlIHNhbWUgbG9naWMgdG8gYWxsXG4gICAgLy8gZXZlbnRzIGZyb20gdGhlIG5vbkRlbGVnYXRlZEV2ZW50cyBsaXN0LiBUaGVuIHdlIGNhbiByZW1vdmVcbiAgICAvLyB0aGlzIHNwZWNpYWwgY2FzZSBhbmQgdXNlIHRoZSBzYW1lIGxvZ2ljIGZvciBhbGwgZXZlbnRzLlxuICAgIGlmIChkb21FdmVudE5hbWUgIT09ICdzY3JvbGwnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19OT05fREVMRUdBVEVEO1xuICAgIHRhcmdldCA9IHRhcmdldEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJTZXQgPSBnZXRFdmVudExpc3RlbmVyU2V0KHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7IC8vIElmIHRoZSBsaXN0ZW5lciBlbnRyeSBpcyBlbXB0eSBvciB3ZSBzaG91bGQgdXBncmFkZSwgdGhlblxuICAvLyB3ZSBuZWVkIHRvIHRyYXAgYW4gZXZlbnQgbGlzdGVuZXIgb250byB0aGUgdGFyZ2V0LlxuXG4gIGlmICghbGlzdGVuZXJTZXQuaGFzKGxpc3RlbmVyU2V0S2V5KSkge1xuICAgIGlmIChpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKSB7XG4gICAgICBldmVudFN5c3RlbUZsYWdzIHw9IElTX0NBUFRVUkVfUEhBU0U7XG4gICAgfVxuXG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsIGlzRGVmZXJyZWRMaXN0ZW5lckZvckxlZ2FjeUZCU3VwcG9ydCkge1xuICB2YXIgbGlzdGVuZXIgPSBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncyk7IC8vIElmIHBhc3NpdmUgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZW4gdGhlIGV2ZW50IHdpbGwgYmVcbiAgLy8gYWN0aXZlIGFuZCBub3QgcGFzc2l2ZS5cblxuICB2YXIgaXNQYXNzaXZlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgLy8gQnJvd3NlcnMgaW50cm9kdWNlZCBhbiBpbnRlcnZlbnRpb24sIG1ha2luZyB0aGVzZSBldmVudHNcbiAgICAvLyBwYXNzaXZlIGJ5IGRlZmF1bHQgb24gZG9jdW1lbnQuIFJlYWN0IGRvZXNuJ3QgYmluZCB0aGVtXG4gICAgLy8gdG8gZG9jdW1lbnQgYW55bW9yZSwgYnV0IGNoYW5naW5nIHRoaXMgbm93IHdvdWxkIHVuZG9cbiAgICAvLyB0aGUgcGVyZm9ybWFuY2Ugd2lucyBmcm9tIHRoZSBjaGFuZ2UuIFNvIHdlIGVtdWxhdGVcbiAgICAvLyB0aGUgZXhpc3RpbmcgYmVoYXZpb3IgbWFudWFsbHkgb24gdGhlIHJvb3RzIG5vdy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5NjUxXG4gICAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3RvdWNobW92ZScgfHwgZG9tRXZlbnROYW1lID09PSAnd2hlZWwnKSB7XG4gICAgICBpc1Bhc3NpdmVMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0Q29udGFpbmVyID0gIHRhcmdldENvbnRhaW5lcjtcbiAgdmFyIHVuc3Vic2NyaWJlTGlzdGVuZXI7IC8vIFdoZW4gbGVnYWN5RkJTdXBwb3J0IGlzIGVuYWJsZWQsIGl0J3MgZm9yIHdoZW4gd2VcblxuXG4gIGlmIChpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKSB7XG4gICAgaWYgKGlzUGFzc2l2ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIsIGlzUGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIsIGlzUGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoZ3JhbmRDb250YWluZXIsIHRhcmdldENvbnRhaW5lcikge1xuICByZXR1cm4gZ3JhbmRDb250YWluZXIgPT09IHRhcmdldENvbnRhaW5lciB8fCBncmFuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIGdyYW5kQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRhcmdldENvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgYW5jZXN0b3JJbnN0ID0gdGFyZ2V0SW5zdDtcblxuICBpZiAoKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSkgPT09IDAgJiYgKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19OT05fREVMRUdBVEVEKSA9PT0gMCkge1xuICAgIHZhciB0YXJnZXRDb250YWluZXJOb2RlID0gdGFyZ2V0Q29udGFpbmVyOyAvLyBJZiB3ZSBhcmUgdXNpbmcgdGhlIGxlZ2FjeSBGQiBzdXBwb3J0IGZsYWcsIHdlXG5cbiAgICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhlIGJlbG93IGxvZ2ljIGF0dGVtcHRzIHRvIHdvcmsgb3V0IGlmIHdlIG5lZWQgdG8gY2hhbmdlXG4gICAgICAvLyB0aGUgdGFyZ2V0IGZpYmVyIHRvIGEgZGlmZmVyZW50IGFuY2VzdG9yLiBXZSBoYWQgc2ltaWxhciBsb2dpY1xuICAgICAgLy8gaW4gdGhlIGxlZ2FjeSBldmVudCBzeXN0ZW0sIGV4Y2VwdCB0aGUgYmlnIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAgLy8gc3lzdGVtcyBpcyB0aGF0IHRoZSBtb2Rlcm4gZXZlbnQgc3lzdGVtIG5vdyBoYXMgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgIC8vIGF0dGFjaGVkIHRvIGVhY2ggUmVhY3QgUm9vdCBhbmQgUmVhY3QgUG9ydGFsIFJvb3QuIFRvZ2V0aGVyLFxuICAgICAgLy8gdGhlIERPTSBub2RlcyByZXByZXNlbnRpbmcgdGhlc2Ugcm9vdHMgYXJlIHRoZSBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIFRvIGZpZ3VyZSBvdXQgd2hpY2ggYW5jZXN0b3IgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZSwgd2UgdHJhdmVyc2VcbiAgICAgIC8vIHVwIHRoZSBmaWJlciB0cmVlIGZyb20gdGhlIHRhcmdldCBpbnN0YW5jZSBhbmQgYXR0ZW1wdCB0byBmaW5kXG4gICAgICAvLyByb290IGJvdW5kYXJpZXMgdGhhdCBtYXRjaCB0aGF0IG9mIG91ciBjdXJyZW50IFwicm9vdENvbnRhaW5lclwiLlxuICAgICAgLy8gSWYgd2UgZmluZCB0aGF0IFwicm9vdENvbnRhaW5lclwiLCB3ZSBmaW5kIHRoZSBwYXJlbnQgZmliZXJcbiAgICAgIC8vIHN1Yi10cmVlIGZvciB0aGF0IHJvb3QgYW5kIG1ha2UgdGhhdCBvdXIgYW5jZXN0b3IgaW5zdGFuY2UuXG4gICAgICB2YXIgbm9kZSA9IHRhcmdldEluc3Q7XG5cbiAgICAgIG1haW5Mb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlVGFnID0gbm9kZS50YWc7XG5cbiAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RSb290IHx8IG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhcmdldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZVRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBpcyBhIHBvcnRhbCwgYnV0IGl0J3Mgbm90IHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgICAgICAgICAgLy8gTm9ybWFsbHkgcG9ydGFscyBoYW5kbGUgdGhlaXIgb3duIGV2ZW50cyBhbGwgdGhlIHdheSBkb3duIHRvIHRoZSByb290LlxuICAgICAgICAgICAgLy8gU28gd2Ugc2hvdWxkIGJlIGFibGUgdG8gc3RvcCBub3cuIEhvd2V2ZXIsIHdlIGRvbid0IGtub3cgaWYgdGhpcyBwb3J0YWxcbiAgICAgICAgICAgIC8vIHdhcyBwYXJ0IG9mICpvdXIqIHJvb3QuXG4gICAgICAgICAgICB2YXIgZ3JhbmROb2RlID0gbm9kZS5yZXR1cm47XG5cbiAgICAgICAgICAgIHdoaWxlIChncmFuZE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGdyYW5kVGFnID0gZ3JhbmROb2RlLnRhZztcblxuICAgICAgICAgICAgICBpZiAoZ3JhbmRUYWcgPT09IEhvc3RSb290IHx8IGdyYW5kVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYW5kQ29udGFpbmVyID0gZ3JhbmROb2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvciBhbmQgd2UgZm91bmQgaXQgYXNcbiAgICAgICAgICAgICAgICAgIC8vIGEgcGFyZW50IG9mIHRoZSBQb3J0YWwuIFRoYXQgbWVhbnMgd2UgY2FuIGlnbm9yZSBpdCBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gUG9ydGFsIHdpbGwgYnViYmxlIHRocm91Z2ggdG8gdXMuXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JhbmROb2RlID0gZ3JhbmROb2RlLnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE5vdyB3ZSBuZWVkIHRvIGZpbmQgaXQncyBjb3JyZXNwb25kaW5nIGhvc3QgZmliZXIgaW4gdGhlIG90aGVyXG4gICAgICAgICAgLy8gdHJlZS4gVG8gZG8gdGhpcyB3ZSBjYW4gdXNlIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLCBidXQgd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGZpYmVyIGlzIGEgaG9zdCBpbnN0YW5jZSwgb3RoZXJ3aXNlXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byB0cmF2ZXJzZSB1cCB0aHJvdWdoIHRoZSBET00gdGlsbCB3ZSBmaW5kIHRoZSBjb3JyZWN0XG4gICAgICAgICAgLy8gbm9kZSB0aGF0IGlzIGZyb20gdGhlIG90aGVyIHRyZWUuXG5cblxuICAgICAgICAgIHdoaWxlIChjb250YWluZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50Tm9kZS50YWc7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRUYWcgPT09IEhvc3RDb21wb25lbnQgfHwgcGFyZW50VGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICAgICAgICBub2RlID0gYW5jZXN0b3JJbnN0ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiYXRjaGVkRXZlbnRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIGFuY2VzdG9ySW5zdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICB9O1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnRUeXBlLCBpbkNhcHR1cmVQaGFzZSwgYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgdmFyIGNhcHR1cmVOYW1lID0gcmVhY3ROYW1lICE9PSBudWxsID8gcmVhY3ROYW1lICsgJ0NhcHR1cmUnIDogbnVsbDtcbiAgdmFyIHJlYWN0RXZlbnROYW1lID0gaW5DYXB0dXJlUGhhc2UgPyBjYXB0dXJlTmFtZSA6IHJlYWN0TmFtZTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjtcbiAgdmFyIGxhc3RIb3N0Q29tcG9uZW50ID0gbnVsbDsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UyID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTIuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UyLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICBsYXN0SG9zdENvbXBvbmVudCA9IHN0YXRlTm9kZTsgLy8gY3JlYXRlRXZlbnRIYW5kbGUgbGlzdGVuZXJzXG5cblxuICAgICAgaWYgKHJlYWN0RXZlbnROYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdEV2ZW50TmFtZSk7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgbGFzdEhvc3RDb21wb25lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSWYgd2UgYXJlIG9ubHkgYWNjdW11bGF0aW5nIGV2ZW50cyBmb3IgdGhlIHRhcmdldCwgdGhlbiB3ZSBkb24ndFxuICAgIC8vIGNvbnRpbnVlIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSBSZWFjdCBmaWJlciB0cmVlIHRvIGZpbmQgb3RoZXJcbiAgICAvLyBsaXN0ZW5lcnMuXG5cblxuICAgIGlmIChhY2N1bXVsYXRlVGFyZ2V0T25seSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJzO1xufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbi8vIC0gQ2hhbmdlRXZlbnRQbHVnaW5cbi8vIC0gU2VsZWN0RXZlbnRQbHVnaW5cbi8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHByb2Nlc3MgdGhlc2UgcGx1Z2luc1xuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzICh2aWEgZW11bGF0aW9uKS5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpIHtcbiAgdmFyIGNhcHR1cmVOYW1lID0gcmVhY3ROYW1lICsgJ0NhcHR1cmUnO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBpbnN0YW5jZSA9IHRhcmdldEZpYmVyOyAvLyBBY2N1bXVsYXRlIGFsbCBpbnN0YW5jZXMgYW5kIGxpc3RlbmVycyB2aWEgdGhlIHRhcmdldCAtPiByb290IHBhdGguXG5cbiAgd2hpbGUgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgdmFyIF9pbnN0YW5jZTMgPSBpbnN0YW5jZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlMy5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTMudGFnOyAvLyBIYW5kbGUgbGlzdGVuZXJzIHRoYXQgYXJlIG9uIEhvc3RDb21wb25lbnRzIChpLmUuIDxkaXY+KVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTmFtZSk7XG5cbiAgICAgIGlmIChjYXB0dXJlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlYWN0TmFtZSk7XG5cbiAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGJ1YmJsZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBpZiAoaW5zdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjsgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgbm9kZUEgPSBpbnN0QTtcbiAgdmFyIG5vZGVCID0gaW5zdEI7XG4gIHZhciBkZXB0aEEgPSAwO1xuXG4gIGZvciAodmFyIHRlbXBBID0gbm9kZUE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuXG4gIHZhciBkZXB0aEIgPSAwO1xuXG4gIGZvciAodmFyIHRlbXBCID0gbm9kZUI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfSAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG5cblxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIG5vZGVBID0gZ2V0UGFyZW50KG5vZGVBKTtcbiAgICBkZXB0aEEtLTtcbiAgfSAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG5cblxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIG5vZGVCID0gZ2V0UGFyZW50KG5vZGVCKTtcbiAgICBkZXB0aEItLTtcbiAgfSAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cblxuXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcblxuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChub2RlQSA9PT0gbm9kZUIgfHwgbm9kZUIgIT09IG51bGwgJiYgbm9kZUEgPT09IG5vZGVCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIG5vZGVBO1xuICAgIH1cblxuICAgIG5vZGVBID0gZ2V0UGFyZW50KG5vZGVBKTtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBldmVudCwgdGFyZ2V0LCBjb21tb24sIGluQ2FwdHVyZVBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXQ7XG5cbiAgd2hpbGUgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgaWYgKGluc3RhbmNlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBfaW5zdGFuY2U0ID0gaW5zdGFuY2UsXG4gICAgICAgIGFsdGVybmF0ZSA9IF9pbnN0YW5jZTQuYWx0ZXJuYXRlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2U0LnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlNC50YWc7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBzdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChpbkNhcHR1cmVQaGFzZSkge1xuICAgICAgICB2YXIgY2FwdHVyZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChjYXB0dXJlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGNhcHR1cmVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpbkNhcHR1cmVQaGFzZSkge1xuICAgICAgICB2YXIgYnViYmxlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgaWYgKGJ1YmJsZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59IC8vIFdlIHNob3VsZCBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvcjpcbi8vIC0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoaXMgcGx1Z2luXG4vLyBpbiB0aGUgYnViYmxlIHBoYXNlLCBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgdHdvXG4vLyBwaGFzZSBldmVudCBsaXN0ZW5lcnMuXG5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVUd29QaGFzZUxpc3RlbmVycyhkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBlbnRlckV2ZW50LCBmcm9tLCB0bykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG5cbiAgaWYgKGZyb20gIT09IG51bGwpIHtcbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsIGxlYXZlRXZlbnQsIGZyb20sIGNvbW1vbiwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKHRvICE9PSBudWxsICYmIGVudGVyRXZlbnQgIT09IG51bGwpIHtcbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsIGVudGVyRXZlbnQsIHRvLCBjb21tb24sIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSArIFwiX19cIiArIChjYXB0dXJlID8gJ2NhcHR1cmUnIDogJ2J1YmJsZScpO1xufVxuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSBOYW1lc3BhY2VzLmh0bWw7XG52YXIgd2FybmVkVW5rbm93blRhZ3M7XG52YXIgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nO1xudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQ7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcjtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO1xudmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZTtcbnZhciBub3JtYWxpemVIVE1MO1xuXG57XG4gIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZSxcbiAgICAvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbiAgICAvLyBhbiBpc29sYXRlZCBmcmFtZSBhbmQgcHJvY2Vzcy5cbiAgICAvLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbiAgICAvLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS93ZWJ2aWV3LXRhZ1xuICAgIHdlYnZpZXc6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIHtcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzXG4gICAgfSk7XG4gIH07IC8vIElFIDExIHBhcnNlcyAmIG5vcm1hbGl6ZXMgdGhlIHN0eWxlIGF0dHJpYnV0ZSBhcyBvcHBvc2VkIHRvIG90aGVyXG4gIC8vIGJyb3dzZXJzLiBJdCBhZGRzIHNwYWNlcyBhbmQgc29ydHMgdGhlIHByb3BlcnRpZXMgaW4gc29tZVxuICAvLyBub24tYWxwaGFiZXRpY2FsIG9yZGVyLiBIYW5kbGluZyB0aGF0IHdvdWxkIHJlcXVpcmUgc29ydGluZyBDU1NcbiAgLy8gcHJvcGVydGllcyBpbiB0aGUgY2xpZW50ICYgc2VydmVyIHZlcnNpb25zIG9yIGFwcGx5aW5nXG4gIC8vIGBleHBlY3RlZFN0eWxlYCB0byBhIHRlbXBvcmFyeSBET00gbm9kZSB0byByZWFkIGl0cyBgc3R5bGVgIGF0dHJpYnV0ZVxuICAvLyBub3JtYWxpemVkLiBTaW5jZSBpdCBvbmx5IGFmZmVjdHMgSUUsIHdlJ3JlIHNraXBwaW5nIHN0eWxlIHdhcm5pbmdzXG4gIC8vIGluIHRoYXQgYnJvd3NlciBjb21wbGV0ZWx5IGluIGZhdm9yIG9mIGRvaW5nIGFsbCB0aGF0IHdvcmsuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExODA3XG5cblxuICBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gY2FuVXNlRE9NICYmICFkb2N1bWVudC5kb2N1bWVudE1vZGU7IC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcblxuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZXMpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcblxuICAgIGVycm9yKCdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTsgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG5cblxuICBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKSB7XG4gIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gbm9vcDtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuXG5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG5cbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIC8vIFRPRE86IEhhbmRsZSB3YXNDdXN0b21Db21wb25lbnRUYWdcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVQYXlsb2FkLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHByb3BLZXkgPSB1cGRhdGVQYXlsb2FkW2ldO1xuICAgIHZhciBwcm9wVmFsdWUgPSB1cGRhdGVQYXlsb2FkW2kgKyAxXTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZzsgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG5cbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpOyAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG5cbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgdHlwZSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7XG4gICAgICAgIGlzOiBwcm9wcy5pc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbiAgICAgIC8vIFRoaXMgcHJldmVudHM6XG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgIG5vZGUubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnNpemUpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGEgc2l6ZSBncmVhdGVyIHRoYW4gMSBjYXVzZXMgYSBzZWxlY3QgdG8gYmVoYXZlIGxpa2UgYG11bHRpcGxlPXRydWVgLCB3aGVyZVxuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB3aGVuIGEgc2VsZWN0IGluIFwic2luZ2xlIHNlbGVjdGlvbiBtb2RlXCIuXG4gICAgICAgICAgbm9kZS5zaXplID0gcHJvcHMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG5cbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHZhciBwcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBlcnJvciBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIGZhbHNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG59IC8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cblxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuXG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzKTtcbiAgdmFyIHByb3BLZXk7XG4gIHZhciBzdHlsZU5hbWU7XG4gIHZhciBzdHlsZVVwZGF0ZXMgPSBudWxsO1xuXG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcblxuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIHZhciBsYXN0UHJvcCA9IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cblxuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdvYmplY3QnICYmIG5leHRQcm9wICE9PSBudWxsICYmIG5leHRQcm9wLiQkdHlwZW9mID09PSBSRUFDVF9PUEFRVUVfSURfVFlQRSkge1xuICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIHVzZU9wYXF1ZVJlZmVyZW5jZSdzIG9wYXF1ZSBvYmplY3QsIHRoaXMgbWVhbnMgd2UgYXJlIGh5ZHJhdGluZy5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgY2FsbCB0aGUgb3BhcXVlIG9iamVjdCdzIHRvU3RyaW5nIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyBhIG5ldyBjbGllbnRcbiAgICAgIC8vIElEIHNvIGNsaWVudCBhbmQgc2VydmVyIElEcyBtYXRjaCBhbmQgdGhyb3dzIHRvIHJlcmVuZGVyLlxuICAgICAgbmV4dFByb3AudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAge1xuICAgICAgdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFByb3BzW1NUWUxFXSk7XG4gICAgfVxuXG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYuXG5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcztcblxuICB7XG4gICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nID0gcmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddID09PSB0cnVlO1xuICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgfSAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuXG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbX2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgYWxsb3dlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tfaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKCAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKCAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICggLy8gQ29udmluY2UgRmxvdyB3ZSd2ZSBjYWxjdWxhdGVkIGl0IChpdCdzIERFVi1vbmx5IGluIHRoaXMgbWV0aG9kLilcbiAgICB0eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWcgPT09ICdib29sZWFuJykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZWlyIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7XG5cbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIHx8IC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJIVE1MID0gZG9tRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBleHBlY3RlZEhUTUwgPSBub3JtYWxpemVIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcblxuICAgICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuXG4gICAgICAgIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRTdHlsZSAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzaG91bGRJZ25vcmVBdHRyaWJ1dGUocHJvcEtleSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykgJiYgIXNob3VsZFJlbW92ZUF0dHJpYnV0ZShwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICAgICAgdmFyIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuXG4gICAgICAgICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBudWxsICYmIHN0YW5kYXJkTmFtZSAhPT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAvLyBJZiBhbiBTVkcgcHJvcCBpcyBzdXBwbGllZCB3aXRoIGJhZCBjYXNpbmcsIGl0IHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBmcm9tIEhUTUwsIGJ1dCB3aWxsIHByb2R1Y2UgYSBtaXNtYXRjaFxuICAgICAgICAgICAgICAvLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBhbHJlYWR5IHdhcm4gYWJvdXQgYmFkIGNhc2luZyBlbHNld2hlcmUuXG4gICAgICAgICAgICAgIC8vIFNvIHdlJ2xsIHNraXAgdGhlIG1pc2xlYWRpbmcgZXh0cmEgbWlzbWF0Y2ggd2FybmluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IHRydWU7IC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cblxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlICYmICFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKGV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZSA+IDAgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIHRydWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAgdmFyIGlzRGlmZmVyZW50ID0gdGV4dE5vZGUubm9kZVZhbHVlICE9PSB0ZXh0O1xuICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59XG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKCkge307XG5cbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG5cbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJywgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcblxuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG5cbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIHRhZzogdGFnXG4gICAgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfSAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcblxuXG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcblxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG5cbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcblxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG5cbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcblxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcblxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuXG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknIHx8IHRhZyA9PT0gJ2ZyYW1lc2V0JztcblxuICAgICAgY2FzZSAnZnJhbWVzZXQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnZnJhbWUnO1xuXG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfSAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcblxuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG5cblxuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiQxID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGRUYWcgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnO1xuXG4gICAgaWYgKGRpZFdhcm4kMVt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm4kMVt3YXJuS2V5XSA9IHRydWU7XG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG5cbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9IFwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+LCA8dGhlYWQ+IG9yIDx0Zm9vdD4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuXG4gICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxO1xuXG57XG4gIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbn1cblxudmFyIFNVU1BFTlNFX1NUQVJUX0RBVEEgPSAnJCc7XG52YXIgU1VTUEVOU0VfRU5EX0RBVEEgPSAnLyQnO1xudmFyIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSA9ICckPyc7XG52YXIgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSA9ICckISc7XG52YXIgU1RZTEUkMSA9ICdzdHlsZSc7XG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250ZXh0KHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB2YXIgdHlwZTtcbiAgdmFyIG5hbWVzcGFjZTtcbiAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuXG4gIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAge1xuICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICBhbmNlc3RvckluZm86IGFuY2VzdG9ySW5mb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQocGFyZW50SG9zdENvbnRleHQsIHR5cGUsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB7XG4gICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgdmFyIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICBhbmNlc3RvckluZm86IGFuY2VzdG9ySW5mb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoY29udGFpbmVySW5mbykge1xuICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgdmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcblxuICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgcmV0dXJuIGFjdGl2ZUluc3RhbmNlO1xufVxuZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuXG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXBkYXRlKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG5cbiAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlID09PSAnb3B0aW9uJyB8fCB0eXBlID09PSAnbm9zY3JpcHQnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAhPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dEluc3RhbmNlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG5cbiAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICByZXR1cm4gdGV4dE5vZGU7XG59XG4vLyBpZiBhIGNvbXBvbmVudCBqdXN0IGltcG9ydHMgUmVhY3RET00gKGUuZy4gZm9yIGZpbmRET01Ob2RlKS5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIG1pZ2h0IG5vdCBoYXZlIHNldFRpbWVvdXQgb3IgY2xlYXJUaW1lb3V0LlxuXG52YXIgc2NoZWR1bGVUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIGNhbmNlbFRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIG5vVGltZW91dCA9IC0xOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjb21taXRNb3VudChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgLy8gZmlyZXMgaWYgdGhlcmUgaXMgYW4gYFVwZGF0ZWAgZWZmZWN0IHNjaGVkdWxlZCBkdXJpbmcgbW91bnRpbmcuXG4gIC8vIFRoaXMgaGFwcGVucyBpZiBgZmluYWxpemVJbml0aWFsQ2hpbGRyZW5gIHJldHVybnMgYHRydWVgICh3aGljaCBpdFxuICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgLy8gdGhlcmUgYXJlIGFsc28gb3RoZXIgY2FzZXMgd2hlbiB0aGlzIG1pZ2h0IGhhcHBlbiAoc3VjaCBhcyBwYXRjaGluZ1xuICAvLyB1cCB0ZXh0IGNvbnRlbnQgZHVyaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaCkuIFNvIHdlJ2xsIGNoZWNrIHRoaXMgYWdhaW4uXG4gIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0VXBkYXRlKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuXG4gIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCkge1xuICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyk7XG59XG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXI7XG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0gLy8gVGhpcyBjb250YWluZXIgbWlnaHQgYmUgdXNlZCBmb3IgYSBwb3J0YWwuXG4gIC8vIElmIHNvbWV0aGluZyBpbnNpZGUgYSBwb3J0YWwgaXMgY2xpY2tlZCwgdGhhdCBjbGljayBzaG91bGQgYnViYmxlXG4gIC8vIHRocm91Z2ggdGhlIFJlYWN0IHRyZWUuIEhvd2V2ZXIsIG9uIE1vYmlsZSBTYWZhcmkgdGhlIGNsaWNrIHdvdWxkXG4gIC8vIG5ldmVyIGJ1YmJsZSB0aHJvdWdoIHRoZSAqRE9NKiB0cmVlIHVubGVzcyBhbiBhbmNlc3RvciB3aXRoIG9uY2xpY2tcbiAgLy8gZXZlbnQgZXhpc3RzLiBTbyB3ZSB3b3VsZG4ndCBzZWUgaXQgYW5kIGRpc3BhdGNoIGl0LlxuICAvLyBUaGlzIGlzIHdoeSB3ZSBlbnN1cmUgdGhhdCBub24gUmVhY3Qgcm9vdCBjb250YWluZXJzIGhhdmUgaW5saW5lIG9uY2xpY2tcbiAgLy8gZGVmaW5lZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTkxOFxuXG5cbiAgdmFyIHJlYWN0Um9vdENvbnRhaW5lciA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gIGlmICgocmVhY3RSb290Q29udGFpbmVyID09PSBudWxsIHx8IHJlYWN0Um9vdENvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSAmJiBwYXJlbnROb2RlLm9uY2xpY2sgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudE5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBEb2VzIHRoaXMgd29yayBmb3IgYWxsIGVsZW1lbnQgdHlwZXM/IFdoYXQgYWJvdXQgTWF0aE1MPyBTaG91bGQgd2VcbiAgLy8gcGFzcyBob3N0IGNvbnRleHQgdG8gdGhpcyBtZXRob2Q/XG4gIGluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHZhciBzdHlsZSA9IGluc3RhbmNlLnN0eWxlO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGUuc2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJywgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cbmZ1bmN0aW9uIGhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlKSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSAnJztcbn1cbmZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGVQcm9wID0gcHJvcHNbU1RZTEUkMV07XG4gIHZhciBkaXNwbGF5ID0gc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgJiYgc3R5bGVQcm9wICE9PSBudWxsICYmIHN0eWxlUHJvcC5oYXNPd25Qcm9wZXJ0eSgnZGlzcGxheScpID8gc3R5bGVQcm9wLmRpc3BsYXkgOiBudWxsO1xuICBpbnN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZSgnZGlzcGxheScsIGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gdW5oaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gdGV4dDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSAnJztcbiAgfSBlbHNlIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB2YXIgYm9keSA9IGNvbnRhaW5lci5ib2R5O1xuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgYm9keS50ZXh0Q29udGVudCA9ICcnO1xuICAgIH1cbiAgfVxufSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjYW5IeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpIHtcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgZm9yICg7IG5vZGUgIT0gbnVsbDsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuXG4gICAgaWYgKG5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7IC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAvLyBnZXQgYXR0YWNoZWQuXG5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICB2YXIgcGFyZW50TmFtZXNwYWNlO1xuXG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cblxuICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSk7XG59XG5mdW5jdGlvbiBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZzsgLy8gU2tpcCBwYXN0IGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG5cbiAgdmFyIGRlcHRoID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuXG4gICAgICBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgfSAvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG5cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gUmV0dXJucyB0aGUgU3VzcGVuc2VJbnN0YW5jZSBpZiB0aGlzIG5vZGUgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuLy8gU3VzcGVuc2VJbnN0YW5jZS4gSS5lLiBpZiBpdHMgcHJldmlvdXMgc2libGluZyBpcyBhIENvbW1lbnQgd2l0aFxuLy8gU1VTUEVOU0VfeF9TVEFSVF9EQVRBLiBPdGhlcndpc2UsIG51bGwuXG5cbmZ1bmN0aW9uIGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UodGFyZ2V0SW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0YW5jZS5wcmV2aW91c1NpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRDb250YWluZXIoY29udGFpbmVyKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihjb250YWluZXIpO1xufVxuZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxuICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgOyBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSA7XG59XG52YXIgY2xpZW50SWQgPSAwO1xuZnVuY3Rpb24gbWFrZUNsaWVudElkSW5ERVYod2Fybk9uQWNjZXNzSW5ERVYpIHtcbiAgdmFyIGlkID0gJ3I6JyArIChjbGllbnRJZCsrKS50b1N0cmluZygzNik7XG4gIHJldHVybiB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm5PbkFjY2Vzc0luREVWKCk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9PUEFRVUVfSURfVFlQRTtcbn1cbmZ1bmN0aW9uIG1ha2VPcGFxdWVIeWRyYXRpbmdPYmplY3QoYXR0ZW1wdFRvUmVhZFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX09QQVFVRV9JRF9UWVBFLFxuICAgIHRvU3RyaW5nOiBhdHRlbXB0VG9SZWFkVmFsdWUsXG4gICAgdmFsdWVPZjogYXR0ZW1wdFRvUmVhZFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlUG9ydGFsTW91bnQocG9ydGFsSW5zdGFuY2UpIHtcbiAge1xuICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHBvcnRhbEluc3RhbmNlKTtcbiAgfVxufVxuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0RmliZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbFByb3BzS2V5ID0gJ19fcmVhY3RQcm9wcyQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkgPSAnX19yZWFjdENvbnRhaW5lciQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRzJCcgKyByYW5kb21LZXk7XG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5mdW5jdGlvbiBtYXJrQ29udGFpbmVyQXNSb290KGhvc3RSb290LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBob3N0Um9vdDtcbn1cbmZ1bmN0aW9uIHVubWFya0NvbnRhaW5lckFzUm9vdChub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBudWxsO1xufVxuZnVuY3Rpb24gaXNDb250YWluZXJNYXJrZWRBc1Jvb3Qobm9kZSkge1xuICByZXR1cm4gISFub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xufSAvLyBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgSG9zdENvbXBvbmVudCBvciBIb3N0VGV4dCBmaWJlciBhbmNlc3Rvci5cbi8vIElmIHRoZSB0YXJnZXQgbm9kZSBpcyBwYXJ0IG9mIGEgaHlkcmF0ZWQgb3Igbm90IHlldCByZW5kZXJlZCBzdWJ0cmVlLCB0aGVuXG4vLyB0aGlzIG1heSBhbHNvIHJldHVybiBhIFN1c3BlbnNlQ29tcG9uZW50IG9yIEhvc3RSb290IHRvIGluZGljYXRlIHRoYXQuXG4vLyBDb25jZXB0dWFsbHkgdGhlIEhvc3RSb290IGZpYmVyIGlzIGEgY2hpbGQgb2YgdGhlIENvbnRhaW5lciBub2RlLiBTbyBpZiB5b3Vcbi8vIHBhc3MgdGhlIENvbnRhaW5lciBub2RlIGFzIHRoZSB0YXJnZXROb2RlLCB5b3Ugd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHRoZVxuLy8gSG9zdFJvb3QgYmFjay4gVG8gZ2V0IHRvIHRoZSBIb3N0Um9vdCwgeW91IG5lZWQgdG8gcGFzcyBhIGNoaWxkIG9mIGl0LlxuLy8gVGhlIHNhbWUgdGhpbmcgYXBwbGllcyB0byBTdXNwZW5zZSBib3VuZGFyaWVzLlxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcblxuICBpZiAodGFyZ2V0SW5zdCkge1xuICAgIC8vIERvbid0IHJldHVybiBIb3N0Um9vdCBvciBTdXNwZW5zZUNvbXBvbmVudCBoZXJlLlxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9IC8vIElmIHRoZSBkaXJlY3QgZXZlbnQgdGFyZ2V0IGlzbid0IGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUsIHdlIG5lZWQgdG8gbG9va1xuICAvLyB0byBzZWUgaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUuXG5cblxuICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgIC8vIFdlJ2xsIGNoZWNrIGlmIHRoaXMgaXMgYSBjb250YWluZXIgcm9vdCB0aGF0IGNvdWxkIGluY2x1ZGVcbiAgICAvLyBSZWFjdCBub2RlcyBpbiB0aGUgZnV0dXJlLiBXZSBuZWVkIHRvIGNoZWNrIHRoaXMgZmlyc3QgYmVjYXVzZVxuICAgIC8vIGlmIHdlJ3JlIGEgY2hpbGQgb2YgYSBkZWh5ZHJhdGVkIGNvbnRhaW5lciwgd2UgbmVlZCB0byBmaXJzdFxuICAgIC8vIGZpbmQgdGhhdCBpbm5lciBjb250YWluZXIgYmVmb3JlIG1vdmluZyBvbiB0byBmaW5kaW5nIHRoZSBwYXJlbnRcbiAgICAvLyBpbnN0YW5jZS4gTm90ZSB0aGF0IHdlIGRvbid0IGNoZWNrIHRoaXMgZmllbGQgb24gIHRoZSB0YXJnZXROb2RlXG4gICAgLy8gaXRzZWxmIGJlY2F1c2UgdGhlIGZpYmVycyBhcmUgY29uY2VwdHVhbGx5IGJldHdlZW4gdGhlIGNvbnRhaW5lclxuICAgIC8vIG5vZGUgYW5kIHRoZSBmaXJzdCBjaGlsZC4gSXQgaXNuJ3Qgc3Vycm91bmRpbmcgdGhlIGNvbnRhaW5lciBub2RlLlxuICAgIC8vIElmIGl0J3Mgbm90IGEgY29udGFpbmVyLCB3ZSBjaGVjayBpZiBpdCdzIGFuIGluc3RhbmNlLlxuICAgIHRhcmdldEluc3QgPSBwYXJlbnROb2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldIHx8IHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICBpZiAodGFyZ2V0SW5zdCkge1xuICAgICAgLy8gU2luY2UgdGhpcyB3YXNuJ3QgdGhlIGRpcmVjdCB0YXJnZXQgb2YgdGhlIGV2ZW50LCB3ZSBtaWdodCBoYXZlXG4gICAgICAvLyBzdGVwcGVkIHBhc3QgZGVoeWRyYXRlZCBET00gbm9kZXMgdG8gZ2V0IGhlcmUuIEhvd2V2ZXIgdGhleSBjb3VsZFxuICAgICAgLy8gYWxzbyBoYXZlIGJlZW4gbm9uLVJlYWN0IG5vZGVzLiBXZSBuZWVkIHRvIGFuc3dlciB3aGljaCBvbmUuXG4gICAgICAvLyBJZiB3ZSB0aGUgaW5zdGFuY2UgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiB0aGVyZSBjYW4ndCBiZVxuICAgICAgLy8gYSBuZXN0ZWQgc3VzcGVuc2UgYm91bmRhcnkgd2l0aGluIGl0LiBTbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBmYXN0XG4gICAgICAvLyBiYWlsb3V0LiBNb3N0IG9mIHRoZSB0aW1lLCB3aGVuIHBlb3BsZSBhZGQgbm9uLVJlYWN0IGNoaWxkcmVuIHRvXG4gICAgICAvLyB0aGUgdHJlZSwgaXQgaXMgdXNpbmcgYSByZWYgdG8gYSBjaGlsZC1sZXNzIERPTSBub2RlLlxuICAgICAgLy8gTm9ybWFsbHkgd2UnZCBvbmx5IG5lZWQgdG8gY2hlY2sgb25lIG9mIHRoZSBmaWJlcnMgYmVjYXVzZSBpZiBpdFxuICAgICAgLy8gaGFzIGV2ZXIgZ29uZSBmcm9tIGhhdmluZyBjaGlsZHJlbiB0byBkZWxldGluZyB0aGVtIG9yIHZpY2UgdmVyc2FcbiAgICAgIC8vIGl0IHdvdWxkIGhhdmUgZGVsZXRlZCB0aGUgZGVoeWRyYXRlZCBib3VuZGFyeSBuZXN0ZWQgaW5zaWRlIGFscmVhZHkuXG4gICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgSG9zdFJvb3Qgc3RhcnRzIG91dCB3aXRoIGFuIGFsdGVybmF0ZSBpdCBtaWdodFxuICAgICAgLy8gaGF2ZSBvbmUgb24gdGhlIGFsdGVybmF0ZSBzbyB3ZSBuZWVkIHRvIGNoZWNrIGluIGNhc2UgdGhpcyB3YXMgYVxuICAgICAgLy8gcm9vdC5cbiAgICAgIHZhciBhbHRlcm5hdGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKHRhcmdldEluc3QuY2hpbGQgIT09IG51bGwgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBOZXh0IHdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGUgbm9kZSB0aGF0IHNraXBwZWQgcGFzdCBpc1xuICAgICAgICAvLyBuZXN0ZWQgd2l0aGluIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbmQgaWYgc28sIHdoaWNoIG9uZS5cbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuXG4gICAgICAgIHdoaWxlIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSBzdXNwZW5zZSBpbnN0YW5jZS4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmVuJ3RcbiAgICAgICAgICAvLyBoeWRyYXRlZCBpdCB5ZXQuIEV2ZW4gdGhvdWdoIHdlIGxlYXZlIHRoZSBjb21tZW50cyBpbiB0aGVcbiAgICAgICAgICAvLyBET00gYWZ0ZXIgaHlkcmF0aW5nLCBhbmQgdGhlcmUgYXJlIGJvdW5kYXJpZXMgaW4gdGhlIERPTVxuICAgICAgICAgIC8vIHRoYXQgY291bGQgYWxyZWFkeSBiZSBoeWRyYXRlZCwgd2Ugd291bGRuJ3QgaGF2ZSBmb3VuZCB0aGVtXG4gICAgICAgICAgLy8gdGhyb3VnaCB0aGlzIHBhc3Mgc2luY2UgaWYgdGhlIHRhcmdldCBpcyBoeWRyYXRlZCBpdCB3b3VsZFxuICAgICAgICAgIC8vIGhhdmUgaGFkIGFuIGludGVybmFsSW5zdGFuY2VLZXkgb24gaXQuXG4gICAgICAgICAgLy8gTGV0J3MgZ2V0IHRoZSBmaWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIFN1c3BlbnNlQ29tcG9uZW50XG4gICAgICAgICAgLy8gYXMgdGhlIGRlZXBlc3QgaW5zdGFuY2UuXG4gICAgICAgICAgdmFyIHRhcmdldFN1c3BlbnNlSW5zdCA9IHN1c3BlbnNlSW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICAgICAgICBpZiAodGFyZ2V0U3VzcGVuc2VJbnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0U3VzcGVuc2VJbnN0O1xuICAgICAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgZmluZCBhIEZpYmVyIG9uIHRoZSBjb21tZW50LCBpdCBtaWdodCBiZSBiZWNhdXNlXG4gICAgICAgICAgLy8gd2UgaGF2ZW4ndCBnb3R0ZW4gdG8gaHlkcmF0ZSBpdCB5ZXQuIFRoZXJlIG1pZ2h0IHN0aWxsIGJlIGFcbiAgICAgICAgICAvLyBwYXJlbnQgYm91bmRhcnkgdGhhdCBoYXNuJ3QgYWJvdmUgdGhpcyBvbmUgc28gd2UgbmVlZCB0byBmaW5kXG4gICAgICAgICAgLy8gdGhlIG91dGVyIG1vc3QgdGhhdCBpcyBrbm93bi5cblxuXG4gICAgICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7IC8vIElmIHdlIGRvbid0IGZpbmQgb25lLCB0aGVuIHRoYXQgc2hvdWxkIG1lYW4gdGhhdCB0aGUgcGFyZW50XG4gICAgICAgICAgLy8gaG9zdCBjb21wb25lbnQgYWxzbyBoYXNuJ3QgaHlkcmF0ZWQgeWV0LiBXZSBjYW4gcmV0dXJuIGl0XG4gICAgICAgICAgLy8gYmVsb3cgc2luY2UgaXQgd2lsbCBiYWlsIG91dCBvbiB0aGUgaXNNb3VudGVkIGNoZWNrIGxhdGVyLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV07XG5cbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0IHx8IGluc3QudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH0gLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcImdldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsUHJvcHNLZXldID0gcHJvcHM7XG59XG5mdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyU2V0KG5vZGUpIHtcbiAgdmFyIGVsZW1lbnRMaXN0ZW5lclNldCA9IG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcblxuICBpZiAoZWxlbWVudExpc3RlbmVyU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBuZXcgU2V0KCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudExpc3RlbmVyU2V0O1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSk7XG4gICAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG5cblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICB7XG4gICAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICAgIHJldHVybiBjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICBpZiAoIShjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgdHlwZSwgcGFyZW50Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7IC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gICAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAoIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAgIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAgIC8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cblxuICAgIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5Q29udGV4dE9iamVjdDsgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAgIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0eXBlLCBkaWRDaGFuZ2UpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcmV2aW91c0NvbnRleHQpO1xuICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0OyAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuXG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpOyAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cblxuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICB7XG4gICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gICAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICAgaWYgKCEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQmxvY2tpbmdSb290ID0gMTtcbnZhciBDb25jdXJyZW50Um9vdCA9IDI7XG5cbnZhciByZW5kZXJlcklEID0gbnVsbDtcbnZhciBpbmplY3RlZEhvb2sgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG52YXIgaXNEZXZUb29sc1ByZXNlbnQgPSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycpO1xuICAgIH0gLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9IC8vIERldlRvb2xzIGV4aXN0c1xuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIHByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBTY2hlZHVsZXJfcnVuV2l0aFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgIFNjaGVkdWxlcl9jYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfc2hvdWxkWWllbGQgPSBTY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQsXG4gICAgU2NoZWR1bGVyX3JlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsXG4gICAgU2NoZWR1bGVyX25vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICBTY2hlZHVsZXJfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSBTY2hlZHVsZXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsXG4gICAgU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX0xvd1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0xvd1ByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmYWtlQ2FsbGJhY2tOb2RlID0ge307IC8vIEV4Y2VwdCBmb3IgTm9Qcmlvcml0eSwgdGhlc2UgY29ycmVzcG9uZCB0byBTY2hlZHVsZXIgcHJpb3JpdGllcy4gV2UgdXNlXG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkkMSA9IDk5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPSA5ODtcbnZhciBOb3JtYWxQcmlvcml0eSQxID0gOTc7XG52YXIgTG93UHJpb3JpdHkkMSA9IDk2O1xudmFyIElkbGVQcmlvcml0eSQxID0gOTU7IC8vIE5vUHJpb3JpdHkgaXMgdGhlIGFic2VuY2Ugb2YgcHJpb3JpdHkuIEFsc28gUmVhY3Qtb25seS5cblxudmFyIE5vUHJpb3JpdHkkMSA9IDkwO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IC8vIEZhbGwgYmFjayBncmFjZWZ1bGx5IGlmIHdlJ3JlIHJ1bm5pbmcgYW4gb2xkZXIgdmVyc2lvbiBvZiBTY2hlZHVsZXIuXG5TY2hlZHVsZXJfcmVxdWVzdFBhaW50ICE9PSB1bmRlZmluZWQgPyBTY2hlZHVsZXJfcmVxdWVzdFBhaW50IDogZnVuY3Rpb24gKCkge307XG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IGZhbHNlO1xudmFyIGluaXRpYWxUaW1lTXMkMSA9IFNjaGVkdWxlcl9ub3ckMSgpOyAvLyBJZiB0aGUgaW5pdGlhbCB0aW1lc3RhbXAgaXMgcmVhc29uYWJseSBzbWFsbCwgdXNlIFNjaGVkdWxlcidzIGBub3dgIGRpcmVjdGx5LlxuLy8gVGhpcyB3aWxsIGJlIHRoZSBjYXNlIGZvciBtb2Rlcm4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBwZXJmb3JtYW5jZS5ub3dgLiBJblxuLy8gb2xkZXIgYnJvd3NlcnMsIFNjaGVkdWxlciBmYWxscyBiYWNrIHRvIGBEYXRlLm5vd2AsIHdoaWNoIHJldHVybnMgYSBVbml4XG4vLyB0aW1lc3RhbXAuIEluIHRoYXQgY2FzZSwgc3VidHJhY3QgdGhlIG1vZHVsZSBpbml0aWFsaXphdGlvbiB0aW1lIHRvIHNpbXVsYXRlXG4vLyB0aGUgYmVoYXZpb3Igb2YgcGVyZm9ybWFuY2Uubm93IGFuZCBrZWVwIG91ciB0aW1lcyBzbWFsbCBlbm91Z2ggdG8gZml0XG4vLyB3aXRoaW4gMzIgYml0cy5cbi8vIFRPRE86IENvbnNpZGVyIGxpZnRpbmcgdGhpcyBpbnRvIFNjaGVkdWxlci5cblxudmFyIG5vdyA9IGluaXRpYWxUaW1lTXMkMSA8IDEwMDAwID8gU2NoZWR1bGVyX25vdyQxIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gU2NoZWR1bGVyX25vdyQxKCkgLSBpbml0aWFsVGltZU1zJDE7XG59O1xuZnVuY3Rpb24gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHN3aXRjaCAoU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsKCkpIHtcbiAgICBjYXNlIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJbW1lZGlhdGVQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICByZXR1cm4gVXNlckJsb2NraW5nUHJpb3JpdHkkMjtcblxuICAgIGNhc2UgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vcm1hbFByaW9yaXR5JDE7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Mb3dQcmlvcml0eTpcbiAgICAgIHJldHVybiBMb3dQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVQcmlvcml0eSQxO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gcHJpb3JpdHkgbGV2ZWwuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKSB7XG4gIHN3aXRjaCAocmVhY3RQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eTtcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHkkMjpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHk7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5JDE6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5O1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Mb3dQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5JDE6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX0lkbGVQcmlvcml0eTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eSQxKHJlYWN0UHJpb3JpdHlMZXZlbCwgZm4pIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSByZWFjdFByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShyZWFjdFByaW9yaXR5TGV2ZWwpO1xuICByZXR1cm4gU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBmbik7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHJlYWN0UHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSByZWFjdFByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShyZWFjdFByaW9yaXR5TGV2ZWwpO1xuICByZXR1cm4gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgLy8gUHVzaCB0aGlzIGNhbGxiYWNrIGludG8gYW4gaW50ZXJuYWwgcXVldWUuIFdlJ2xsIGZsdXNoIHRoZXNlIGVpdGhlciBpblxuICAvLyB0aGUgbmV4dCB0aWNrLCBvciBlYXJsaWVyIGlmIHNvbWV0aGluZyBjYWxscyBgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZWAuXG4gIGlmIChzeW5jUXVldWUgPT09IG51bGwpIHtcbiAgICBzeW5jUXVldWUgPSBbY2FsbGJhY2tdOyAvLyBGbHVzaCB0aGUgcXVldWUgaW4gdGhlIG5leHQgdGljaywgYXQgdGhlIGVhcmxpZXN0LlxuXG4gICAgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWVJbXBsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG4gICAgLy8gd2UgYWxyZWFkeSBzY2hlZHVsZWQgb25lIHdoZW4gd2UgY3JlYXRlZCB0aGUgcXVldWUuXG4gICAgc3luY1F1ZXVlLnB1c2goY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGZha2VDYWxsYmFja05vZGU7XG59XG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgaWYgKGNhbGxiYWNrTm9kZSAhPT0gZmFrZUNhbGxiYWNrTm9kZSkge1xuICAgIFNjaGVkdWxlcl9jYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCkge1xuICBpZiAoaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgbm9kZSA9IGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlO1xuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sobm9kZSk7XG4gIH1cblxuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCgpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nU3luY1F1ZXVlICYmIHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY3kuXG4gICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IHRydWU7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9pc1N5bmMyID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9xdWV1ZSA9IHN5bmNRdWV1ZTtcbiAgICAgICAgcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAoOyBpIDwgX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfcXVldWVbaV07XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhfaXNTeW5jMik7XG4gICAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3luY1F1ZXVlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN5bmNRdWV1ZSA9IHN5bmNRdWV1ZS5zbGljZShpICsgMSk7XG4gICAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICAgIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSwgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxudmFyIE5vTW9kZSA9IDA7XG52YXIgU3RyaWN0TW9kZSA9IDE7IC8vIFRPRE86IFJlbW92ZSBCbG9ja2luZ01vZGUgYW5kIENvbmN1cnJlbnRNb2RlIGJ5IHJlYWRpbmcgZnJvbSB0aGUgcm9vdFxuLy8gdGFnIGluc3RlYWRcblxudmFyIEJsb2NraW5nTW9kZSA9IDI7XG52YXIgQ29uY3VycmVudE1vZGUgPSA0O1xudmFyIFByb2ZpbGVNb2RlID0gODtcbnZhciBEZWJ1Z1RyYWNpbmdNb2RlID0gMTY7XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIE5vVHJhbnNpdGlvbiA9IDA7XG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xufVxuXG52YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSBkbyBhbiBpbml0aWFsIHBhc3MgdG8gZ2F0aGVyIGNvbXBvbmVudCBuYW1lc1xuICAgIHZhciBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfSAvLyBGaW5hbGx5LCB3ZSBmbHVzaCBhbGwgdGhlIHdhcm5pbmdzXG4gICAgLy8gVU5TQUZFXyBvbmVzIGJlZm9yZSB0aGUgZGVwcmVjYXRlZCBvbmVzLCBzaW5jZSB0aGV5J2xsIGJlICdsb3VkZXInXG5cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBzb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCBcIiArICdyZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczIpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMzKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNCA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBcIiArICdjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczUgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpOyAvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxuXG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuXG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cblxuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgaWYgKGZpYmVyQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0RmliZXIgPSBmaWJlckFycmF5WzBdO1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGJhc2VQcm9wcyk7XG5cbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBuZXh0VmFsdWUpIHtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlckZpYmVyKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAvLyBObyBjaGFuZ2VcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAge1xuICAgICAgaWYgKChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgIT09IGNoYW5nZWRCaXRzKSB7XG4gICAgICAgIGVycm9yKCdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkQml0cyB8IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbiAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgbm9kZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAhaXNTdWJzZXRPZkxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAvLyBhbmNlc3RvciBwYXRoIGFscmVhZHkgaGFzIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJMYW5lcykge1xuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQgJiYgKGRlcGVuZGVuY3kub2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgLy8gTWF0Y2ghIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGlzIGZpYmVyLlxuICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKSk7XG4gICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7IC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cblxuICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcyk7IC8vIE1hcmsgdGhlIHVwZGF0ZWQgbGFuZXMgb24gdGhlIGxpc3QsIHRvby5cblxuICAgICAgICAgIGxpc3QubGFuZXMgPSBtZXJnZUxhbmVzKGxpc3QubGFuZXMsIHJlbmRlckxhbmVzKTsgLy8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuICAgICAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdC5cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgaWYgKGZpcnN0Q29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cbiAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgaWYgKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID09PSBjb250ZXh0KSA7IGVsc2UgaWYgKG9ic2VydmVkQml0cyA9PT0gZmFsc2UgfHwgb2JzZXJ2ZWRCaXRzID09PSAwKSA7IGVsc2Uge1xuICAgIHZhciByZXNvbHZlZE9ic2VydmVkQml0czsgLy8gQXZvaWQgZGVvcHRpbmcgb24gb2JzZXJ2YWJsZSBhcmd1bWVudHMgb3IgaGV0ZXJvZ2VuZW91cyB0eXBlcy5cblxuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZWRCaXRzICE9PSAnbnVtYmVyJyB8fCBvYnNlcnZlZEJpdHMgPT09IE1BWF9TSUdORURfMzFfQklUX0lOVCkge1xuICAgICAgLy8gT2JzZXJ2ZSBhbGwgdXBkYXRlcy5cbiAgICAgIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IGNvbnRleHQ7XG4gICAgICByZXNvbHZlZE9ic2VydmVkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHM7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG9ic2VydmVkQml0czogcmVzb2x2ZWRPYnNlcnZlZEJpdHMsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGlmICghKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICE9PSBudWxsKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5cblxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHRJdGVtLFxuICAgICAgICByZXNwb25kZXJzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA7XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbFxuICAgIH0sXG4gICAgZWZmZWN0czogbnVsbFxuICB9O1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xufVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBDbG9uZSB0aGUgdXBkYXRlIHF1ZXVlIGZyb20gY3VycmVudC4gVW5sZXNzIGl0J3MgYWxyZWFkeSBhIGNsb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBldmVudFRpbWU6IGV2ZW50VGltZSxcbiAgICBsYW5lOiBsYW5lLFxuICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgcGF5bG9hZDogbnVsbCxcbiAgICBjYWxsYmFjazogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuXG4gIHtcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBzaGFyZWRRdWV1ZSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcblxuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCBhcmUgdGhyb3duIGJ5IGEgY2hpbGQgZHVyaW5nIHRoZSByZW5kZXJcbiAgLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbiAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBDaGVjayBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIGNsb25lLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbiAgICAgIC8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuICAgICAgLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4gICAgICAvLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG4gICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuICAgICAgdmFyIG5ld0xhc3QgPSBudWxsO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHVwZGF0ZXMgYW5kIGNsb25lIHRoZW0uXG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlLmV2ZW50VGltZSxcbiAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICAgICAgbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyBBcHBlbmQgdGhlIGNhcHR1cmVkIHVwZGF0ZSB0aGUgZW5kIG9mIHRoZSBjbG9uZWQgbGlzdC5cblxuXG4gICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgICAgbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gYmFzZSB1cGRhdGVzLlxuICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG5cbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICB9XG5cbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBwcmV2U3RhdGUsIG5leHRQcm9wcywgaW5zdGFuY2UpIHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgICB9IC8vIFN0YXRlIG9iamVjdFxuXG5cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENhcHR1cmVVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICB9XG4gICAgLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgIGNhc2UgVXBkYXRlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAge1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXRlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICB9XG5cbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIElmIHNvLCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsOyAvLyBUaGUgcGVuZGluZyBxdWV1ZSBpcyBjaXJjdWxhci4gRGlzY29ubmVjdCB0aGUgcG9pbnRlciBiZXR3ZWVuIGZpcnN0XG4gICAgLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cblxuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDsgLy8gQXBwZW5kIHBlbmRpbmcgdXBkYXRlcyB0byBiYXNlIHF1ZXVlXG5cbiAgICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9XG5cbiAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlOyAvLyBJZiB0aGVyZSdzIGEgY3VycmVudCBxdWV1ZSwgYW5kIGl0J3MgZGlmZmVyZW50IGZyb20gdGhlIGJhc2UgcXVldWUsIHRoZW5cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuICAgIC8vIHF1ZXVlIGlzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IHdpdGggbm8gY3ljbGVzLCB3ZSBjYW4gYXBwZW5kIHRvIGJvdGhcbiAgICAvLyBsaXN0cyBhbmQgdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLlxuICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gICAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHZhciBjdXJyZW50TGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgIT09IGxhc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuXG5cbiAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVzIHRvIGNvbXB1dGUgdGhlIHJlc3VsdC5cbiAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4gICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cbiAgICB2YXIgbmV3TGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdGaXJzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciBuZXdMYXN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG4gICAgICB2YXIgdXBkYXRlRXZlbnRUaW1lID0gdXBkYXRlLmV2ZW50VGltZTtcblxuICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuXG5cbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgbmV3U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gU2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHdoYXRldmVyIGlzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuICAgIC8vIGJlZ2luIHBoYXNlIGJ5IHRoZSB0aW1lIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLCBzbyB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbiAgICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuICAgIC8vIHRoYXQgcmVnYXJkbGVzcy5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogXCIgKyBjYWxsYmFjayApO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuZnVuY3Rpb24gY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFF1ZXVlLCBpbnN0YW5jZSkge1xuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgdmFyIGVmZmVjdHMgPSBmaW5pc2hlZFF1ZXVlLmVmZmVjdHM7XG4gIGZpbmlzaGVkUXVldWUuZWZmZWN0cyA9IG51bGw7XG5cbiAgaWYgKGVmZmVjdHMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZWZmZWN0LmNhbGxiYWNrO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OyAvLyBSZWFjdC5Db21wb25lbnQgdXNlcyBhIHNoYXJlZCBmcm96ZW4gb2JqZWN0IGJ5IGRlZmF1bHQuXG4vLyBXZSdsbCB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXplIGxlZ2FjeSByZWZzLlxuXG52YXIgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjaztcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IF9hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSBSZXBsYWNlU3RhdGU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuXG4gIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgcHJvcHMpIHtcbiAgdmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIHtcbiAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiBjdG9yKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9IC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblxuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG5cblxuICBpZiAoaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSBlbXB0eVJlZnNPYmplY3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59IC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA/IHVucmVzb2x2ZWRPbGRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIHVucmVzb2x2ZWROZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dFVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSB1bnJlc29sdmVkTmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyA9PT0gdW5yZXNvbHZlZE5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG52YXIgZGlkV2FybkFib3V0TWFwcztcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nO1xudmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZztcblxudmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge307XG5cbntcbiAgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG5cbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgLy8gVE9ETzogQ2xlYW4gdGhpcyB1cCBvbmNlIHdlIHR1cm4gb24gdGhlIHN0cmluZyByZWYgd2FybmluZyBmb3JcbiAgICAgIC8vIGV2ZXJ5b25lLCBiZWNhdXNlIHRoZSBzdHJpY3QgbW9kZSBjYXNlIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG4gICAgICBpZiAoKHJldHVybkZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlIHx8IHdhcm5BYm91dFN0cmluZ1JlZnMpICYmIC8vIFdlIHdhcm4gaW4gUmVhY3RFbGVtZW50LmpzIGlmIG93bmVyIGFuZCBzZWxmIGFyZSBlcXVhbCBmb3Igc3RyaW5nIHJlZnNcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAvLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuICAgICAgIShlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9zZWxmICYmIGVsZW1lbnQuX293bmVyLnN0YXRlTm9kZSAhPT0gZWxlbWVudC5fc2VsZikpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdTdHJpbmcgcmVmcyBhcmUgYSBzb3VyY2Ugb2YgcG90ZW50aWFsIGJ1Z3MgYW5kIHNob3VsZCBiZSBhdm9pZGVkLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIG1peGVkUmVmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdDtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG5cbiAgICAgICAgaWYgKCEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIkZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgc3RyaW5nIHJlZnMuIFdlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5zdCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiBcIiArIG1peGVkUmVmICsgXCIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjsgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIHR5cGVvZiBjdXJyZW50LnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzO1xuXG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSBpbnN0LnJlZnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50Ll9vd25lcikge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIgKyBtaXhlZFJlZiArIFwiKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4yLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCkgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xuICB9XG59IC8vIFdlIGF2b2lkIGlubGluaW5nIHRoaXMgdG8gYXZvaWQgcG90ZW50aWFsIGRlb3B0cyBmcm9tIHVzaW5nIHRyeS9jYXRjaC5cbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cblxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcblxuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkpIHtcbiAgICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKTtcbiAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgIH0gLy8gSW5zZXJ0XG5cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBsYW5lcywga2V5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBsYW5lcywgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG5cblxuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCwgcmV0dXJuRmliZXIpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLCBrZXkpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAoISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9IC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEobmV3Q2hpbGRyZW4gIT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQudGFnKSB7XG4gICAgICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBCbG9jazpcblxuICAgICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZmFsbHRocm91Z2ggaGVyZSBpZiBlbmFibGVCbG9ja3NBUEkgaXMgbm90IG9uLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2V4aXN0aW5nMyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX2V4aXN0aW5nMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgX2V4aXN0aW5nMy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZXhpc3RpbmczO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9IC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGxhbmVzKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJyAmJiAhaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSBCbG9jazpcbiAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKSArIFwiKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblxuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59IC8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MoY2hpbGQsIGxhbmVzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcbnZhciBjb250ZXh0U3RhY2tDdXJzb3IkMSA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgaWYgKCEoYyAhPT0gTk9fQ09OVEVYVCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpOyAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cblxuICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbnZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0ID0gMDsgLy8gVGhlIFN1c3BlbnNlIENvbnRleHQgaXMgc3BsaXQgaW50byB0d28gcGFydHMuIFRoZSBsb3dlciBiaXRzIGlzXG4vLyBpbmhlcml0ZWQgZGVlcGx5IGRvd24gdGhlIHN1YnRyZWUuIFRoZSB1cHBlciBiaXRzIG9ubHkgYWZmZWN0XG4vLyB0aGlzIGltbWVkaWF0ZSBzdXNwZW5zZSBib3VuZGFyeSBhbmQgZ2V0cyByZXNldCBlYWNoIG5ld1xuLy8gYm91bmRhcnkgb3Igc3VzcGVuc2UgbGlzdC5cblxudmFyIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMTsgLy8gU3VidHJlZSBGbGFnczpcbi8vIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2Ygb3VyIHBhcmVudCBTdXNwZW5zZVxuLy8gYm91bmRhcmllcyBpcyBub3QgY3VycmVudGx5IHNob3dpbmcgdmlzaWJsZSBtYWluIGNvbnRlbnQuXG4vLyBFaXRoZXIgYmVjYXVzZSBpdCBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBvciBpcyBub3QgbW91bnRlZCBhdCBhbGwuXG4vLyBXZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGRlc2lyYWJsZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgYXRcbi8vIHRoZSBwYXJlbnQuIElmIG5vdCwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIHRyaWdnZXIgdW5kZXNpcmFibGUgYm91bmRhcmllc1xuLy8gYW5kL29yIHN1c3BlbmQgdGhlIGNvbW1pdCB0byBhdm9pZCBoaWRpbmcgdGhlIHBhcmVudCBjb250ZW50LlxuXG52YXIgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0ID0gMTsgLy8gU2hhbGxvdyBGbGFnczpcbi8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cblxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG52YXIgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtcbmZ1bmN0aW9uIGhhc1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBmbGFnKSB7XG4gIHJldHVybiAocGFyZW50Q29udGV4dCAmIGZsYWcpICE9PSAwO1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xufVxuZnVuY3Rpb24gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzaGFsbG93Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG59XG5mdW5jdGlvbiBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHN1YnRyZWVDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0IHwgc3VidHJlZUNvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoU3VzcGVuc2VDb250ZXh0KGZpYmVyLCBuZXdDb250ZXh0KSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3Q29udGV4dCwgZmliZXIpO1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENhcHR1cmVTdXNwZW5zZSh3b3JrSW5Qcm9ncmVzcywgaGFzSW52aXNpYmxlUGFyZW50KSB7XG4gIC8vIElmIGl0IHdhcyB0aGUgcHJpbWFyeSBjaGlsZHJlbiB0aGF0IGp1c3Qgc3VzcGVuZGVkLCBjYXB0dXJlIGFuZCByZW5kZXIgdGhlXG4gIC8vIGZhbGxiYWNrLiBPdGhlcndpc2UsIGRvbid0IGNhcHR1cmUgYW5kIGJ1YmJsZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gQSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFsd2F5cyBjYXB0dXJlcy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7IC8vIEluIG9yZGVyIHRvIGNhcHR1cmUsIHRoZSBTdXNwZW5zZSBjb21wb25lbnQgbXVzdCBoYXZlIGEgZmFsbGJhY2sgcHJvcC5cblxuICBpZiAocHJvcHMuZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBSZWd1bGFyIGJvdW5kYXJpZXMgYWx3YXlzIGNhcHR1cmUuXG5cblxuICBpZiAocHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG4gIC8vIHBhcmVudCBib3VuZGFyeSBpZiBpdCBpcyBjdXJyZW50bHkgaW52aXNpYmxlLlxuXG5cbiAgaWYgKGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB0aGUgcGFyZW50IGlzIG5vdCBhYmxlIHRvIGhhbmRsZSBpdCwgd2UgbXVzdCBoYW5kbGUgaXQuXG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgdmFyIG5vZGUgPSByb3c7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKGRlaHlkcmF0ZWQgPT09IG51bGwgfHwgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhkZWh5ZHJhdGVkKSB8fCBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhkZWh5ZHJhdGVkKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50ICYmIC8vIHJldmVhbE9yZGVyIHVuZGVmaW5lZCBjYW4ndCBiZSB0cnVzdGVkIGJlY2F1c2UgaXQgZG9uJ3RcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgaXQgc3VzcGVuZGVkIG9yIG5vdC5cbiAgICBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRpZFN1c3BlbmQgPSAobm9kZS5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICBpZiAoZGlkU3VzcGVuZCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvdykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgTm9GbGFncyQxID1cbi8qICAqL1xuMDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxudmFyIEhhc0VmZmVjdCA9XG4vKiAqL1xuMTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cbnZhciBMYXlvdXQgPVxuLyogICAgKi9cbjI7XG52YXIgUGFzc2l2ZSQxID1cbi8qICAgKi9cbjQ7XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICBjaGlsZFRvRGVsZXRlLmZsYWdzID0gRGVsZXRpb247IC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gIC8vIHJlY3JlYXRlZC5cblxuICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcblxuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3RleHQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuXG4gIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuXG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gIH1cblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkOyAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkVXBkYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlcik7XG5cbiAge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QgJiYgcGFyZW50LnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0eXBlID0gZmliZXIudHlwZTsgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gIC8vIHNpZGUgb2YgdGhlbS5cbiAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cblxuICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRJc0h5ZHJhdGluZygpIHtcbiAgcmV0dXJuIGlzSHlkcmF0aW5nO1xufVxuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xudmFyIHJlbmRlcmVyU2lnaWwkMTtcblxue1xuICAvLyBVc2VkIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgbXV0YWJsZSBzb3VyY2UuXG4gIHJlbmRlcmVyU2lnaWwkMSA9IHt9O1xufVxuXG5mdW5jdGlvbiBtYXJrU291cmNlQXNEaXJ0eShtdXRhYmxlU291cmNlKSB7XG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5wdXNoKG11dGFibGVTb3VyY2UpO1xufVxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSkge1xuICB7XG4gICAgcmV0dXJuIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKSB7XG4gIHtcbiAgICBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5ID0gdmVyc2lvbjtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5wdXNoKG11dGFibGVTb3VyY2UpO1xufVxuZnVuY3Rpb24gd2FybkFib3V0TXVsdGlwbGVSZW5kZXJlcnNERVYobXV0YWJsZVNvdXJjZSkge1xuICB7XG4gICAge1xuICAgICAgaWYgKG11dGFibGVTb3VyY2UuX2N1cnJlbnRQcmltYXJ5UmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbCQxO1xuICAgICAgfSBlbHNlIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsJDEpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgbXV0YWJsZSBzb3VyY2UuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBFYWdlciByZWFkcyB0aGUgdmVyc2lvbiBvZiBhIG11dGFibGUgc291cmNlIGFuZCBzdG9yZXMgaXQgb24gdGhlIHJvb3QuXG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcjtcblxue1xuICBkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyID0ge307XG4gIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuLy8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxudmFyIHJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG4vLyBjdXJyZW50IGhvb2sgbGlzdCBpcyB0aGUgbGlzdCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZmliZXIuIFRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBob29rIGxpc3QgaXMgYSBuZXcgbGlzdCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzXG4vLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcbi8vIGZpbmlzaGVkIGV2YWx1YXRpbmcgdGhpcyBjb21wb25lbnQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHdlIGtub3dcbi8vIHdoZXRoZXIgd2UgbmVlZCB0byBjbGVhciByZW5kZXIgcGhhc2UgdXBkYXRlcyBhZnRlciBhIHRocm93LlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuLy8gZ2V0cyByZXNldCBhZnRlciBlYWNoIGF0dGVtcHQuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIHNvbWUgd2F5IHRvIGNvbnNvbGlkYXRlIHRoaXMgd2l0aFxuLy8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7IC8vIEluIERFViwgdGhpcyBsaXN0IGVuc3VyZXMgdGhhdCBob29rcyBhcmUgY2FsbGVkIGluIHRoZSBzYW1lIG9yZGVyIGJldHdlZW4gcmVuZGVycy5cbi8vIFRoZSBsaXN0IHN0b3JlcyB0aGUgb3JkZXIgb2YgaG9va3MgdXNlZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIChtb3VudCkuXG4vLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG5cbnZhciBob29rVHlwZXNEZXYgPSBudWxsO1xudmFyIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIEluIERFViwgdGhpcyB0cmFja3Mgd2hldGhlciBjdXJyZW50bHkgcmVuZGVyaW5nIGNvbXBvbmVudCBuZWVkcyB0byBpZ25vcmVcbi8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cbi8vIFdoZW4gdHJ1ZSwgc3VjaCBIb29rcyB3aWxsIGFsd2F5cyBiZSBcInJlbW91bnRlZFwiLiBPbmx5IHVzZWQgZHVyaW5nIGhvdCByZWxvYWQuXG5cbnZhciBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiA9PT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2Kys7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSkge1xuICAgICAgICB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihob29rTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAge1xuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQgJiYgZGVwcyAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgLy8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cbiAgICAgIC8vIEl0J3MgdW5saWtlbHkgdGhlaXIgdHlwZSB3b3VsZCBjaGFuZ2UgYXMgdXN1YWxseSB5b3UgZGVmaW5lIHRoZW0gaW5saW5lLlxuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuICcgKyAnc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nLCBjdXJyZW50SG9va05hbWVJbkRldiwgdHlwZW9mIGRlcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnR5cGUpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YWJsZSA9ICcnO1xuICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldO1xuICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7IC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgICAvLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG5cbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuICAgICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJyArICcgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicgKyAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyArICclcycgKyAnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJywgY29tcG9uZW50TmFtZSwgdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIHtcbiAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHtcbiAgICAgIC8vIE9ubHkgdHJ1ZSB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGJlaW5nIGhvdCByZWxvYWRlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcsIG5leHRSZW5kZXJMYW5lcykge1xuICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5cbiAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuICAvLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbC5cbiAgLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcbiAgLy8gVXNpbmcgbWVtb2l6ZWRTdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbiAgLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuICAvLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cblxuICB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgfSBlbHNlIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBoYW5kbGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNvbXBvbmVudCBpcyB1cGRhdGluZyxcbiAgICAgIC8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cbiAgICAgIC8vIFdlIHdhbnQgdG8gbWF0Y2ggdGhlIHByb2R1Y3Rpb24gY29kZSBiZWhhdmlvciAod2hpY2ggd2lsbCB1c2UgSG9va3NEaXNwYXRjaGVyT25Nb3VudCksXG4gICAgICAvLyBidXQgd2l0aCB0aGUgZXh0cmEgREVWIHZhbGlkYXRpb24gdG8gZW5zdXJlIGhvb2tzIG9yZGVyaW5nIGhhc24ndCBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgIC8vIEtlZXAgcmVuZGVyaW5nIGluIGEgbG9vcCBmb3IgYXMgbG9uZyBhcyByZW5kZXIgcGhhc2UgdXBkYXRlcyBjb250aW51ZSB0b1xuICAgIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcblxuICAgICAgaWYgKCEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgcmVuZGVyIHRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG4gICAgICB9IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cblxuICAgICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgfVxuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9ICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuICAgICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgfSAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cblxuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gIH0gLy8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4gIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG5cbiAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID0gY3VycmVudEhvb2sgIT09IG51bGwgJiYgY3VycmVudEhvb2submV4dCAhPT0gbnVsbDtcbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIGlmICghIWRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgZWFybHkgcmV0dXJuIHN0YXRlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KFBhc3NpdmUgfCBVcGRhdGUpO1xuICBjdXJyZW50LmxhbmVzID0gcmVtb3ZlTGFuZXMoY3VycmVudC5sYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc0FmdGVyVGhyb3coKSB7XG4gIC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmN5LlxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuICAgIC8vIHBoYXNlLCB3aGljaCB3ZSBhcmUgbm93IGFib3J0aW5nLiBSZW1vdmUgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWVzIHNvXG4gICAgLy8gdGhleSBkbyBub3QgcGVyc2lzdCB0byB0aGUgbmV4dCByZW5kZXIuIERvIG5vdCByZW1vdmUgdXBkYXRlcyBmcm9tIGhvb2tzXG4gICAgLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cbiAgICAvL1xuICAgIC8vIE9ubHkgcmVzZXQgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUgaWYgaXQgaGFzIGEgY2xvbmUuIElmIGl0IGRvZXNcbiAgICAvLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG4gICAgLy8gc2NoZWR1bGVkIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgdmFyIGhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBob29rID0gaG9vay5uZXh0O1xuICAgIH1cblxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIHZhciBob29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbiAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4gIC8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbiAgLy8gdXNlIGFzIGEgYmFzZS4gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBiYXNlIGxpc3QsIHdlIG11c3Qgc3dpdGNoIHRvXG4gIC8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cbiAgdmFyIG5leHRDdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgfVxuXG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuICB9IGVsc2Uge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgfVxuXG4gIGlmIChuZXh0V29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vaztcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuICAgIGlmICghKG5leHRDdXJyZW50SG9vayAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgdmFyIG5ld0hvb2sgPSB7XG4gICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IG5ld0hvb2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXdIb29rO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEVmZmVjdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAoIShxdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnQgPSBjdXJyZW50SG9vazsgLy8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG4gIHZhciBiYXNlUXVldWUgPSBjdXJyZW50LmJhc2VRdWV1ZTsgLy8gVGhlIGxhc3QgcGVuZGluZyB1cGRhdGUgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIG5ldyB1cGRhdGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgLy8gV2UnbGwgYWRkIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG4gICAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTWVyZ2UgdGhlIHBlbmRpbmcgcXVldWUgYW5kIHRoZSBiYXNlIHF1ZXVlLlxuICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgdmFyIHBlbmRpbmdGaXJzdCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nRmlyc3Q7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSBpZiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcsIG9yIHNvbWUgZm9ybSBvZiB0aGF0LlxuICAgICAgICBlcnJvcignSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxuICAgIHZhciBmaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdTdGF0ZSA9IGN1cnJlbnQuYmFzZVN0YXRlO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdDtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBlYWdlclJlZHVjZXI6IHVwZGF0ZS5lYWdlclJlZHVjZXIsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBpZiAodXBkYXRlLmVhZ2VyUmVkdWNlciA9PT0gcmVkdWNlcikge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIHdhcyBwcm9jZXNzZWQgZWFnZXJseSwgYW5kIGl0cyByZWR1Y2VyIG1hdGNoZXMgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWR1Y2VyLCB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLlxuICAgICAgICAgIG5ld1N0YXRlID0gdXBkYXRlLmVhZ2VyU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IGZpcnN0KTtcblxuICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3Q7XG4gICAgfSAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAoIShxdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZztcbiAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyByZW5kZXIncy5cbiAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlOyAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAvLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuXG4gICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlYWRGcm9tVW5zdWJjcmliZWRNdXRhYmxlU291cmNlKHJvb3QsIHNvdXJjZSwgZ2V0U25hcHNob3QpIHtcbiAge1xuICAgIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKHNvdXJjZSk7XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTsgLy8gSXMgaXQgc2FmZSBmb3IgdGhpcyBjb21wb25lbnQgdG8gcmVhZCBmcm9tIHRoaXMgc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXI/XG5cbiAgdmFyIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBmYWxzZTsgLy8gQ2hlY2sgdGhlIHZlcnNpb24gZmlyc3QuXG4gIC8vIElmIHRoaXMgcmVuZGVyIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCB3aXRoIGEgc3BlY2lmaWMgdmVyc2lvbixcbiAgLy8gd2UgY2FuIHVzZSBpdCBhbG9uZSB0byBkZXRlcm1pbmUgaWYgd2UgY2FuIHNhZmVseSByZWFkIGZyb20gdGhlIHNvdXJjZS5cblxuICB2YXIgY3VycmVudFJlbmRlclZlcnNpb24gPSBnZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24oc291cmNlKTtcblxuICBpZiAoY3VycmVudFJlbmRlclZlcnNpb24gIT09IG51bGwpIHtcbiAgICAvLyBJdCdzIHNhZmUgdG8gcmVhZCBpZiB0aGUgc3RvcmUgaGFzbid0IGJlZW4gbXV0YXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgLy8gd2UgcmVhZCBzb21ldGhpbmcuXG4gICAgaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSA9IGN1cnJlbnRSZW5kZXJWZXJzaW9uID09PSB2ZXJzaW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gdmVyc2lvbiwgdGhlbiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIHJlYWQgZnJvbSB0aGVcbiAgICAvLyBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciBwYXNzLCBzbyB3ZSBuZWVkIHRvIGRvIGEgYml0IG1vcmUgd29yay5cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlzIGlmIHRoZXJlIGFyZSBhbnkgaG9va3MgdGhhdCBhbHJlYWR5XG4gICAgLy8gc3Vic2NyaWJlZCB0byB0aGUgc291cmNlLCBhbmQgaWYgc28sIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBwZW5kaW5nXG4gICAgLy8gbXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIHN5bmNocm9uaXplZCB5ZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBtdXRhdGlvbnMsIHRoZW4gYHJvb3QubXV0YWJsZVJlYWRMYW5lc2Agd2lsbCBiZVxuICAgIC8vIGVtcHR5LCBhbmQgd2Uga25vdyB3ZSBjYW4gc2FmZWx5IHJlYWQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSAqYXJlKiBwZW5kaW5nIG11dGF0aW9ucywgd2UgbWF5IHN0aWxsIGJlIGFibGUgdG8gc2FmZWx5IHJlYWRcbiAgICAvLyBpZiB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBsYW5lcyBhcmUgaW5jbHVzaXZlIG9mIHRoZSBwZW5kaW5nIG11dGF0aW9uXG4gICAgLy8gbGFuZXMsIHNpbmNlIHRoYXQgZ3VhcmFudGVlcyB0aGF0IHRoZSB2YWx1ZSB3ZSdyZSBhYm91dCB0byByZWFkIGZyb21cbiAgICAvLyB0aGUgc291cmNlIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdmFsdWVzIHRoYXQgd2UgcmVhZCBkdXJpbmcgdGhlIG1vc3RcbiAgICAvLyByZWNlbnQgbXV0YXRpb24uXG4gICAgaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSA9IGlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcblxuICAgIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgICAvLyBJZiBpdCdzIHNhZmUgdG8gcmVhZCBmcm9tIHRoaXMgc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIsXG4gICAgICAvLyBzdG9yZSB0aGUgdmVyc2lvbiBpbiBjYXNlIG90aGVyIGNvbXBvbmVudHMgcmVhZCBmcm9tIGl0LlxuICAgICAgLy8gQSBjaGFuZ2VkIHZlcnNpb24gbnVtYmVyIHdpbGwgbGV0IHRob3NlIGNvbXBvbmVudHMga25vdyB0byB0aHJvdyBhbmQgcmVzdGFydCB0aGUgcmVuZGVyLlxuICAgICAgc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSwgdmVyc2lvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UpIHtcbiAgICB2YXIgc25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHNuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uIGFzIHRoZSBzbmFwc2hvdCB2YWx1ZS4gJyArICdGdW5jdGlvbnMgbWF5IGNsb3NlIG92ZXIgbXV0YWJsZSB2YWx1ZXMgYW5kIGNhdXNlIHRlYXJpbmcuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNuYXBzaG90O1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgc3BlY2lhbCBjYXNlIG9mIGEgbXV0YWJsZSBzb3VyY2UgYmVpbmcgc2hhcmVkIGJldHdlZW4gcmVuZGVyZXJzLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgaWYgdGhlIHNvdXJjZSBpcyBtdXRhdGVkIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgcmVuZGVyZXIsXG4gICAgLy8gVGhlIHNlY29uZCByZW5kZXJlciBkb24ndCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcmVzZXQgdGhlIFdJUCB2ZXJzaW9uIGR1cmluZyB1bndpbmQsXG4gICAgLy8gKGJlY2F1c2UgdGhlIGhvb2sgb25seSBtYXJrcyBzb3VyY2VzIGFzIGRpcnR5IGlmIGl0J3Mgd3JpdHRlbiB0byB0aGVpciBXSVAgdmVyc2lvbikuXG4gICAgLy8gVGhhdCB3b3VsZCBjYXVzZSB0aGlzIHRlYXIgY2hlY2sgdG8gdGhyb3cgYWdhaW4gYW5kIGV2ZW50dWFsbHkgYmUgdmlzaWJsZSB0byB0aGUgdXNlci5cbiAgICAvLyBXZSBjYW4gYXZvaWQgdGhpcyBpbmZpbml0ZSBsb29wIGJ5IGV4cGxpY2l0bHkgbWFya2luZyB0aGUgc291cmNlIGFzIGRpcnR5LlxuICAgIC8vXG4gICAgLy8gVGhpcyBjYW4gbGVhZCB0byB0ZWFyaW5nIGluIHRoZSBmaXJzdCByZW5kZXJlciB3aGVuIGl0IHJlc3VtZXMsXG4gICAgLy8gYnV0IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8gYWJvdXQgdGhhdCAoc2hvcnQgb2YgdGhyb3dpbmcgaGVyZSBhbmQgcmVmdXNpbmcgdG8gY29udGludWUgdGhlIHJlbmRlcikuXG4gICAgbWFya1NvdXJjZUFzRGlydHkoc291cmNlKTtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IHJlYWQgZnJvbSBtdXRhYmxlIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHdpdGhvdXQgdGVhcmluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShob29rLCBzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICBpZiAoIShyb290ICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZXRWZXJzaW9uID0gc291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24oc291cmNlLl9zb3VyY2UpO1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG5cbiAgdmFyIF9kaXNwYXRjaGVyJHVzZVN0YXRlID0gZGlzcGF0Y2hlci51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlYWRGcm9tVW5zdWJjcmliZWRNdXRhYmxlU291cmNlKHJvb3QsIHNvdXJjZSwgZ2V0U25hcHNob3QpO1xuICB9KSxcbiAgICAgIGN1cnJlbnRTbmFwc2hvdCA9IF9kaXNwYXRjaGVyJHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVsxXTtcblxuICB2YXIgc25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7IC8vIEdyYWIgYSBoYW5kbGUgdG8gdGhlIHN0YXRlIGhvb2sgYXMgd2VsbC5cbiAgLy8gV2UgdXNlIGl0IHRvIGNsZWFyIHRoZSBwZW5kaW5nIHVwZGF0ZSBxdWV1ZSBpZiB3ZSBoYXZlIGEgbmV3IHNvdXJjZS5cblxuICB2YXIgc3RhdGVIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rO1xuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHJlZnMgPSBtZW1vaXplZFN0YXRlLnJlZnM7XG4gIHZhciBwcmV2R2V0U25hcHNob3QgPSByZWZzLmdldFNuYXBzaG90O1xuICB2YXIgcHJldlNvdXJjZSA9IG1lbW9pemVkU3RhdGUuc291cmNlO1xuICB2YXIgcHJldlN1YnNjcmliZSA9IG1lbW9pemVkU3RhdGUuc3Vic2NyaWJlO1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczogcmVmcyxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZVxuICB9OyAvLyBTeW5jIHRoZSB2YWx1ZXMgbmVlZGVkIGJ5IG91ciBzdWJzY3JpcHRpb24gaGFuZGxlciBhZnRlciBlYWNoIGNvbW1pdC5cblxuICBkaXNwYXRjaGVyLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmcy5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBOb3JtYWxseSB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yIGEgc3RhdGUgaG9vayBuZXZlciBjaGFuZ2VzLFxuICAgIC8vIGJ1dCB0aGlzIGhvb2sgcmVjcmVhdGVzIHRoZSBxdWV1ZSBpbiBjZXJ0YWluIGNhc2VzICB0byBhdm9pZCB1cGRhdGVzIGZyb20gc3RhbGUgc291cmNlcy5cbiAgICAvLyBoYW5kbGVDaGFuZ2UoKSBiZWxvdyBuZWVkcyB0byByZWZlcmVuY2UgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIHdpdGhvdXQgcmUtc3Vic2NyaWJpbmcsXG4gICAgLy8gc28gd2UgdXNlIGEgcmVmIHRvIGVuc3VyZSB0aGF0IGl0IGFsd2F5cyBoYXMgdGhlIGxhdGVzdCB2ZXJzaW9uLlxuXG4gICAgcmVmcy5zZXRTbmFwc2hvdCA9IHNldFNuYXBzaG90OyAvLyBDaGVjayBmb3IgYSBwb3NzaWJsZSBjaGFuZ2UgYmV0d2VlbiB3aGVuIHdlIGxhc3QgcmVuZGVyZWQgbm93LlxuXG4gICAgdmFyIG1heWJlTmV3VmVyc2lvbiA9IGdldFZlcnNpb24oc291cmNlLl9zb3VyY2UpO1xuXG4gICAgaWYgKCFvYmplY3RJcyh2ZXJzaW9uLCBtYXliZU5ld1ZlcnNpb24pKSB7XG4gICAgICB2YXIgbWF5YmVOZXdTbmFwc2hvdCA9IGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIG1heWJlTmV3U25hcHNob3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0SXMoc25hcHNob3QsIG1heWJlTmV3U25hcHNob3QpKSB7XG4gICAgICAgIHNldFNuYXBzaG90KG1heWJlTmV3U25hcHNob3QpO1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgICAgbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCBsYW5lKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNvdXJjZSBtdXRhdGVkIGJldHdlZW4gcmVuZGVyIGFuZCBub3csXG4gICAgICAvLyB0aGVyZSBtYXkgYmUgc3RhdGUgdXBkYXRlcyBhbHJlYWR5IHNjaGVkdWxlZCBmcm9tIHRoZSBvbGQgc291cmNlLlxuICAgICAgLy8gRW50YW5nbGUgdGhlIHVwZGF0ZXMgc28gdGhhdCB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC5cblxuXG4gICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCByb290Lm11dGFibGVSZWFkTGFuZXMpO1xuICAgIH1cbiAgfSwgW2dldFNuYXBzaG90LCBzb3VyY2UsIHN1YnNjcmliZV0pOyAvLyBJZiB3ZSBnb3QgYSBuZXcgc291cmNlIG9yIHN1YnNjcmliZSBmdW5jdGlvbiwgcmUtc3Vic2NyaWJlIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSByZWZzLmdldFNuYXBzaG90O1xuICAgICAgdmFyIGxhdGVzdFNldFNuYXBzaG90ID0gcmVmcy5zZXRTbmFwc2hvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGF0ZXN0U2V0U25hcHNob3QobGF0ZXN0R2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpKTsgLy8gUmVjb3JkIGEgcGVuZGluZyBtdXRhYmxlIHNvdXJjZSB1cGRhdGUgd2l0aCB0aGUgc2FtZSBleHBpcmF0aW9uIHRpbWUuXG5cbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBBIHNlbGVjdG9yIG1pZ2h0IHRocm93IGFmdGVyIGEgc291cmNlIG11dGF0aW9uLlxuICAgICAgICAvLyBlLmcuIGl0IG1pZ2h0IHRyeSB0byByZWFkIGZyb20gYSBwYXJ0IG9mIHRoZSBzdG9yZSB0aGF0IG5vIGxvbmdlciBleGlzdHMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgc3RpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHdpdGggUmVhY3QuXG4gICAgICAgIC8vIFdvcnN0IGNhc2UgdGhlIHNlbGVjdG9yIHdpbGwgdGhyb3cgYWdhaW4gYW5kIHRoZW4gYW4gZXJyb3IgYm91bmRhcnkgd2lsbCBoYW5kbGUgaXQuXG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShzb3VyY2UuX3NvdXJjZSwgaGFuZGxlQ2hhbmdlKTtcblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHN1YnNjcmliZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtzb3VyY2UsIHN1YnNjcmliZV0pOyAvLyBJZiBhbnkgb2YgdGhlIGlucHV0cyB0byB1c2VNdXRhYmxlU291cmNlIGNoYW5nZSwgcmVhZGluZyBpcyBwb3RlbnRpYWxseSB1bnNhZmUuXG4gIC8vXG4gIC8vIElmIGVpdGhlciB0aGUgc291cmNlIG9yIHRoZSBzdWJzY3JpcHRpb24gaGF2ZSBjaGFuZ2VkIHdlIGNhbid0IGNhbid0IHRydXN0IHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vIE1heWJlIHRoZSBzb3VyY2UgY2hhbmdlZCBpbiBhIHdheSB0aGF0IHRoZSBvbGQgc3Vic2NyaXB0aW9uIGlnbm9yZWQgYnV0IHRoZSBuZXcgb25lIGRlcGVuZHMgb24uXG4gIC8vXG4gIC8vIElmIHRoZSBnZXRTbmFwc2hvdCBmdW5jdGlvbiBjaGFuZ2VkLCB3ZSBhbHNvIHNob3VsZG4ndCByZWx5IG9uIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgdW5kZXJseWluZyBzb3VyY2Ugd2FzIG11dGF0ZWQgYmV0d2VlbiB0aGUgd2hlbiB0aGUgbGFzdCBcImNoYW5nZVwiIGV2ZW50IGZpcmVkLFxuICAvLyBhbmQgd2hlbiB0aGUgY3VycmVudCByZW5kZXIgKHdpdGggdGhlIG5ldyBnZXRTbmFwc2hvdCBmdW5jdGlvbikgaXMgcHJvY2Vzc2VkLlxuICAvL1xuICAvLyBJbiBib3RoIGNhc2VzLCB3ZSBuZWVkIHRvIHRocm93IGF3YXkgcGVuZGluZyB1cGRhdGVzIChzaW5jZSB0aGV5IGFyZSBubyBsb25nZXIgcmVsZXZhbnQpXG4gIC8vIGFuZCB0cmVhdCByZWFkaW5nIGZyb20gdGhlIHNvdXJjZSBhcyB3ZSBkbyBpbiB0aGUgbW91bnQgY2FzZS5cblxuICBpZiAoIW9iamVjdElzKHByZXZHZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHx8ICFvYmplY3RJcyhwcmV2U291cmNlLCBzb3VyY2UpIHx8ICFvYmplY3RJcyhwcmV2U3Vic2NyaWJlLCBzdWJzY3JpYmUpKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IHF1ZXVlIGFuZCBzZXRTdGF0ZSBtZXRob2QsXG4gICAgLy8gU28gaWYgdGhlcmUgYXJlIGludGVybGVhdmVkIHVwZGF0ZXMsIHRoZXkgZ2V0IHB1c2hlZCB0byB0aGUgb2xkZXIgcXVldWUuXG4gICAgLy8gV2hlbiB0aGlzIGJlY29tZXMgY3VycmVudCwgdGhlIHByZXZpb3VzIHF1ZXVlIGFuZCBkaXNwYXRjaCBtZXRob2Qgd2lsbCBiZSBkaXNjYXJkZWQsXG4gICAgLy8gaW5jbHVkaW5nIGFueSBpbnRlcmxlYXZpbmcgdXBkYXRlcyB0aGF0IG9jY3VyLlxuICAgIHZhciBuZXdRdWV1ZSA9IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IHNuYXBzaG90XG4gICAgfTtcbiAgICBuZXdRdWV1ZS5kaXNwYXRjaCA9IHNldFNuYXBzaG90ID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBuZXdRdWV1ZSk7XG4gICAgc3RhdGVIb29rLnF1ZXVlID0gbmV3UXVldWU7XG4gICAgc3RhdGVIb29rLmJhc2VRdWV1ZSA9IG51bGw7XG4gICAgc25hcHNob3QgPSByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgICBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vay5iYXNlU3RhdGUgPSBzbmFwc2hvdDtcbiAgfVxuXG4gIHJldHVybiBzbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICByZWZzOiB7XG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsXG4gICAgICBzZXRTbmFwc2hvdDogbnVsbFxuICAgIH0sXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTtcbiAgcmV0dXJuIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgZGVzdHJveSwgZGVwcykge1xuICB2YXIgZWZmZWN0ID0ge1xuICAgIHRhZzogdGFnLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgZGVwczogZGVwcyxcbiAgICAvLyBDaXJjdWxhclxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIGxhc3RFZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICAgIGVmZmVjdC5uZXh0ID0gZmlyc3RFZmZlY3Q7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZik7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgdW5kZWZpbmVkLCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBkZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RWZmZWN0ID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICBkZXN0cm95ID0gcHJldkVmZmVjdC5kZXN0cm95O1xuXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlIHwgUGFzc2l2ZSwgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG5cbiAgICB2YXIgX2luc3QgPSBjcmVhdGUoKTtcblxuICAgIHJlZkNhbGxiYWNrKF9pbnN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVmT2JqZWN0ID0gcmVmO1xuXG4gICAge1xuICAgICAgaWYgKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcgKyAncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgJ2FuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykgKyAnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaW5zdDIgPSBjcmVhdGUoKTtcblxuICAgIHJlZk9iamVjdC5jdXJyZW50ID0gX2luc3QyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZPYmplY3QuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikgey8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxudmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cbmZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF9tb3VudFN0YXRlID0gbW91bnRTdGF0ZSh2YWx1ZSksXG4gICAgICBwcmV2VmFsdWUgPSBfbW91bnRTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX21vdW50U3RhdGVbMV07XG5cbiAgbW91bnRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF91cGRhdGVTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX3VwZGF0ZVN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcHJldlZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF9yZXJlbmRlclN0YXRlID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgcHJldlZhbHVlID0gX3JlcmVuZGVyU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcHJldlZhbHVlO1xufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2V0UGVuZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO1xuXG4gIHtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsIDwgVXNlckJsb2NraW5nUHJpb3JpdHkkMiA/IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgIH0pO1xuICAgIHJ1bldpdGhQcmlvcml0eSQxKHByaW9yaXR5TGV2ZWwgPiBOb3JtYWxQcmlvcml0eSQxID8gTm9ybWFsUHJpb3JpdHkkMSA6IHByaW9yaXR5TGV2ZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgX21vdW50U3RhdGUyID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZTJbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGUyWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgY2FuIGJlIHN0b3JlZCBvbiBhIHJlZiwgc2luY2UgYHNldFBlbmRpbmdgXG4gIC8vIG5ldmVyIGNoYW5nZXMuXG5cblxuICB2YXIgc3RhcnQgPSBzdGFydFRyYW5zaXRpb24uYmluZChudWxsLCBzZXRQZW5kaW5nKTtcbiAgbW91bnRSZWYoc3RhcnQpO1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZTIgPSByZXJlbmRlclN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfcmVyZW5kZXJTdGF0ZTJbMF07XG5cbiAgdmFyIHN0YXJ0UmVmID0gdXBkYXRlUmVmKCk7XG4gIHZhciBzdGFydCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG4gIHJldHVybiBbc3RhcnQsIGlzUGVuZGluZ107XG59XG5cbnZhciBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKSB7XG4gIHtcbiAgICByZXR1cm4gaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFRPRE86IFNob3VsZCB3YXJuIGluIGVmZmVjdHMgYW5kIGNhbGxiYWNrcywgdG9vXG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcblxuICAgIGlmIChnZXRJc1JlbmRlcmluZygpICYmICFkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyW25hbWVdKSB7XG4gICAgICBlcnJvcignVGhlIG9iamVjdCBwYXNzZWQgYmFjayBmcm9tIHVzZU9wYXF1ZUlkZW50aWZpZXIgaXMgbWVhbnQgdG8gYmUgJyArICdwYXNzZWQgdGhyb3VnaCB0byBhdHRyaWJ1dGVzIG9ubHkuIERvIG5vdCByZWFkIHRoZSAnICsgJ3ZhbHVlIGRpcmVjdGx5LicpO1xuXG4gICAgICBkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgbWFrZUlkID0gIG1ha2VDbGllbnRJZEluREVWLmJpbmQobnVsbCwgd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSkpIDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciBkaWRVcGdyYWRlID0gZmFsc2U7XG4gICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcblxuICAgIHZhciByZWFkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRpZFVwZ3JhZGUpIHtcbiAgICAgICAgLy8gT25seSB1cGdyYWRlIG9uY2UuIFRoaXMgd29ya3MgZXZlbiBpbnNpZGUgdGhlIHJlbmRlciBwaGFzZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSB1cGRhdGUgaXMgYWRkZWQgdG8gYSBzaGFyZWQgcXVldWUsIHdoaWNoIG91dGxhc3RzIHRoZVxuICAgICAgICAvLyBpbi1wcm9ncmVzcyByZW5kZXIuXG4gICAgICAgIGRpZFVwZ3JhZGUgPSB0cnVlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gdHJ1ZTtcbiAgICAgICAgICBzZXRJZChtYWtlSWQoKSk7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICAgICAgICAgIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVihmaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIG9iamVjdCBwYXNzZWQgYmFjayBmcm9tIHVzZU9wYXF1ZUlkZW50aWZpZXIgaXMgbWVhbnQgdG8gYmUgcGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgdmFsdWUgZGlyZWN0bHkuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaWQgPSBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KHJlYWRWYWx1ZSk7XG4gICAgdmFyIHNldElkID0gbW91bnRTdGF0ZShpZClbMV07XG5cbiAgICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBVcGRhdGUgfCBQYXNzaXZlO1xuICAgICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgfSwgdW5kZWZpbmVkLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9pZCA9IG1ha2VJZCgpO1xuXG4gICAgbW91bnRTdGF0ZShfaWQpO1xuICAgIHJldHVybiBfaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIGlkID0gdXBkYXRlU3RhdGUoKVswXTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHJlcmVuZGVyU3RhdGUoKVswXTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBlYWdlclJlZHVjZXI6IG51bGwsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuICAgICAgLy8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbiAgICAgIC8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4gICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbiAgICAgIHZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtcblxuICAgICAgaWYgKGxhc3RSZW5kZXJlZFJlZHVjZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgZWFnZXJTdGF0ZSA9IGxhc3RSZW5kZXJlZFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pOyAvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuICAgICAgICAgIC8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4gICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuICAgICAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cblxuICAgICAgICAgIHVwZGF0ZS5lYWdlclJlZHVjZXIgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoZmliZXIpO1xuICAgICAgICB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdVcGRhdGVzSW5EZXYoZmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG52YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTXV0YWJsZVNvdXJjZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VPcGFxdWVJZGVudGlmaWVyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuXG57XG4gIHZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICB9O1xuXG4gIHZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbn1cblxudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBjb21taXRUaW1lID0gMDtcbnZhciBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDEoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMSgpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDEoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gIC8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbiAgLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4gIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG4gIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcztcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcztcbnZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xudmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyO1xudmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO1xuXG57XG4gIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzID0ge307XG4gIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cbiAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4gIC8vIHdhbnQgdG8gcmVjb25jaWxlIHdpdGhvdXQgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZXhpc3Rpbmcgc2V0LiBUaGlzIGhhcyB0aGVcbiAgLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4gIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4gIC8vXG4gIC8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4gIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbiAgLy8gcGFzc2luZyBudWxsLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIEluIHRoZSBzZWNvbmQgcGFzcywgd2UgbW91bnQgdGhlIG5ldyBjaGlsZHJlbi4gVGhlIHRyaWNrIGhlcmUgaXMgdGhhdCB3ZVxuICAvLyBwYXNzIG51bGwgaW4gcGxhY2Ugb2Ygd2hlcmUgd2UgdXN1YWxseSBwYXNzIHRoZSBjdXJyZW50IGNoaWxkIHNldC4gVGhpcyBoYXNcbiAgLy8gdGhlIGVmZmVjdCBvZiByZW1vdW50aW5nIGFsbCBjaGlsZHJlbiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlaXJcbiAgLy8gaWRlbnRpdGllcyBtYXRjaC5cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXIsIG5leHRQcm9wcywgcmVmLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuXG4gICAgaWYgKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkgJiYgQ29tcG9uZW50LmNvbXBhcmUgPT09IG51bGwgJiYgLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuICAgIENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbiAgICAgIC8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4gICAgICAvLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU2ltcGxlTWVtb0NvbXBvbmVudDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlZFR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlc29sdmVkVHlwZSwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKHR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoQ29tcG9uZW50LnR5cGUsIG51bGwsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLm1vZGUsIHJlbmRlckxhbmVzKTtcbiAgICBjaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgY2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICB7XG4gICAgdmFyIF90eXBlID0gQ29tcG9uZW50LnR5cGU7XG4gICAgdmFyIF9pbm5lclByb3BUeXBlcyA9IF90eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChfaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAvLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuICAgICAgY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoX3R5cGUpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhpcyBpcyBhbHdheXMgZXhhY3RseSBvbmUgY2hpbGRcblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUodXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgaW5uZXIgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgb3V0ZXJNZW1vVHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuXG4gICAgICBpZiAob3V0ZXJNZW1vVHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgIC8vIFdlIHdhcm4gd2hlbiB5b3UgZGVmaW5lIHByb3BUeXBlcyBvbiBsYXp5KClcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBza2lwIG92ZXIgaXQgdG8gZmluZCBtZW1vKCkgb3V0ZXIgd3JhcHBlci5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgZm9yIG1lbW8gYXJlIHZhbGlkYXRlZCBsYXRlci5cbiAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBvdXRlck1lbW9UeXBlO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBpbml0KHBheWxvYWQpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IG51bGw7XG4gICAgICAgIH0gLy8gSW5uZXIgcHJvcFR5cGVzIHdpbGwgYmUgdmFsaWRhdGVkIGluIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcGF0aC5cblxuXG4gICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IG91dGVyTWVtb1R5cGUgJiYgb3V0ZXJNZW1vVHlwZS5wcm9wVHlwZXM7XG5cbiAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgKFNpbXBsZU1lbW9Db21wb25lbnQgaGFzIG5vIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUob3V0ZXJNZW1vVHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJiAoIC8vIFByZXZlbnQgYmFpbG91dCBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZC5cbiAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lcykpIHtcbiAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuICAgICAgICAvLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW1sYXRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuICAgICAgICAvLyB3ZSdyZSBiYWlsaW5nIG91dCBlYXJseSAqd2l0aG91dCogZXZhbHVhdGluZyB0aGUgY29tcG9uZW50LCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGFjY291bnQgZm9yIGl0IGhlcmUsIHRvby4gUmVzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGZpYmVyLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBhIE1lbW9Db21wb25lbnQgZmliZXIgZG9lcyBub3QgaGF2ZSBob29rcyBvciBhbiB1cGRhdGUgcXVldWU7XG4gICAgICAgIC8vIHJhdGhlciwgaXQgd3JhcHMgYXJvdW5kIGFuIGlubmVyIGNvbXBvbmVudCwgd2hpY2ggbWF5IG9yIG1heSBub3RcbiAgICAgICAgLy8gY29udGFpbnMgaG9va3MuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhlIHJlc2V0IGF0IGluIGJlZ2luV29yayBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuXG4gIGlmIChuZXh0UHJvcHMubW9kZSA9PT0gJ2hpZGRlbicgfHwgbmV4dFByb3BzLm1vZGUgPT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgd2Ugc2hvdWxkIGRvIGluIEJsb2NraW5nIG1vZGUuXG4gICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2QmFzZUxhbmVzID0gcHJldlN0YXRlLmJhc2VMYW5lcztcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG4gICAgICB7XG4gICAgICAgIG1hcmtTcGF3bmVkV29yayhPZmZzY3JlZW5MYW5lKTtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGU7IC8vIFdlJ3JlIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgd2UgbmVlZCB0byBwdXNoIHRoaXMgdG8gdGhlIHN0YWNrIGFueXdheVxuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgbmV4dEJhc2VMYW5lcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gX25leHRTdGF0ZTI7IC8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cblxuICAgICAgdmFyIHN1YnRyZWVSZW5kZXJMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgOiByZW5kZXJMYW5lcztcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9zdWJ0cmVlUmVuZGVyTGFuZXM7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlJ3JlIG5vdCBoaWRkZW4gYW55bW9yZSwgcmVzZXQgdGhlIHN0YXRlXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgfVxuXG4gICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBfc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufSAvLyBOb3RlOiBUaGVzZSBoYXBwZW4gdG8gaGF2ZSBpZGVudGljYWwgYmVnaW4gcGhhc2VzLCBmb3Igbm93LiBXZSBzaG91bGRuJ3QgaG9sZFxuLy8gb3Vyc2VsdmVzIHRvIHRoaXMgY29uc3RyYWludCwgdGhvdWdoLiBJZiB0aGUgYmVoYXZpb3IgZGl2ZXJnZXMsIHdlIHNob3VsZFxuLy8gZm9yayB0aGUgZnVuY3Rpb24uXG5cblxudmFyIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudDtcblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7IC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG4gICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiByZWYgIT09IG51bGwgfHwgY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBzaG91bGRVcGRhdGU7XG5cbiAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgY2xhc3MgY29tcG9uZW50IHdpdGhvdXQgYW4gaW5zdGFuY2Ugb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkXG4gICAgICAvLyBpbnNpZGUgYSBub24tY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG9cbiAgICAgIC8vIHRyZWF0IGl0IGxpa2UgYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICB9IC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuXG5cbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIHZhciBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBkaWRDYXB0dXJlRXJyb3IgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFJlcmVuZGVyXG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgaWYgKGRpZENhcHR1cmVFcnJvciAmJiB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzIG5vdCBkZWZpbmVkLFxuICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cbiAgICAvLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAge1xuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblxuICBpZiAoIShjdXJyZW50ICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIklmIHRoZSByb290IGRvZXMgbm90IGhhdmUgYW4gdXBkYXRlUXVldWUsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYmFpbGVkIG91dC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmVsZW1lbnQgOiBudWxsO1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0U3RhdGUuZWxlbWVudDtcblxuICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290Lmh5ZHJhdGUgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG4gICAge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7XG5cbiAgICAgIGlmIChtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhW2ldO1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpICsgMV07XG4gICAgICAgICAgc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UsIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICB2YXIgbm9kZSA9IGNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgIC8vIHJvb3QuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF6eUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcbiAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQ7XG5cbiAgc3dpdGNoIChyZXNvbHZlZFRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgcmVzb2x2ZWRQcm9wcywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlTWVtb0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLCByZXNvbHZlZFByb3BzKSwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICAgIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBoaW50ID0gJyc7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgIGhpbnQgPSAnIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/JztcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZW50aW9uIEZvcndhcmRSZWYgb3IgTWVtb0NvbXBvbmVudFxuICAvLyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhblxuICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG5cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5jb21wbGV0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9IC8vIFByb21vdGUgdGhlIGZpYmVyIHRvIGEgY2xhc3MgYW5kIHRyeSByZW5kZXJpbmcgYWdhaW4uXG5cblxuICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyBhIGZvcmsgb2YgYHVwZGF0ZUNsYXNzQ29tcG9uZW50YFxuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzKTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIHZhbHVlO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICB7XG4gICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDsgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHZhbHVlLnN0YXRlICE9PSBudWxsICYmIHZhbHVlLnN0YXRlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zdGF0ZSA6IG51bGw7XG4gICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG5cbiAgICB7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckxhbmVzKTtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cblxuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG5cbiAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBTVVNQRU5ERURfTUFSS0VSID0ge1xuICBkZWh5ZHJhdGVkOiBudWxsLFxuICByZXRyeUxhbmU6IE5vTGFuZVxufTtcblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiByZW5kZXJMYW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGFja1xuICAgICAgLy8gaXMgdHJ1ZS4gTW9yZSBwcmVjaXNlIG5hbWUgbWlnaHQgYmUgXCJGb3JjZVJlbWFpblN1c3BlbnNlRmFsbGJhY2tcIi5cbiAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBmYWN0b3Jpbmcgc21lbGwuIENhbid0IHJlbWFpbiBvbiBhIGZhbGxiYWNrIGlmIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5cblxuICByZXR1cm4gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogU2hvdWxkIG5vdCByZW1vdmUgcmVuZGVyIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gIHJldHVybiByZW1vdmVMYW5lcyhjdXJyZW50LmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIHN1c3BlbmQuXG5cbiAge1xuICAgIGlmIChzaG91bGRTdXNwZW5kKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICB2YXIgc2hvd0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKGRpZFN1c3BlbmQgfHwgc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQpKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbiAgICAvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgIHNob3dGYWxsYmFjayA9IHRydWU7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXR0ZW1wdGluZyB0aGUgbWFpbiBjb250ZW50XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50IG9yIHRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgc3RhdGUuXG4gICAgICAvLyBNYXJrIHRoaXMgc3VidHJlZSBjb250ZXh0IGFzIGhhdmluZyBhdCBsZWFzdCBvbmUgaW52aXNpYmxlIHBhcmVudCB0aGF0IGNvdWxkXG4gICAgICAvLyBoYW5kbGUgdGhlIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gQm91bmRhcmllcyB3aXRob3V0IGZhbGxiYWNrcyBvciBzaG91bGQgYmUgYXZvaWRlZCBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2VcbiAgICAgIC8vIHRoZXkgY2Fubm90IGhhbmRsZSBwcmVmZXJyZWQgZmFsbGJhY2sgc3RhdGVzLlxuICAgICAgaWYgKG5leHRQcm9wcy5mYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIG5leHRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZSkge1xuICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBPSywgdGhlIG5leHQgcGFydCBpcyBjb25mdXNpbmcuIFdlJ3JlIGFib3V0IHRvIHJlY29uY2lsZSB0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkncyBjaGlsZHJlbi4gVGhpcyBpbnZvbHZlcyBzb21lIGN1c3RvbSByZWNvbmNpbGF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICAvLyBCdXQgb25seSBpZiB0aGlzIGhhcyBhIGZhbGxiYWNrLlxuICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3BzLnVuc3RhYmxlX2V4cGVjdGVkTG9hZFRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgQ1BVLWJvdW5kIHRyZWUuIFNraXAgdGhpcyB0cmVlIGFuZCBzaG93IGEgcGxhY2Vob2xkZXIgdG9cbiAgICAgIC8vIHVuYmxvY2sgdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQuIFRoZW4gaW1tZWRpYXRlbHkgcmV0cnkgYWZ0ZXIgdGhlXG4gICAgICAvLyBpbml0aWFsIGNvbW1pdC5cbiAgICAgIHZhciBfZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXMgdG9cbiAgICAgIC8vIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtcyBvZlxuICAgICAgLy8gcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLCBpdCdzXG4gICAgICAvLyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzIGNvbW1pdHRlZC4gSWZcbiAgICAgIC8vIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZSBwYWludGVkLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLiBXZSBjYW4gdXNlIGFueVxuICAgICAgLy8gUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmcgc2luY2Ugd2UncmUgbGVhdmluZ1xuICAgICAgLy8gaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICB7XG4gICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAvLyBJZiB0aGUgY3VycmVudCBmaWJlciBoYXMgYSBTdXNwZW5zZVN0YXRlLCB0aGF0IG1lYW5zIGl0J3MgYWxyZWFkeSBzaG93aW5nXG4gICAgLy8gYSBmYWxsYmFjay5cbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjIsIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjIsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN0YXRlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzLm1lbW9pemVkU3RhdGUgPSBwcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgICAgcmV0dXJuIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4zID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0ID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50NDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdHJlZSBpcyBub3QgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2suXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRpbWVkIG91dC5cbiAgICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjQgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQyID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjQsIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB2YXIgX3ByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NS5tZW1vaXplZFN0YXRlID0gX3ByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKF9wcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NS5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpOyAvLyBTa2lwIHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBhbmQgY29udGludWUgd29ya2luZyBvbiB0aGVcbiAgICAgICAgLy8gZmFsbGJhY2sgY2hpbGRyZW4uXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0aWxsIGhhdmVuJ3QgdGltZWQgb3V0LiBDb250aW51ZSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLCBsaWtlIHdlXG4gICAgICAgIC8vIG5vcm1hbGx5IGRvLlxuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW41ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ2ID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50NjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSwgTm9MYW5lcywgbnVsbCk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IG51bGw7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBEZWxldGUgdGhlIGZhbGxiYWNrIGNoaWxkIGZyYWdtZW50XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzID0gRGVsZXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAnaGlkZGVuJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICBpZiAoIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbiAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUgJiYgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbiAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuICAvLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbiAgLy8gb25seSBjb2RlcGF0aC4pXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IC8vIFRoZSBmYWxsYmFjayBmaWJlciB3YXMgYWRkZWQgYXMgYSBkZWxldGlvbiBlZmZlY3QgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG4gICAgLy8gdG8gZGVsZXRlIGl0LiBTbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0LiBEZWxldGlvbnMgYXJlIHN0b3JlZFxuICAgIC8vIG9uIHRoZSBzYW1lIGxpc3QgYXMgZWZmZWN0cy4gV2Ugd2FudCB0byBrZWVwIHRoZSBlZmZlY3RzIGZyb20gdGhlIHByaW1hcnlcbiAgICAvLyB0cmVlLiBTbyB3ZSBjb3B5IHRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50J3MgZWZmZWN0IGxpc3QsIHdoaWNoIGRvZXMgbm90XG4gICAgLy8gaW5jbHVkZSB0aGUgZmFsbGJhY2sgZGVsZXRpb24gZWZmZWN0LlxuXG5cbiAgICB2YXIgcHJvZ3Jlc3NlZExhc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKHByb2dyZXNzZWRMYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmZpcnN0RWZmZWN0O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IHByb2dyZXNzZWRMYXN0RWZmZWN0O1xuICAgICAgcHJvZ3Jlc3NlZExhc3RFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IFJlc2V0IHRoaXMgc29tZXdoZXJlIGVsc2U/IExvbCBsZWdhY3kgbW9kZSBpcyBzbyB3ZWlyZC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHByaW1hcnlDaGlsZFByb3BzKTtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMpIHtcbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgZmlyc3RDaGlsZCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbiAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuICAvLyB0byB1bmJsb2NrLlxuICB2YXIgbm9kZSA9IGZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuICAgICAgLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4gICAgICAvLyBsaXN0IGl0c2VsZi5cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4gICAgICAvLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpIHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbiAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3JcbiAgLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4gIC8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4gIC8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuICAvLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxuICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcbiAgdmFyIGxhc3RDb250ZW50Um93ID0gbnVsbDtcblxuICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgIGxhc3RDb250ZW50Um93ID0gcm93O1xuICAgIH1cblxuICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAocmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCAmJiByZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICd0b2dldGhlcicgJiYgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSkge1xuICAgICAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG4gICAgICBpZiAodGFpbE1vZGUgIT09ICdjb2xsYXBzZWQnICYmIHRhaWxNb2RlICE9PSAnaGlkZGVuJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAge1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjaGlsZFNsb3QpO1xuICAgIHZhciBpc0l0ZXJhYmxlID0gIWlzQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FycmF5IHx8IGlzSXRlcmFibGUpIHtcbiAgICAgIHZhciB0eXBlID0gaXNBcnJheSA/ICdhcnJheScgOiAnaXRlcmFibGUnO1xuXG4gICAgICBlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJyArICdhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnICsgJzwvU3VzcGVuc2VMaXN0PicsIHR5cGUsIGluZGV4LCB0eXBlKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKChyZXZlYWxPcmRlciA9PT0gJ2ZvcndhcmRzJyB8fCByZXZlYWxPcmRlciA9PT0gJ2JhY2t3YXJkcycpICYmIGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZHJlbltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuSXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJyArICdUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJyArICdEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLCByZXZlYWxPcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBpc0JhY2t3YXJkcywgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlLCBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nKSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbDogdGFpbCxcbiAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZSxcbiAgICAgIGxhc3RFZmZlY3Q6IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmdcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZztcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIFN1c3BlbnNlTGlzdCBkb2Vzbid0IHdvcmsgc28gd2UganVzdFxuICAgIC8vIHVzZSBtYWtlIGl0IGEgbm9vcCBieSB0cmVhdGluZyBpdCBhcyB0aGUgZGVmYXVsdCByZXZlYWxPcmRlci5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnRSb3cgPSBmaW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO1xuICAgICAgICAgIHZhciB0YWlsO1xuXG4gICAgICAgICAgaWYgKGxhc3RDb250ZW50Um93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbiAgICAgICAgICAgIHRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG4gICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcbiAgICAgICAgICAgIGxhc3RDb250ZW50Um93LnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAvLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2VcbiAgICAgICAgICAvLyBvcmRlci5cbiAgICAgICAgICB2YXIgX3RhaWwgPSBudWxsO1xuICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJvdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Um93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuICAgICAgICAgICAgX3RhaWwgPSByb3c7XG4gICAgICAgICAgICByb3cgPSBuZXh0Um93O1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIHRydWUsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgX3RhaWwsIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICB7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBudWxsLCAvLyB0YWlsXG4gICAgICAgICAgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHVuZGVmaW5lZCwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4gICAgICAgICAgLy8gYSBib3VuZGFyeS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuICB7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXdQcm9wcykpIHtcbiAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcbiAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVyUHJvcFR5cGVzID0gd29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLCBuZXdQcm9wcywgJ3Byb3AnLCAnQ29udGV4dC5Qcm92aWRlcicpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuXG4gIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQsIG5ld1Byb3BzLnVuc3RhYmxlX29ic2VydmVkQml0cyk7XG4gIHZhciBuZXdDaGlsZHJlbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpIHtcbiAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gUmV1c2UgcHJldmlvdXMgZGVwZW5kZW5jaWVzXG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgfVxuXG4gIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMpOyAvLyBDaGVjayBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBhbnkgcGVuZGluZyB3b3JrLlxuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4gICAgLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbiAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdW50RmliZXIoY3VycmVudCwgb2xkV29ya0luUHJvZ3Jlc3MsIG5ld1dvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuJyk7XG4gICAgfSAvLyBEaXNjb25uZWN0IGZyb20gdGhlIG9sZCBjdXJyZW50LlxuICAgIC8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5cblxuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBvbGRXb3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBDb25uZWN0IHRvIHRoZSBuZXcgdHJlZS5cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmluZGV4ID0gb2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3Muc2libGluZyA9IG9sZFdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmV0dXJuID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJlZiA9IG9sZFdvcmtJblByb2dyZXNzLnJlZjsgLy8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cblxuICAgIGlmIChvbGRXb3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpIHtcbiAgICAgIHJldHVybkZpYmVyLmNoaWxkID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2U2libGluZyA9IHJldHVybkZpYmVyLmNoaWxkO1xuXG4gICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLicpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocHJldlNpYmxpbmcuc2libGluZyAhPT0gb2xkV29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJldmlvdXMgc2libGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSAvLyBEZWxldGUgdGhlIG9sZCBmaWJlciBhbmQgcGxhY2UgdGhlIG5ldyBvbmUuXG4gICAgLy8gU2luY2UgdGhlIG9sZCBmaWJlciBpcyBkaXNjb25uZWN0ZWQsIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgbWFudWFsbHkuXG5cblxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjdXJyZW50O1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgY3VycmVudC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjdXJyZW50LmZsYWdzID0gRGVsZXRpb247XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHVwZGF0ZUxhbmVzID0gd29ya0luUHJvZ3Jlc3MubGFuZXM7XG5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlc3RhcnQgdGhlIGJlZ2luIHBoYXNlIHdpdGggYSBuZXcgZmliZXIuXG4gICAgICByZXR1cm4gcmVtb3VudEZpYmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3Mua2V5LCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsIHdvcmtJblByb2dyZXNzLm1vZGUsIHdvcmtJblByb2dyZXNzLmxhbmVzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBoYXNDb250ZXh0Q2hhbmdlZCgpIHx8ICggLy8gRm9yY2UgYSByZS1yZW5kZXIgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQ6XG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgIT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICAvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHVuc2V0IGlmIHRoZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB0byBiZSBlcXVhbCBsYXRlciAobWVtbykuXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lcykpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTsgLy8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuICAgICAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gICAgICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cblxuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBQcm9maWxlciBzaG91bGQgb25seSBjYWxsIG9uUmVuZGVyIHdoZW4gb25lIG9mIGl0cyBkZXNjZW5kYW50cyBhY3R1YWxseSByZW5kZXJlZC5cbiAgICAgICAgICAgIHZhciBoYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICB9IC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG5cblxuICAgICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgICAgIC8vIGdvIHN0cmFpZ2h0IHRvIHRoZSBmYWxsYmFjay4gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgICAgIC8vIGNoaWxkIGZyYWdtZW50LlxuXG5cbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRMYW5lcyA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM7XG5cbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHByaW1hcnlDaGlsZExhbmVzKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAgICAgLy8gdG8gYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gYWdhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgbWFya2VkXG4gICAgICAgICAgICAgICAgLy8gb24gaXRcbiAgICAgICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4gYW5kIHdvcmsgb24gdGhlIGZhbGxiYWNrLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICAgICAgICAgIHZhciBfaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICAgIGlmIChfaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgbWlnaHQgZ2V0IHVuYmxvY2tlZCBieSBzdGF0ZSB1cGRhdGVzIG9yIHJldHJpZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuICAgICAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgfSAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSB0YWlsIGRvZXNuJ3QgbWF0dGVyLiBBbnl0aGluZyBuZXcgdGhhdCBzdXNwZW5kcyB3aWxsIHdvcmtcbiAgICAgICAgICAgIC8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cblxuXG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuXG4gICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gYWxtb3N0IGlkZW50aWNhbCB0byB0aGUgbG9naWMgdXNlZCBpbiB0aGUgbm9ybWFsIHVwZGF0ZSBwYXRoLFxuICAgICAgICAgICAgLy8gc28gd2UnbGwganVzdCBlbnRlciB0aGF0LiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHdlJ2xsIGJhaWwgb3V0XG4gICAgICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAgICAgLy8gaGF2ZSBub3QgY2hhbmdlZC4gV2hpY2ggaXMgZmluZS5cbiAgICAgICAgICAgIC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCByZWZhY3RvciBgYmVnaW5Xb3JrYCB0byBzcGxpdCB0aGUgYmFpbG91dFxuICAgICAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgICAgIC8vIGJ1dCBJIHdvbid0IDopXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb24gdGhpcyBmaWJlciwgYnV0IHRoZXJlIGFyZSBubyBuZXcgcHJvcHNcbiAgICAgICAgLy8gbm9yIGxlZ2FjeSBjb250ZXh0LiBTZXQgdGhpcyB0byBmYWxzZS4gSWYgYW4gdXBkYXRlIHF1ZXVlIG9yIGNvbnRleHRcbiAgICAgICAgLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB3aWxsIGFzc3VtZSB0aGUgY2hpbGRyZW4gaGF2ZSBub3QgY2hhbmdlZCBhbmQgYmFpbCBvdXQuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICB9IC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuICAvLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCB3ZSdyZSBhYm91dCB0byBldmFsdWF0ZSB0aGUgY29tcG9uZW50IGFuZCBwcm9jZXNzXG4gIC8vIHRoZSB1cGRhdGUgcXVldWUuIEhvd2V2ZXIsIHRoZXJlJ3MgYW4gZXhjZXB0aW9uOiBTaW1wbGVNZW1vQ29tcG9uZW50XG4gIC8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuICAvLyBtb3ZlIHRoaXMgYXNzaWdubWVudCBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIGFuZCBpbnRvIGVhY2ggYnJhbmNoLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgICByZXR1cm4gbW91bnRMYXp5Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudCA/IHVucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MiwgX3VucmVzb2x2ZWRQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MiwgX3Jlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSB0eXBlID8gX3VucmVzb2x2ZWRQcm9wczIgOiByZXNvbHZlRGVmYXVsdFByb3BzKHR5cGUsIF91bnJlc29sdmVkUHJvcHMyKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90eXBlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczMgPSByZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMiwgX3VucmVzb2x2ZWRQcm9wczMpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IF90eXBlMi5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgX3Jlc29sdmVkUHJvcHMzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuICAgICAgICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoX3R5cGUyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSwgX3Jlc29sdmVkUHJvcHMzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlMiwgX3Jlc29sdmVkUHJvcHMzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50MyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQzID8gX3VucmVzb2x2ZWRQcm9wczQgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQzLCBfdW5yZXNvbHZlZFByb3BzNCk7XG5cbiAgICAgICAgcmV0dXJuIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MywgX3Jlc29sdmVkUHJvcHM0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlTGVnYWN5SGlkZGVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbn1cblxudmFyIGFwcGVuZEFsbENoaWxkcmVuO1xudmFyIHVwZGF0ZUhvc3RDb250YWluZXI7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudCQxO1xudmFyIHVwZGF0ZUhvc3RUZXh0JDE7XG5cbntcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuICAgICAgLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgIC8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAvLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuICAgIC8vIHJlbGF0ZWQgdG8gYGhpZGRlbmAuXG5cbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpOyAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cblxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjaykge1xuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cbiAgICAvLyBzbyB3ZSBkb24ndCBsZWF2ZSBhbnkgYmVoaW5kLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIHRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKGxhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdjb2xsYXBzZWQnOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIF90YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoX3RhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKF90YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9sYXN0VGFpbE5vZGUgPSBfdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RhaWxOb2RlID0gX3RhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAoX2xhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgaWYgKCFoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgJiYgcmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2Ugc3VzcGVuZGVkIGR1cmluZyB0aGUgaGVhZC4gV2Ugd2FudCB0byBzaG93IGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBNb2RlOlxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFmaWJlclJvb3QuaHlkcmF0ZSkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQuXG4gICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugb2YgUmVhY3QgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvciB1cGRhdGVzIHRvbywgYmVjYXVzZSBjdXJyZW50LmNoaWxkIHdvdWxkIG9ubHkgYmUgbnVsbFxuICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIHRoZSBjb250YWluZXIgd291bGQgYWxyZWFkeSBiZSBlbXB0eSkuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKCEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMiA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQyKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7IC8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy5mYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBwcmV2U3RhdGUgIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgJiYgIXByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJ0cmVlZSBpcyBydW5uaW5nIGluIGJsb2NraW5nIG1vZGUgd2UgY2FuIHN1c3BlbmQsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdvbid0IHN1c3BlbmQuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBiYWNrIHRvIHRocm93RXhjZXB0aW9uIGJlY2F1c2UgdGhpcyBpcyB0b28gbGF0ZVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxhcmdlIHRyZWUgd2hpY2ggaXMgY29tbW9uIGZvciBpbml0aWFsIGxvYWRzLiBXZVxuICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgcmVzdGFydCBhIHJlbmRlciBvciBub3QgdW50aWwgd2UgZ2V0XG4gICAgICAgICAgICAvLyB0aGlzIG1hcmtlciwgYW5kIHRoaXMgaXMgdG9vIGxhdGUuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHJlbmRlciBhbHJlYWR5IGhhZCBhIHBpbmcgb3IgbG93ZXIgcHJpIHVwZGF0ZXMsXG4gICAgICAgICAgICAvLyBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBrbm93IHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhYmxlIHRvIGltbWVkaWF0ZWx5IHJlc3RhcnQgZnJvbSB3aXRoaW4gdGhyb3dFeGNlcHRpb24uXG4gICAgICAgICAgICB2YXIgaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0ID0gY3VycmVudCA9PT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbiAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IE9ubHkgc2NoZWR1bGUgdXBkYXRlcyBpZiB0aGVzZSB2YWx1ZXMgYXJlIG5vbiBlcXVhbCwgaS5lLiBpdCBjaGFuZ2VkLlxuICAgICAgICAgIGlmIChuZXh0RGlkVGltZW91dCB8fCBwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgc2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhXG4gICAgICAgICAgICAvLyByZXRyeSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZS4gVGhpcyBmbGFnIGlzIGFsc28gdXNlZCB0byBoaWRlIHRoZVxuICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbi4gSW4gbXV0YXRpb24gbW9kZSwgd2UgYWxzbyBuZWVkIHRoZSBmbGFnIHRvXG4gICAgICAgICAgICAvLyAqdW5oaWRlKiBjaGlsZHJlbiB0aGF0IHdlcmUgcHJldmlvdXNseSBoaWRkZW4sIHNvIGNoZWNrIGlmIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHRvby5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgICAvLyBzZXF1ZW50aWFsIHRvIGVuc3VyZSB0aGlzIHN3aXRjaCBpcyBjb21waWxlZCB0byBhIGp1bXAgdGFibGUuXG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVubmFibGVzLiBJbnN0ZWFkLCB3ZSdsbCB0cmFuc2ZlciBpdHMgdGhlbm5hYmxlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlTGlzdCBzbyB0aGF0IGl0IGNhbiByZXRyeSBpZiB0aGV5IHJlc29sdmUuXG4gICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvZiB0aGVzZSBpbiB0aGUgbGlzdCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAvLyB3aGljaCBvbmVzIGdldHMgdG8gcGluZy4gSW4gdGhlb3J5IHdlIGNvdWxkIGdldCBjbGV2ZXIgYW5kIGtlZXBcbiAgICAgICAgICAgICAgICAgIC8vIHRyYWNrIG9mIGhvdyBtYW55IGRlcGVuZGVuY2llcyByZW1haW4gYnV0IGl0IGdldHMgdHJpY2t5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBiYWlsIG91dCBvZiB0aGUgbG9vcCBiZWZvcmUgZmluZGluZyBhbnkgYnV0IHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHRoYXQgbWVhbnMgdGhhdCB0aGUgb3RoZXIgYm91bmRhcmllcyB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBuZXdUaGVubmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbm5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG5ld1RoZW5uYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgIH0gLy8gUmVyZW5kZXIgdGhlIHdob2xlIGxpc3QsIGJ1dCB0aGlzIHRpbWUsIHdlJ2xsIGZvcmNlIGZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgLy8gdG8gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgbGlzdCBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cblxuXG4gICAgICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0OyAvLyBSZXNldCB0aGUgY2hpbGQgZmliZXJzIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuXG4gICAgICAgICAgICAgICAgICByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7IC8vIFNldCB1cCB0aGUgU3VzcGVuc2UgQ29udGV4dCB0byBmb3JjZSBzdXNwZW5zZSBhbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgIC8vIHJlcmVuZGVyIHRoZSBjaGlsZHJlbi5cblxuICAgICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsICYmIG5vdygpID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG4gICAgICAgICAgICAgIC8vIGxlZnQgaW4gdGhlIHRhaWwuIFdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyIGF0dGVtcHRzIHRvIHJlbmRlclxuICAgICAgICAgICAgICAvLyB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdUaGVubmFibGVzID0gX3N1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICBpZiAoX25ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9uZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSByb3cgd2UganVzdCByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgbGlzdCB0byB3aGF0IGl0IHdhcyBiZWZvcmUgd2UgcmVuZGVyZWQgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2hpbGQuIFRoZSBuZXN0ZWQgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGFwcGVuZGVkIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICAgICAgICB2YXIgbGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0OyAvLyBSZW1vdmUgYW55IGVmZmVjdHMgdGhhdCB3ZXJlIGFwcGVuZGVkIGFmdGVyIHRoaXMgcG9pbnQuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9IC8vIFdlJ3JlIGRvbmUuXG5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4gICAgICAgICAgICAvLyBleGNlZWQgaXQuXG4gICAgICAgICAgICBub3coKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFya1NwYXduZWRXb3JrKFNvbWVSZXRyeUxhbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGxpc3Qgb2YgdGhlIGJhY2t3YXJkcyB0YWlsIHdpbGwgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICAgICAgICAvLyB0byB0aGUgZW5kLiBUaGlzIGJyZWFrcyB0aGUgZ3VhcmFudGVlIHRoYXQgbGlmZS1jeWNsZXMgZmlyZSBpblxuICAgICAgICAgICAgLy8gc2libGluZyBvcmRlciBidXQgdGhhdCBpc24ndCBhIHN0cm9uZyBndWFyYW50ZWUgcHJvbWlzZWQgYnkgUmVhY3QuXG4gICAgICAgICAgICAvLyBFc3BlY2lhbGx5IHNpbmNlIHRoZXNlIG1pZ2h0IGFsc28ganVzdCBwb3AgaW4gZHVyaW5nIGZ1dHVyZSBjb21taXRzLlxuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gICAgICAgICAgICByZW5kZXJlZFRhaWwuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSByZW5kZXJTdGF0ZS5sYXN0O1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5zaWJsaW5nID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3QgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIHRhaWwgcm93cyB0byByZW5kZXIuXG4gICAgICAgICAgLy8gUG9wIGEgcm93LlxuICAgICAgICAgIHZhciBuZXh0ID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBuZXh0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBuZXh0LnNpYmxpbmc7XG4gICAgICAgICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAgICAgbmV4dC5zaWJsaW5nID0gbnVsbDsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC5cbiAgICAgICAgICAvLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkganVzdCBhdm9pZCBwb3BwaW5nIGl0IGluc3RlYWQgYW5kIG9ubHlcbiAgICAgICAgICAvLyBzZXR0aW5nIGl0IHRoZSBmaXJzdCB0aW1lIHdlIGdvIGZyb20gbm90IHN1c3BlbmRlZCB0byBzdXNwZW5kZWQuXG5cbiAgICAgICAgICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXG4gICAgICAgICAgaWYgKGRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEJsb2NrOlxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJldklzSGlkZGVuICE9PSBuZXh0SXNIaWRkZW4gJiYgbmV3UHJvcHMubW9kZSAhPT0gJ3Vuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nJykge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgX2ZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKCEoKF9mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSByb290IGZhaWxlZCB0byB1bm1vdW50IGFmdGVyIGFuIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICB2YXIgX2ZsYWdzMiA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChfZmxhZ3MyICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTsgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7IC8vIFN1c3BlbnNlTGlzdCBkb2Vzbid0IGFjdHVhbGx5IGNhdGNoIGFueXRoaW5nLiBJdCBzaG91bGQndmUgYmVlblxuICAgICAgICAvLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspIHtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKTsgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG5cbiAgICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnOyAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgICAvLyBXZSByZWNvcmQgdGhpcyBpbmZvcm1hdGlvbiBhcyBhbiBleHBhbmRvIG9uIHRoZSBlcnJvci5cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICBpZiAoYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIC8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuICAgICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgICAvLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXG5cbiAgICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBzb3VyY2UgPyBnZXRDb21wb25lbnROYW1lKHNvdXJjZS50eXBlKSA6IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50OlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKGJvdW5kYXJ5LnR5cGUpO1xuXG4gICAgICBpZiAoZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyBlcnJvckJvdW5kYXJ5TmFtZSArIFwiLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSBjb21wb25lbnROYW1lTWVzc2FnZSArIFwiXFxuXCIgKyBjb21wb25lbnRTdGFjayArIFwiXFxuXFxuXCIgKyAoXCJcIiArIGVycm9yQm91bmRhcnlNZXNzYWdlKTsgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oY29tYmluZWRNZXNzYWdlKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHdlIHByaW50IHRoZSBlcnJvciBkaXJlY3RseS5cbiAgICAgIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBtZXNzYWdlLCB0aGUgSlMgc3RhY2ssIGFuZCBhbnl0aGluZyB0aGUgYnJvd3NlciB3YW50cyB0byBzaG93LlxuICAgICAgLy8gV2UgcGFzcyB0aGUgZXJyb3Igb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIG1lc3NhZ2Ugc28gdGhhdCB0aGUgYnJvd3NlciBkaXNwbGF5cyB0aGUgZXJyb3IgbmF0aXZlbHkuXG4gICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTsgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cblxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogbnVsbFxuICB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IkMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTsgLy8gT25seSBsb2cgaGVyZSBpZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZFxuXG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciQxLCB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJydcbiAgICAgIH0pO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG4gICAgICAgICAgLy8gdGhlbiBpdCBuZWVkcyB0byBjYWxsIHNldFN0YXRlIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMuXG4gICAgICAgICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuICAgICAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShmaWJlci5sYW5lcywgU3luY0xhbmUpKSB7XG4gICAgICAgICAgICBlcnJvcignJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gJyArICdJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS4nLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UgdG8gXCJwaW5nXCIgdGhlIHJvb3QgYW5kIHJldHJ5LiBCdXQgb25seSBpZlxuICAvLyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoXG4gIC8vIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcbiAgICB3YWtlYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG4gIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7IC8vIEl0cyBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG5cbiAgc291cmNlRmliZXIuZmlyc3RFZmZlY3QgPSBzb3VyY2VGaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS5cbiAgICB2YXIgd2FrZWFibGUgPSB2YWx1ZTtcblxuICAgIGlmICgoc291cmNlRmliZXIubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIG1lbW9pemVkU3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIGF0dGVtcHRlZFxuICAgICAgLy8gdG8gcmVuZGVyIGl0LlxuICAgICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50U291cmNlKSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3VycmVudFNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzSW52aXNpYmxlUGFyZW50Qm91bmRhcnkgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpOyAvLyBTY2hlZHVsZSB0aGUgbmVhcmVzdCBTdXNwZW5zZSB0byByZS1yZW5kZXIgdGhlIHRpbWVkIG91dCB2aWV3LlxuXG4gICAgdmFyIF93b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKF93b3JrSW5Qcm9ncmVzcy50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIHNob3VsZENhcHR1cmVTdXNwZW5zZShfd29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5KSkge1xuICAgICAgICAvLyBGb3VuZCB0aGUgbmVhcmVzdCBib3VuZGFyeS5cbiAgICAgICAgLy8gU3Rhc2ggdGhlIHByb21pc2Ugb24gdGhlIGJvdW5kYXJ5IGZpYmVyLiBJZiB0aGUgYm91bmRhcnkgdGltZXMgb3V0LCB3ZSdsbFxuICAgICAgICAvLyBhdHRhY2ggYW5vdGhlciBsaXN0ZW5lciB0byBmbGlwIHRoZSBib3VuZGFyeSBiYWNrIHRvIGl0cyBub3JtYWwgc3RhdGUuXG4gICAgICAgIHZhciB3YWtlYWJsZXMgPSBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHdha2VhYmxlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdha2VhYmxlcy5hZGQod2FrZWFibGUpO1xuICAgICAgICB9IC8vIElmIHRoZSBib3VuZGFyeSBpcyBvdXRzaWRlIG9mIGJsb2NraW5nIG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbiAgICAgICAgLy8gbnVsbCBhbmQga2VlcCByZW5kZXJpbmcuIEluIHRoZSBjb21taXQgcGhhc2UsIHdlJ2xsIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gc3Vic2VxdWVudCBzeW5jaHJvbm91cyB1cGRhdGUgdG8gcmUtcmVuZGVyIHRoZSBTdXNwZW5zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogSXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciB0aGUgY29tcG9uZW50IHRoYXQgc3VzcGVuZGVkIHdhc1xuICAgICAgICAvLyBpbnNpZGUgYSBibG9ja2luZyBtb2RlIHRyZWUuIElmIHRoZSBTdXNwZW5zZSBpcyBvdXRzaWRlIG9mIGl0LCB3ZVxuICAgICAgICAvLyBzaG91bGQgKm5vdCogc3VzcGVuZCB0aGUgY29tbWl0LlxuXG5cbiAgICAgICAgaWYgKChfd29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7IC8vIFdlJ3JlIGdvaW5nIHRvIGNvbW1pdCB0aGlzIGZpYmVyIGV2ZW4gdGhvdWdoIGl0IGRpZG4ndCBjb21wbGV0ZS5cbiAgICAgICAgICAvLyBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yIGNhbGxiYWNrcy4gUmVtb3ZlXG4gICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cblxuICAgICAgICAgIHNvdXJjZUZpYmVyLmZsYWdzICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAgICAgLy8gY29tcGxldGVkIGNsYXNzIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIHdlIHNob3VsZCBub3QgY2FsbFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4gICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbiAgICAgICAgICAgICAgLy8gcHJldmVudCBhIGJhaWwgb3V0LlxuICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBTeW5jTGFuZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShzb3VyY2VGaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG5cblxuICAgICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgU3luY0xhbmUpOyAvLyBFeGl0IHdpdGhvdXQgc3VzcGVuZGluZy5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgICAgICAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gICAgICAgIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAgICAgICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgICAgICAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgICAgICAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgICAgICAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgICAgICAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAgICAgICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgICAgICAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAgICAgICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgICAgICAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgICAgICAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gICAgICAgIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAgICAgICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAgICAgICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgICAgICAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAgICAgICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAgICAgICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgICAvLyBib3VuZGFyeS5cblxuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MgPSBfd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIH0gd2hpbGUgKF93b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7IC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICAvLyBUT0RPOiBVc2UgaW52YXJpYW50IHNvIHRoZSBtZXNzYWdlIGlzIHN0cmlwcGVkIGluIHByb2Q/XG5cblxuICAgIHZhbHVlID0gbmV3IEVycm9yKChnZXRDb21wb25lbnROYW1lKHNvdXJjZUZpYmVyLnR5cGUpIHx8ICdBIFJlYWN0IGNvbXBvbmVudCcpICsgJyBzdXNwZW5kZWQgd2hpbGUgcmVuZGVyaW5nLCBidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHNwZWNpZmllZC5cXG4nICsgJ1xcbicgKyAnQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byAnICsgJ3Byb3ZpZGUgYSBsb2FkaW5nIGluZGljYXRvciBvciBwbGFjZWhvbGRlciB0byBkaXNwbGF5LicpO1xuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTtcblxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfZXJyb3JJbmZvLCBsYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBlcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzICYmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciBfdXBkYXRlMiA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGVycm9ySW5mbywgX2xhbmUpO1xuXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcblxue1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcblxudmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH1cbn07IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG5cbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICB2YXIgcmVmRXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgcmVmRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgZGVzdHJveSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGRlc3Ryb3ksIG51bGwpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgU25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KHRhZywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIHRhZykgPT09IHRhZykge1xuICAgICAgICAvLyBVbm1vdW50XG4gICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gTW91bnRcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKCk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIHVzZUVmZmVjdChhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJyArICdJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0ICcgKyAnYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuJyArICd1c2VFZmZlY3QoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignQW4gZWZmZWN0IGZ1bmN0aW9uIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcgKyAnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBfZWZmZWN0ID0gZWZmZWN0LFxuICAgICAgICAgIG5leHQgPSBfZWZmZWN0Lm5leHQsXG4gICAgICAgICAgdGFnID0gX2VmZmVjdC50YWc7XG5cbiAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxICYmICh0YWcgJiBIYXNFZmZlY3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmluaXNoZWRXb3JrLCBlZmZlY3QpO1xuICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0TW91bnQoZmluaXNoZWRXb3JrLCBlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBuZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cblxuXG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICAgICAgb25SZW5kZXIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUmVuZGVyO1xuICAgICAgICAgIHZhciBlZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9uUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lLCBmaW5pc2hlZFJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pIHtcbiAge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UzID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMywgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50KSAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZmluaXNoZWRXb3JrKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuXG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gaW5zdGFuY2U7XG4gICAgfSAvLyBNb3ZlZCBvdXRzaWRlIHRvIGVuc3VyZSBEQ0Ugd29ya3Mgd2l0aCB0aGlzIGZsYWdcblxuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERldGFjaFJlZihjdXJyZW50KSB7XG4gIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59IC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5cblxuZnVuY3Rpb24gY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB2YXIgX2VmZmVjdDIgPSBlZmZlY3QsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdDIuZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgIHRhZyA9IF9lZmZlY3QyLnRhZztcblxuICAgICAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0YWcgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGN1cnJlbnQsIGVmZmVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICB7XG4gICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlck11dGF0aW9uKGZpYmVyKSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vIE5vdGU6IHdlIGNhbm5vdCBudWxsIG91dCBzaWJsaW5nIGhlcmUsIG90aGVyd2lzZSBpdCBjYW4gY2F1c2UgaXNzdWVzXG4gIC8vIHdpdGggZmluZERPTU5vZGUgYW5kIGhvdyBpdCByZXF1aXJlcyB0aGUgc2libGluZyBmaWVsZCB0byBjYXJyeSBvdXRcbiAgLy8gdHJhdmVyc2FsIGluIGEgbGF0ZXIgZWZmZWN0LiBTZWUgUFIgIzE2ODIwLiBXZSBub3cgY2xlYXIgdGhlIHNpYmxpbmdcbiAgLy8gZmllbGQgYWZ0ZXIgZWZmZWN0cywgc2VlOiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy9cbiAgLy8gRG9uJ3QgZGlzY29ubmVjdCBzdGF0ZU5vZGUgbm93OyBpdCB3aWxsIGJlIGRldGFjaGVkIGluIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzLlxuICAvLyBJdCBtYXkgYmUgcmVxdWlyZWQgaWYgdGhlIGN1cnJlbnQgY29tcG9uZW50IGlzIGFuIGVycm9yIGJvdW5kYXJ5LFxuICAvLyBhbmQgb25lIG9mIGl0cyBkZXNjZW5kYW50cyB0aHJvd3Mgd2hpbGUgdW5tb3VudGluZyBhIHBhc3NpdmUgZWZmZWN0LlxuICBmaWJlci5hbHRlcm5hdGUgPSBudWxsO1xuICBmaWJlci5jaGlsZCA9IG51bGw7XG4gIGZpYmVyLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIGZpYmVyLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgZmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIHBhcmVudDtcbiAgdmFyIGlzQ29udGFpbmVyO1xuICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cblxuICBpZiAocGFyZW50RmliZXIuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgcmVzZXRUZXh0Q29udGVudChwYXJlbnQpOyAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuXG4gICAgcGFyZW50RmliZXIuZmxhZ3MgJj0gfkNvbnRlbnRSZXNldDtcbiAgfVxuXG4gIHZhciBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspOyAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblxuICBpZiAoaXNDb250YWluZXIpIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gaXNIb3N0ID8gbm9kZS5zdGF0ZU5vZGUgOiBub2RlLnN0YXRlTm9kZS5pbnN0YW5jZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgdmFyIG5vZGUgPSBjdXJyZW50OyAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gIC8vIGN1cnJlbnRQYXJlbnRJc1ZhbGlkLlxuXG4gIHZhciBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlOyAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cblxuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnJldHVybjtcblxuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKCEocGFyZW50ICE9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cblxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSAvLyBEb24ndCB2aXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIGFscmVhZHkgdmlzaXRlZCB0aGVtLlxuXG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG5cbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBub2RlKTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50KTtcbiAgfVxuXG4gIHZhciBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgZGV0YWNoRmliZXJNdXRhdGlvbihjdXJyZW50KTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZGV0YWNoRmliZXJNdXRhdGlvbihhbHRlcm5hdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFdvcmsoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTsgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKF9yb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGp1c3QgaHlkcmF0ZWQuIE5vIG5lZWQgdG8gaHlkcmF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIF9yb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKF9yb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFN1c3BlbnNlQ29tcG9uZW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspIHtcbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlICE9PSBudWxsKSB7XG4gICAgbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCk7XG5cbiAgICB7XG4gICAgICAvLyBIaWRlIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHRoYXQgY29udGFpbnMgdGhlIHByaW1hcnkgY2hpbGRyZW4uIFRPRE86XG4gICAgICAvLyBJZGVhbGx5LCB0aGlzIGVmZmVjdCB3b3VsZCBoYXZlIGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBPZmZzY3JlZW4gZmliZXJcbiAgICAgIC8vIGl0c2VsZi4gVGhhdCdzIGhvdyB1bmhpZGluZyB3b3JrczogdGhlIE9mZnNjcmVlbiBjb21wb25lbnQgc2NoZWR1bGVzIGFuXG4gICAgICAvLyBlZmZlY3Qgb24gaXRzZWxmLiBIb3dldmVyLCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnQgZGlkbid0IGNvbXBsZXRlLFxuICAgICAgLy8gc28gdGhlIGZpYmVyIHdhcyBuZXZlciBhZGRlZCB0byB0aGUgZWZmZWN0IGxpc3QgaW4gdGhlIG5vcm1hbCBwYXRoLiBXZVxuICAgICAgLy8gY291bGQgaGF2ZSBhcHBlbmRlZCBpdCB0byB0aGUgZWZmZWN0IGxpc3QgaW4gdGhlIFN1c3BlbnNlIGNvbXBvbmVudCdzXG4gICAgICAvLyBzZWNvbmQgcGFzcywgYnV0IGRvaW5nIGl0IHRoaXMgd2F5IGlzIGxlc3MgY29tcGxpY2F0ZWQuIFRoaXMgd291bGQgYmVcbiAgICAgIC8vIHNpbXBsZXIgaWYgd2UgZ290IHJpZCBvZiB0aGUgZWZmZWN0IGxpc3QgYW5kIHRyYXZlcnNlZCB0aGUgdHJlZSwgbGlrZVxuICAgICAgLy8gd2UncmUgcGxhbm5pbmcgdG8gZG8uXG4gICAgICB2YXIgcHJpbWFyeUNoaWxkUGFyZW50ID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ocHJpbWFyeUNoaWxkUGFyZW50LCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcblxuICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV3U3RhdGUgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cbiAgLy8gRm9yIGVhY2ggd2FrZWFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3RcbiAgLy8gYXR0ZW1wdHMgdG8gcmUtcmVuZGVyIHRoZSBib3VuZGFyeSBpbiB0aGUgcHJpbWFyeSAocHJlLXRpbWVvdXQpIHN0YXRlLlxuICB2YXIgd2FrZWFibGVzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG5cbiAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod2FrZWFibGUuX19yZWFjdERvTm90VHJhY2VJbnRlcmFjdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHJ5ID0gdHJhY2luZy51bnN0YWJsZV93cmFwKHJldHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgIHdha2VhYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IGdvZXMgZnJvbSB2aXNpYmxlIHRvIGhpZGRlbi5cbi8vIEl0IHJldHVybnMgZmFsc2UgaWYgdGhlIGJvdW5kYXJ5IGlzIGFscmVhZHkgaGlkZGVuLlxuLy8gVE9ETzogVXNlIGFuIGVmZmVjdCB0YWcuXG5cblxuZnVuY3Rpb24gaXNTdXNwZW5zZUJvdW5kYXJ5QmVpbmdIaWRkZW4oY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIG5ld1N0YXRlICE9PSBudWxsICYmIG5ld1N0YXRlLmRlaHlkcmF0ZWQgPT09IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcblxuICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbn1cblxudmFyIENPTVBPTkVOVF9UWVBFID0gMDtcbnZhciBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxO1xudmFyIFJPTEVfVFlQRSA9IDI7XG52YXIgVEVTVF9OQU1FX1RZUEUgPSAzO1xudmFyIFRFWFRfVFlQRSA9IDQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciQxID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuY29tcG9uZW50Jyk7XG4gIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzJyk7XG4gIFJPTEVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLnRlc3RfaWQnKTtcbiAgVEVYVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLnRleHQnKTtcbn1cbnZhciBjb21taXRIb29rcyA9IFtdO1xuZnVuY3Rpb24gb25Db21taXRSb290JDEoKSB7XG4gIHtcbiAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIElzU29tZVJlbmRlcmVyQWN0aW5nID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSXNTb21lUmVuZGVyZXJBY3Rpbmc7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgRXZlbnRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBEaXNjcmV0ZUV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICovXG40O1xudmFyIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQgPVxuLyogICAgICAgKi9cbjg7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ29tbWl0Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgUmV0cnlBZnRlckVycm9yID1cbi8qICAgICAgICovXG42NDtcbnZhciBSb290SW5jb21wbGV0ZSA9IDA7XG52YXIgUm9vdEZhdGFsRXJyb3JlZCA9IDE7XG52YXIgUm9vdEVycm9yZWQgPSAyO1xudmFyIFJvb3RTdXNwZW5kZWQgPSAzO1xudmFyIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgPSA0O1xudmFyIFJvb3RDb21wbGV0ZWQgPSA1OyAvLyBEZXNjcmliZXMgd2hlcmUgd2UgYXJlIGluIHRoZSBSZWFjdCBleGVjdXRpb24gc3RhY2tcblxudmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQ7IC8vIFRoZSByb290IHdlJ3JlIHdvcmtpbmcgb25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7IC8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7IC8vIFRoZSBsYW5lcyB3ZSdyZSByZW5kZXJpbmdcblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gU3RhY2sgdGhhdCBhbGxvd3MgY29tcG9uZW50cyB0byBjaGFuZ2UgdGhlIHJlbmRlciBsYW5lcyBmb3IgaXRzIHN1YnRyZWVcbi8vIFRoaXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCB3b3JraW5nIG9uIGF0IHRoZSByb290LiBUaGUgb25seVxuLy8gY2FzZSB3aGVyZSBpdCdzIGRpZmZlcmVudCBmcm9tIGB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc2AgaXMgd2hlbiB3ZVxuLy8gZW50ZXIgYSBzdWJ0cmVlIHRoYXQgaXMgaGlkZGVuIGFuZCBuZWVkcyB0byBiZSB1bmhpZGRlbjogU3VzcGVuc2UgYW5kXG4vLyBPZmZzY3JlZW4gY29tcG9uZW50LlxuLy9cbi8vIE1vc3QgdGhpbmdzIGluIHRoZSB3b3JrIGxvb3Agc2hvdWxkIGRlYWwgd2l0aCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcy5cbi8vIE1vc3QgdGhpbmdzIGluIGJlZ2luL2NvbXBsZXRlIHBoYXNlcyBzaG91bGQgZGVhbCB3aXRoIHN1YnRyZWVSZW5kZXJMYW5lcy5cblxudmFyIHN1YnRyZWVSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG52YXIgc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5vTGFuZXMpOyAvLyBXaGV0aGVyIHRvIHJvb3QgY29tcGxldGVkLCBlcnJvcmVkLCBzdXNwZW5kZWQsIGV0Yy5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5jb21wbGV0ZTsgLy8gQSBmYXRhbCBlcnJvciwgaWYgb25lIGlzIHRocm93blxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IG51bGw7IC8vIFwiSW5jbHVkZWRcIiBsYW5lcyByZWZlciB0byBsYW5lcyB0aGF0IHdlcmUgd29ya2VkIG9uIGR1cmluZyB0aGlzIHJlbmRlci4gSXQnc1xuLy8gc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gYHJlbmRlckxhbmVzYCBiZWNhdXNlIGByZW5kZXJMYW5lc2AgY2FuIGNoYW5nZSBhcyB5b3Vcbi8vIGVudGVyIGFuZCBleGl0IGFuIE9mZnNjcmVlbiB0cmVlLiBUaGlzIHZhbHVlIGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhbGwgcmVuZGVyXG4vLyBsYW5lcyBmb3IgdGhlIGVudGlyZSByZW5kZXIgcGhhc2UuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmsgbGVmdCBvdmVyIGJ5IGNvbXBvbmVudHMgdGhhdCB3ZXJlIHZpc2l0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBPbmx5XG4vLyBpbmNsdWRlcyB1bnByb2Nlc3NlZCB1cGRhdGVzLCBub3Qgd29yayBpbiBiYWlsZWQgb3V0IGNoaWxkcmVuLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgKGluIGFuIGludGVybGVhdmVkIGV2ZW50KSBkdXJpbmcgdGhpcyByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgcGluZ2VkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xudmFyIG1vc3RSZWNlbnRseVVwZGF0ZWRSb290ID0gbnVsbDsgLy8gVGhlIG1vc3QgcmVjZW50IHRpbWUgd2UgY29tbWl0dGVkIGEgZmFsbGJhY2suIFRoaXMgbGV0cyB1cyBlbnN1cmUgYSB0cmFpblxuLy8gbW9kZWwgd2hlcmUgd2UgZG9uJ3QgY29tbWl0IG5ldyBsb2FkaW5nIHN0YXRlcyBpbiB0b28gcXVpY2sgc3VjY2Vzc2lvbi5cblxudmFyIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwO1xudmFyIEZBTExCQUNLX1RIUk9UVExFX01TID0gNTAwOyAvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuLy8gbW9yZSBhbmQgcHJlZmVyIENQVSBzdXNwZW5zZSBoZXVyaXN0aWNzIGluc3RlYWQuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHk7IC8vIEhvdyBsb25nIGEgcmVuZGVyIGlzIHN1cHBvc2VkIHRvIHRha2UgYmVmb3JlIHdlIHN0YXJ0IGZvbGxvd2luZyBDUFVcbi8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cblxudmFyIFJFTkRFUl9USU1FT1VUX01TID0gNTAwO1xuXG5mdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93KCkgKyBSRU5ERVJfVElNRU9VVF9NUztcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU7XG59XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7XG52YXIgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xudmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gTm9Qcmlvcml0eSQxO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzTW91bnQgPSBbXTtcbnZhciBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudCA9IFtdO1xudmFyIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDsgLy8gTWFya3MgdGhlIG5lZWQgdG8gcmVzY2hlZHVsZSBwZW5kaW5nIGludGVyYWN0aW9ucyBhdCB0aGVzZSBsYW5lc1xuLy8gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIHRyYWNlZCBhY3Jvc3MgY29tcG9uZW50c1xuLy8gdGhhdCBzcGF3biBuZXcgd29yayBkdXJpbmcgcmVuZGVyLiBFLmcuIGhpZGRlbiBib3VuZGFyaWVzLCBzdXNwZW5kZWQgU1NSXG4vLyBoeWRyYXRpb24gb3IgU3VzcGVuc2VMaXN0LlxuLy8gVE9ETzogQ2FuIHVzZSBhIGJpdG1hc2sgaW5zdGVhZCBvZiBhbiBhcnJheVxuXG52YXIgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBudWxsOyAvLyBJZiB0d28gdXBkYXRlcyBhcmUgc2NoZWR1bGVkIHdpdGhpbiB0aGUgc2FtZSBldmVudCwgd2Ugc2hvdWxkIHRyZWF0IHRoZWlyXG4vLyBldmVudCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9jayB0aW1lIGhhcyBhZHZhbmNlZFxuLy8gYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBjYWxsLlxuXG52YXIgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xudmFyIGN1cnJlbnRFdmVudFdpcExhbmVzID0gTm9MYW5lcztcbnZhciBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBOb0xhbmVzOyAvLyBEZXYgb25seSBmbGFnIHRoYXQgdHJhY2tzIGlmIHBhc3NpdmUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGJlaW5nIGZsdXNoZWQuXG4vLyBXZSB3YXJuIGFib3V0IHN0YXRlIHVwZGF0ZXMgZm9yIHVubW91bnRlZCBjb21wb25lbnRzIGRpZmZlcmVudGx5IGluIHRoaXMgY2FzZS5cblxudmFyIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG52YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG4gICAgcmV0dXJuIG5vdygpO1xuICB9IC8vIFdlJ3JlIG5vdCBpbnNpZGUgUmVhY3QsIHNvIHdlIG1heSBiZSBpbiB0aGUgbWlkZGxlIG9mIGEgYnJvd3NlciBldmVudC5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRUaW1lICE9PSBOb1RpbWVzdGFtcCkge1xuICAgIC8vIFVzZSB0aGUgc2FtZSBzdGFydCB0aW1lIGZvciBhbGwgdXBkYXRlcyB1bnRpbCB3ZSBlbnRlciBSZWFjdCBhZ2Fpbi5cbiAgICByZXR1cm4gY3VycmVudEV2ZW50VGltZTtcbiAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgc2luY2UgUmVhY3QgeWllbGRlZC4gQ29tcHV0ZSBhIG5ldyBzdGFydCB0aW1lLlxuXG5cbiAgY3VycmVudEV2ZW50VGltZSA9IG5vdygpO1xuICByZXR1cm4gY3VycmVudEV2ZW50VGltZTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gIC8vIFNwZWNpYWwgY2FzZXNcbiAgdmFyIG1vZGUgPSBmaWJlci5tb2RlO1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkgPT09IEltbWVkaWF0ZVByaW9yaXR5JDEgPyBTeW5jTGFuZSA6IFN5bmNCYXRjaGVkTGFuZTtcbiAgfSAvLyBUaGUgYWxnb3JpdGhtIGZvciBhc3NpZ25pbmcgYW4gdXBkYXRlIHRvIGEgbGFuZSBzaG91bGQgYmUgc3RhYmxlIGZvciBhbGxcbiAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZSBpbnB1dHNcbiAgLy8gdG8gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZSwgd2UgdXNlIHRoZSBgcmVuZGVyTGFuZXNgXG4gIC8vIHRvIGF2b2lkIGNob29zaW5nIGEgbGFuZSB0aGF0IGlzIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIHRoZSBcImluY2x1ZGVkXCIgbGFuZXMgY291bGQgYmUgbXV0YXRlZCBpbiBiZXR3ZWVuIHVwZGF0ZXMgaW4gdGhlXG4gIC8vIHNhbWUgZXZlbnQsIGxpa2UgaWYgeW91IHBlcmZvcm0gYW4gdXBkYXRlIGluc2lkZSBgZmx1c2hTeW5jYC4gT3IgYW55IG90aGVyXG4gIC8vIGNvZGUgcGF0aCB0aGF0IG1pZ2h0IGNhbGwgYHByZXBhcmVGcmVzaFN0YWNrYC5cbiAgLy9cbiAgLy8gVGhlIHRyaWNrIHdlIHVzZSBpcyB0byBjYWNoZSB0aGUgZmlyc3Qgb2YgZWFjaCBvZiB0aGVzZSBpbnB1dHMgd2l0aGluIGFuXG4gIC8vIGV2ZW50LiBUaGVuIHJlc2V0IHRoZSBjYWNoZWQgdmFsdWVzIG9uY2Ugd2UgY2FuIGJlIHN1cmUgdGhlIGV2ZW50IGlzIG92ZXIuXG4gIC8vIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cbiAgLy9cbiAgLy8gV2UnbGwgZG8gdGhlIHNhbWUgZm9yIGBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXNgIGJlbG93LlxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFdpcExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgY3VycmVudEV2ZW50V2lwTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzO1xuICB9XG5cbiAgdmFyIGlzVHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpICE9PSBOb1RyYW5zaXRpb247XG5cbiAgaWYgKGlzVHJhbnNpdGlvbikge1xuICAgIGlmIChjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290ICE9PSBudWxsID8gbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QucGVuZGluZ0xhbmVzIDogTm9MYW5lcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFRyYW5zaXRpb25MYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzLCBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMpO1xuICB9IC8vIFRPRE86IFJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgb24gdGhlIFNjaGVkdWxlciBwcmlvcml0eS5cbiAgLy8gVG8gZG8gdGhhdCwgd2UncmUgcmVwbGFjaW5nIGl0IHdpdGggYW4gdXBkYXRlIGxhbmUgcHJpb3JpdHkuXG5cblxuICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpOyAvLyBUaGUgb2xkIGJlaGF2aW9yIHdhcyB1c2luZyB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIFNjaGVkdWxlci5cbiAgLy8gVGhpcyBjb3VwbGVzIFJlYWN0IHRvIHRoZSBTY2hlZHVsZXIgaW50ZXJuYWxzLCBzbyB3ZSdyZSByZXBsYWNpbmcgaXRcbiAgLy8gd2l0aCB0aGUgY3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eSBhYm92ZS4gQXMgYW4gZXhhbXBsZSBvZiBob3cgdGhpc1xuICAvLyBjb3VsZCBiZSBwcm9ibGVtYXRpYywgaWYgd2UncmUgbm90IGluc2lkZSBgU2NoZWR1bGVyLnJ1bldpdGhQcmlvcml0eWAsXG4gIC8vIHRoZW4gd2UnbGwgZ2V0IHRoZSBwcmlvcml0eSBvZiB0aGUgY3VycmVudCBydW5uaW5nIFNjaGVkdWxlciB0YXNrLFxuICAvLyB3aGljaCBpcyBwcm9iYWJseSBub3Qgd2hhdCB3ZSB3YW50LlxuXG4gIHZhciBsYW5lO1xuXG4gIGlmICggLy8gVE9ETzogVGVtcG9yYXJ5LiBXZSdyZSByZW1vdmluZyB0aGUgY29uY2VwdCBvZiBkaXNjcmV0ZSB1cGRhdGVzLlxuICAoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHNjaGVkdWxlclByaW9yaXR5ID09PSBVc2VyQmxvY2tpbmdQcmlvcml0eSQyKSB7XG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKElucHV0RGlzY3JldGVMYW5lUHJpb3JpdHksIGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyTGFuZVByaW9yaXR5ID0gc2NoZWR1bGVyUHJpb3JpdHlUb0xhbmVQcmlvcml0eShzY2hlZHVsZXJQcmlvcml0eSk7XG5cbiAgICBsYW5lID0gZmluZFVwZGF0ZUxhbmUoc2NoZWR1bGVyTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFJldHJ5TGFuZShmaWJlcikge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgcmVxdWVzdFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIC8vIFNwZWNpYWwgY2FzZXNcbiAgdmFyIG1vZGUgPSBmaWJlci5tb2RlO1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkgPT09IEltbWVkaWF0ZVByaW9yaXR5JDEgPyBTeW5jTGFuZSA6IFN5bmNCYXRjaGVkTGFuZTtcbiAgfSAvLyBTZWUgYHJlcXVlc3RVcGRhdGVMYW5lYCBmb3IgZXhwbGFuYXRpb24gb2YgYGN1cnJlbnRFdmVudFdpcExhbmVzYFxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFdpcExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgY3VycmVudEV2ZW50V2lwTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRSZXRyeUxhbmUoY3VycmVudEV2ZW50V2lwTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSkge1xuICBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKTtcbiAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkRmliZXJJbkRFVihmaWJlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFJlY2VpdmVkIGFuIHVwZGF0ZSB0byBhIHRyZWUgdGhhdCdzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLiBNYXJrXG4gICAgLy8gdGhhdCB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlIHdvcmsgb24gdGhpcyByb290LiBVbmxlc3MgdGhlXG4gICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAvLyBwaGFzZSB1cGRhdGUuIEluIHRoYXQgY2FzZSwgd2UgZG9uJ3QgdHJlYXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXMgaWZcbiAgICAvLyB0aGV5IHdlcmUgaW50ZXJsZWF2ZWQsIGZvciBiYWNrd2FyZHMgY29tcGF0IHJlYXNvbnMuXG4gICAge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMsIGxhbmUpO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgICAvLyBUaGUgcm9vdCBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHdoaWNoIG1lYW5zIHRoaXMgcmVuZGVyXG4gICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgIC8vIHN1c3BlbmRlZCBub3csIHJpZ2h0IGJlZm9yZSBtYXJraW5nIHRoZSBpbmNvbWluZyB1cGRhdGUuIFRoaXMgaGFzIHRoZVxuICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCByZW5kZXIgYW5kIHN3aXRjaGluZyB0byB0aGUgdXBkYXRlLlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgLy8gYWxyZWFkeSBzdGFydGVkIHJlbmRlcmluZy5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiByZXF1ZXN0VXBkYXRlTGFuZVByaW9yaXR5IGFsc28gcmVhZHMgdGhlIHByaW9yaXR5LiBQYXNzIHRoZVxuICAvLyBwcmlvcml0eSBhcyBhbiBhcmd1bWVudCB0byB0aGF0IGZ1bmN0aW9uIGFuZCB0aGlzIG9uZS5cblxuXG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICBpZiAobGFuZSA9PT0gU3luY0xhbmUpIHtcbiAgICBpZiAoIC8vIENoZWNrIGlmIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzXG4gICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBMZWdhY3lVbmJhdGNoZWRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIC8vIENoZWNrIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IHJlbmRlcmluZ1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgLy8gUmVnaXN0ZXIgcGVuZGluZyBpbnRlcmFjdGlvbnMgb24gdGhlIHJvb3QgdG8gYXZvaWQgbG9zaW5nIHRyYWNlZCBpbnRlcmFjdGlvbiBkYXRhLlxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpOyAvLyBUaGlzIGlzIGEgbGVnYWN5IGVkZ2UgY2FzZS4gVGhlIGluaXRpYWwgbW91bnQgb2YgYSBSZWFjdERPTS5yZW5kZXItZWRcbiAgICAgIC8vIHJvb3QgaW5zaWRlIG9mIGJhdGNoZWRVcGRhdGVzIHNob3VsZCBiZSBzeW5jaHJvbm91cywgYnV0IGxheW91dCB1cGRhdGVzXG4gICAgICAvLyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG5cbiAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSk7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIHN5bmNocm9ub3VzIHdvcmsgbm93LCB1bmxlc3Mgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9yIGluc2lkZVxuICAgICAgICAvLyBhIGJhdGNoLiBUaGlzIGlzIGludGVudGlvbmFsbHkgaW5zaWRlIHNjaGVkdWxlVXBkYXRlT25GaWJlciBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgIC8vIHdpdGhvdXQgaW1tZWRpYXRlbHkgZmx1c2hpbmcgaXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdXNlci1pbml0aWF0ZWRcbiAgICAgICAgLy8gdXBkYXRlcywgdG8gcHJlc2VydmUgaGlzdG9yaWNhbCBiZWhhdmlvciBvZiBsZWdhY3kgbW9kZS5cbiAgICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNjaGVkdWxlIGEgZGlzY3JldGUgdXBkYXRlIGJ1dCBvbmx5IGlmIGl0J3Mgbm90IFN5bmMuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgRGlzY3JldGVFdmVudENvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgKCAvLyBPbmx5IHVwZGF0ZXMgYXQgdXNlci1ibG9ja2luZyBwcmlvcml0eSBvciBncmVhdGVyIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gZGlzY3JldGUsIGV2ZW4gaW5zaWRlIGEgZGlzY3JldGUgZXZlbnQuXG4gICAgcHJpb3JpdHlMZXZlbCA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMiB8fCBwcmlvcml0eUxldmVsID09PSBJbW1lZGlhdGVQcmlvcml0eSQxKSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgZXZlbnQuIFRyYWNrIHRoZSBsb3dlc3QgcHJpb3JpdHlcbiAgICAgIC8vIGRpc2NyZXRlIHVwZGF0ZSBwZXIgcm9vdCBzbyB3ZSBjYW4gZmx1c2ggdGhlbSBlYXJseSwgaWYgbmVlZGVkLlxuICAgICAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyA9IG5ldyBTZXQoW3Jvb3RdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuYWRkKHJvb3QpO1xuICAgICAgfVxuICAgIH0gLy8gU2NoZWR1bGUgb3RoZXIgdXBkYXRlcyBhZnRlciBpbiBjYXNlIHRoZSBjYWxsYmFjayBpcyBzeW5jLlxuXG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSk7XG4gIH0gLy8gV2UgdXNlIHRoaXMgd2hlbiBhc3NpZ25pbmcgYSBsYW5lIGZvciBhIHRyYW5zaXRpb24gaW5zaWRlXG4gIC8vIGByZXF1ZXN0VXBkYXRlTGFuZWAuIFdlIGFzc3VtZSBpdCdzIHRoZSBzYW1lIGFzIHRoZSByb290IGJlaW5nIHVwZGF0ZWQsXG4gIC8vIHNpbmNlIGluIHRoZSBjb21tb24gY2FzZSBvZiBhIHNpbmdsZSByb290IGFwcCBpdCBwcm9iYWJseSBpcy4gSWYgaXQncyBub3RcbiAgLy8gdGhlIHNhbWUgcm9vdCwgdGhlbiBpdCdzIG5vdCBhIGh1Z2UgZGVhbCwgd2UganVzdCBtaWdodCBiYXRjaCBtb3JlIHN0dWZmXG4gIC8vIHRvZ2V0aGVyIG1vcmUgdGhhbiBuZWNlc3NhcnkuXG5cblxuICBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IHJvb3Q7XG59IC8vIFRoaXMgaXMgc3BsaXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHdlIGNhbiBtYXJrIGEgZmliZXIgd2l0aCBwZW5kaW5nXG4vLyB3b3JrIHdpdGhvdXQgdHJlYXRpbmcgaXQgYXMgYSB0eXBpY2FsIHVwZGF0ZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBldmVudDtcbi8vIGUuZy4gcmV0cnlpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBpc24ndCBhbiB1cGRhdGUsIGJ1dCBpdCBkb2VzIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGEgZmliZXIuXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG5cbiAge1xuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHNvdXJjZUZpYmVyLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgdmFyIG5vZGUgPSBzb3VyY2VGaWJlcjtcbiAgdmFyIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50LmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudC5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoKHBhcmVudC5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gLy8gVXNlIHRoaXMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSB0YXNrIGZvciBhIHJvb3QuIFRoZXJlJ3Mgb25seSBvbmUgdGFzayBwZXJcbi8vIHJvb3Q7IGlmIGEgdGFzayB3YXMgYWxyZWFkeSBzY2hlZHVsZWQsIHdlJ2xsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgcHJpb3JpdHlcbi8vIG9mIHRoZSBleGlzdGluZyB0YXNrIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmlvcml0eSBvZiB0aGUgbmV4dCBsZXZlbCB0aGF0IHRoZVxuLy8gcm9vdCBoYXMgd29yayBvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgdXBkYXRlLCBhbmQgcmlnaHQgYmVmb3JlXG4vLyBleGl0aW5nIGEgdGFzay5cblxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpOyAvLyBUaGlzIHJldHVybnMgdGhlIHByaW9yaXR5IGxldmVsIGNvbXB1dGVkIGR1cmluZyB0aGUgYGdldE5leHRMYW5lc2AgY2FsbC5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IHJldHVybk5leHRMYW5lc1ByaW9yaXR5KCk7XG5cbiAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPSByb290LmNhbGxiYWNrUHJpb3JpdHk7XG5cbiAgICBpZiAoZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID09PSBuZXdDYWxsYmFja1ByaW9yaXR5KSB7XG4gICAgICAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZSBwcmlvcml0eSBjaGFuZ2VkLiBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ld1xuICAgIC8vIG9uZSBiZWxvdy5cblxuXG4gICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICB9IC8vIFNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuXG5cbiAgdmFyIG5ld0NhbGxiYWNrTm9kZTtcblxuICBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlU3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jQmF0Y2hlZExhbmVQcmlvcml0eSkge1xuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgcGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gbGFuZVByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShuZXdDYWxsYmFja1ByaW9yaXR5KTtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwsIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfVxuXG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbmV3Q2FsbGJhY2tOb2RlO1xufSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgZXZlcnkgY29uY3VycmVudCB0YXNrLCBpLmUuIGFueXRoaW5nIHRoYXRcbi8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5cblxuZnVuY3Rpb24gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KHJvb3QpIHtcbiAgLy8gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBhIFJlYWN0IGV2ZW50LCB3ZSBjYW4gY2xlYXIgdGhlIGN1cnJlbnRcbiAgLy8gZXZlbnQgdGltZS4gVGhlIG5leHQgdXBkYXRlIHdpbGwgY29tcHV0ZSBhIG5ldyBldmVudCB0aW1lLlxuICBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gIGN1cnJlbnRFdmVudFdpcExhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lcztcblxuICBpZiAoISgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIgKTtcbiAgICB9XG4gIH0gLy8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuICAvLyBpbiBjYXNlIHRoZXkgc2NoZWR1bGUgYWRkaXRpb25hbCB3b3JrLlxuXG5cbiAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoZSBwYXNzaXZlIGVmZmVjdCBwaGFzZSBtYXkgaGF2ZSBjYW5jZWxlZCB0aGUgY3VycmVudCB0YXNrLlxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cbiAgICBpZiAocm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0YXNrIHdhcyBjYW5jZWxlZC4gRXhpdC4gV2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAvLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG4gICAgICAvLyB0aGVyZSdzIGEgbmV3IHRhc2ssIG9yIHRoYXQgdGhlcmUncyBubyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGV4cGlyYXRpb24gdGltZSB0byB3b3JrIG9uLCB1c2luZyB0aGUgZmllbGRzIHN0b3JlZFxuICAvLyBvbiB0aGUgcm9vdC5cblxuXG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcyk7XG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkge1xuICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHdoZW4gdW5oaWRpbmcgYSBoaWRkZW4gdHJlZSwgd2UgaW5jbHVkZSBhbGwgdGhlIGxhbmVzXG4gICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgc2tpcHBlZCB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uIFRoYXQgc2V0IG9mXG4gICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAvL1xuICAgIC8vIFNvIHdlJ2xsIHRocm93IG91dCB0aGUgY3VycmVudCB3b3JrIGFuZCByZXN0YXJ0LlxuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICB9IGVsc2UgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RJbmNvbXBsZXRlKSB7XG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJldHJ5QWZ0ZXJFcnJvcjsgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbixcbiAgICAgIC8vIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHNpZGUgcmVuZGVyLlxuXG4gICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgIHJvb3QuaHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgICAgbGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgICAgaWYgKGxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgICAgdGhyb3cgZmF0YWxFcnJvcjtcbiAgICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBUaGUgbmV4dCBzdGVwIGlzIGVpdGhlciB0byBjb21taXQgaXQsXG4gICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsIGV4aXRTdGF0dXMsIGxhbmVzKSB7XG4gIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgIGNhc2UgUm9vdEluY29tcGxldGU6XG4gICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLy8gRmxvdyBrbm93cyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWlucyBpZiBJIGFkZCBhIGJyZWFrXG4gICAgLy8gc3RhdGVtZW50LCBidXQgZXNsaW50IGRvZXNuJ3Qga25vdyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWluc1xuICAgIC8vIGlmIEkgZG8uIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmV0cnkgdGhpcyB0cmVlLiBJZiB3ZSByZWFjaGVkXG4gICAgICAgIC8vIHRoaXMgcG9pbnQsIGl0IGVycm9yZWQgYWdhaW4uIENvbW1pdCBpdC5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpOyAvLyBXZSBoYXZlIGFuIGFjY2VwdGFibGUgbG9hZGluZyBzdGF0ZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHdlXG4gICAgICAgIC8vIHNob3VsZCBpbW1lZGlhdGVseSBjb21taXQgaXQgb3Igd2FpdCBhIGJpdC5cblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykgJiYgLy8gZG8gbm90IGRlbGF5IGlmIHdlJ3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZVxuICAgICAgICAhc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcbiAgICAgICAgICAvLyBUaGlzIHJlbmRlciBvbmx5IGluY2x1ZGVkIHJldHJpZXMsIG5vIHVwZGF0ZXMuIFRocm90dGxlIGNvbW1pdHRpbmdcbiAgICAgICAgICAvLyByZXRyaWVzIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyB0b28gbWFueSBsb2FkaW5nIHN0YXRlcyB0b28gcXVpY2tseS5cbiAgICAgICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3coKTsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cbiAgICAgICAgICBpZiAobXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICAgICAgICAgICAgaWYgKG5leHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgICAgICAvLyBUaGVyZSdzIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICAgICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhzdXNwZW5kZWRMYW5lcywgbGFuZXMpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBwcmVmZXIgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBvZiBhdCB0aGUgbGFzdFxuICAgICAgICAgICAgICAvLyBzdXNwZW5kZWQgbGV2ZWwuIFBpbmcgdGhlIGxhc3Qgc3VzcGVuZGVkIGxldmVsIHRvIHRyeVxuICAgICAgICAgICAgICAvLyByZW5kZXJpbmcgaXQgYWdhaW4uXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIHRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIElkbGU/IFNob3VsZCBub3QgcmVzdGFydC5cbiAgICAgICAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgICAgICAgbWFya1Jvb3RQaW5nZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cblxuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QpLCBtc1VudGlsVGltZW91dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVGhlIHdvcmsgZXhwaXJlZC4gQ29tbWl0IGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdygpIC0gZXZlbnRUaW1lTXM7XG5cbiAgICAgICAgICB2YXIgX21zVW50aWxUaW1lb3V0ID0gam5kKHRpbWVFbGFwc2VkTXMpIC0gdGltZUVsYXBzZWRNczsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cblxuICAgICAgICAgIGlmIChfbXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFjayBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICAvLyB0byBhcnJpdmUuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgY29tcGxldGVkLiBSZWFkeSB0byBjb21taXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgLy8gV2hlbiBzdXNwZW5kaW5nLCB3ZSBzaG91bGQgYWx3YXlzIGV4Y2x1ZGUgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBvciAobW9yZVxuICAvLyByYXJlbHksIHNpbmNlIHdlIHRyeSB0byBhdm9pZCBpdCkgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgLy8gVE9ETzogTG9sIG1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIGZhY3RvciB0aGlzIGJlc2lkZXMgdGhpc1xuICAvLyBvYm5veGlvdXNseSBuYW1lZCBmdW5jdGlvbiA6KVxuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7XG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB2YXIgbGFuZXM7XG4gIHZhciBleGl0U3RhdHVzO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgaW5jbHVkZXNTb21lTGFuZShyb290LmV4cGlyZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpKSB7XG4gICAgLy8gVGhlcmUncyBhIHBhcnRpYWwgdHJlZSwgYW5kIGF0IGxlYXN0IG9uZSBvZiBpdHMgbGFuZXMgaGFzIGV4cGlyZWQuIEZpbmlzaFxuICAgIC8vIHJlbmRlcmluZyBpdCBiZWZvcmUgcmVuZGVyaW5nIHRoZSByZXN0IG9mIHRoZSBleHBpcmVkIHdvcmsuXG4gICAgbGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gICAgaWYgKGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkge1xuICAgICAgLy8gVGhlIHJlbmRlciBpbmNsdWRlZCBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgc2tpcHBlZCB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uIFRoYXQgc2V0IG9mXG4gICAgICAvLyBsYW5lcyBpcyBhIHN1cGVyc2V0IG9mIHRoZSBsYW5lcyB3ZSBzdGFydGVkIHJlbmRlcmluZyB3aXRoLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG9ubHkgaGFwcGVucyB3aGVuIHBhcnQgb2YgdGhlIHRyZWUgaXMgcmVuZGVyZWRcbiAgICAgIC8vIGNvbmN1cnJlbnRseS4gSWYgdGhlIHdob2xlIHRyZWUgaXMgcmVuZGVyZWQgc3luY2hyb25vdXNseSwgdGhlbiB0aGVyZVxuICAgICAgLy8gYXJlIG5vIGludGVybGVhdmVkIGV2ZW50cy5cbiAgICAgIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIGxhbmVzKTtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gIH1cblxuICBpZiAocm9vdC50YWcgIT09IExlZ2FjeVJvb3QgJiYgZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IFJldHJ5QWZ0ZXJFcnJvcjsgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbixcbiAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgIHJvb3QuaHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICB9IC8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbCByZW5kZXJcbiAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgLy8gYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cblxuXG4gICAgbGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QpOyAvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4gIC8vIHBlbmRpbmcgbGV2ZWwuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlcygpIHtcbiAgLy8gVE9ETzogU2hvdWxkIGJlIGFibGUgdG8gZmx1c2ggaW5zaWRlIGJhdGNoZWRVcGRhdGVzLCBidXQgbm90IGluc2lkZSBgYWN0YC5cbiAgLy8gSG93ZXZlciwgYGFjdGAgdXNlcyBgYmF0Y2hlZFVwZGF0ZXNgLCBzbyB0aGVyZSdzIG5vIHdheSB0byBkaXN0aW5ndWlzaFxuICAvLyB0aG9zZSB0d28gY2FzZXMuIE5lZWQgdG8gZml4IHRoaXMgYmVmb3JlIGV4cG9zaW5nIGZsdXNoRGlzY3JldGVVcGRhdGVzXG4gIC8vIGFzIGEgcHVibGljIEFQSS5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKEJhdGNoZWRDb250ZXh0IHwgUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuICAgICAgICBlcnJvcigndW5zdGFibGVfZmx1c2hEaXNjcmV0ZVVwZGF0ZXM6IENhbm5vdCBmbHVzaCB1cGRhdGVzIHdoZW4gUmVhY3QgaXMgJyArICdhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgICAgIH1cbiAgICB9IC8vIFdlJ3JlIGFscmVhZHkgcmVuZGVyaW5nLCBzbyB3ZSBjYW4ndCBzeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgd29yay5cbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmVzdGVkIGV2ZW50IGRpc3BhdGNoIHRyaWdnZXJlZCBieSBhIGxpZmVjeWNsZS9lZmZlY3QsXG4gICAgLy8gbGlrZSBgZWwuZm9jdXMoKWAuIEV4aXQuXG5cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpOyAvLyBJZiB0aGUgZGlzY3JldGUgdXBkYXRlcyBzY2hlZHVsZWQgcGFzc2l2ZSBlZmZlY3RzLCBmbHVzaCB0aGVtIG5vdyBzbyB0aGF0XG4gIC8vIHRoZXkgZmlyZSBiZWZvcmUgdGhlIG5leHQgc2VyaWFsIGV2ZW50LlxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hQZW5kaW5nRGlzY3JldGVVcGRhdGVzKCkge1xuICBpZiAocm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgIC8vIEZvciBlYWNoIHJvb3Qgd2l0aCBwZW5kaW5nIGRpc2NyZXRlIHVwZGF0ZXMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG9cbiAgICAvLyBpbW1lZGlhdGVseSBmbHVzaCB0aGVtLlxuICAgIHZhciByb290cyA9IHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXM7XG4gICAgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyA9IG51bGw7XG4gICAgcm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgbWFya0Rpc2NyZXRlVXBkYXRlc0V4cGlyZWQocm9vdCk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgIH0pO1xuICB9IC8vIE5vdyBmbHVzaCB0aGUgaW1tZWRpYXRlIHF1ZXVlLlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCkge1xuICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gRXZlbnRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyQxKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gRGlzY3JldGVFdmVudENvbnRleHQ7XG5cbiAge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoVXNlckJsb2NraW5nUHJpb3JpdHkkMiwgZm4uYmluZChudWxsLCBhLCBiLCBjLCBkKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCkge1xuICAgICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0ICY9IH5CYXRjaGVkQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBMZWdhY3lVbmJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuXG4gIGlmICgocHJldkV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAge1xuICAgICAgZXJyb3IoJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gUmVhY3QgY2Fubm90ICcgKyAnZmx1c2ggd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgY2FsbCB0byAnICsgJ2Egc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oYSk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJldHVybiBydW5XaXRoUHJpb3JpdHkkMShJbW1lZGlhdGVQcmlvcml0eSQxLCBmbi5iaW5kKG51bGwsIGEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4gICAgICAvLyB0aGUgc3RhY2suXG5cbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgZG8ge1xuICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlc2V0IG1vZHVsZS1sZXZlbCBzdGF0ZSB0aGF0IHdhcyBzZXQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NBZnRlclRocm93KCk7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBJIGZvdW5kIGFuZCBhZGRlZCB0aGlzIG1pc3NpbmcgbGluZSB3aGlsZSBpbnZlc3RpZ2F0aW5nIGFcbiAgICAgIC8vIHNlcGFyYXRlIGlzc3VlLiBXcml0ZSBhIHJlZ3Jlc3Npb24gdGVzdCB1c2luZyBzdHJpbmcgcmVmcy5cblxuICAgICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaWYgKGVycm9yZWRXb3JrID09PSBudWxsIHx8IGVycm9yZWRXb3JrLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSB3b3JraW5nIG9uIGEgbm9uLXJvb3QgZmliZXIuIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIGl0OyB0aGUgcm9vdCBpc1xuICAgICAgICAvLyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0IGNhdWdodCBieSBhbiBlcnJvclxuICAgICAgICAvLyBib3VuZGFyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSB0aHJvd25WYWx1ZTsgLy8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuICAgICAgICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4gICAgICAgIC8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbiAgICAgICAgLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuICAgICAgICAvLyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAvLyBzdXNwZW5kZWQgcmVuZGVyLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFeGNlcHRpb24ocm9vdCwgZXJyb3JlZFdvcmsucmV0dXJuLCBlcnJvcmVkV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhlcnJvcmVkV29yayk7XG4gICAgfSBjYXRjaCAoeWV0QW5vdGhlclRocm93blZhbHVlKSB7XG4gICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHJldHVybiBwYXRoIGFsc28gdGhyZXcuXG4gICAgICB0aHJvd25WYWx1ZSA9IHlldEFub3RoZXJUaHJvd25WYWx1ZTtcblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzID09PSBlcnJvcmVkV29yayAmJiBlcnJvcmVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGhhcyBhbHJlYWR5IGVycm9yZWQsIHRoZW4gd2UgaGFkIHRyb3VibGUgcHJvY2Vzc2luZ1xuICAgICAgICAvLyB0aGUgZXJyb3IuIEJ1YmJsZSBpdCB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgICAgZXJyb3JlZFdvcmsgPSBlcnJvcmVkV29yay5yZXR1cm47XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gZXJyb3JlZFdvcms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFJldHVybiB0byB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cblxuXG4gICAgcmV0dXJuO1xuICB9IHdoaWxlICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAocHJldkRpc3BhdGNoZXIgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgUmVhY3QgaXNvbW9ycGhpYyBwYWNrYWdlIGRvZXMgbm90IGluY2x1ZGUgYSBkZWZhdWx0IGRpc3BhdGNoZXIuXG4gICAgLy8gSW5zdGVhZCB0aGUgZmlyc3QgcmVuZGVyZXIgd2lsbCBsYXppbHkgYXR0YWNoIG9uZSwgaW4gb3JkZXIgdG8gZ2l2ZVxuICAgIC8vIG5pY2VyIGVycm9yIG1lc3NhZ2VzLlxuICAgIHJldHVybiBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZEaXNwYXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpIHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcHVzaEludGVyYWN0aW9ucyhyb290KSB7XG4gIHtcbiAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICAgIHJldHVybiBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKSB7XG4gIHtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdygpO1xufVxuZnVuY3Rpb24gbWFya1NraXBwZWRVcGRhdGVMYW5lcyhsYW5lKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IG1lcmdlTGFuZXMobGFuZSwgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbiAgLy8gdGhpcyByZW5kZXIuXG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgfHwgaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpKSkge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4gICAgLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbiAgICAvLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuICAgIC8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxuICAgIG1hcmtSb290U3VzcGVuZGVkJDEod29ya0luUHJvZ3Jlc3NSb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdENvbXBsZXRlZCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgc3RhcnRXb3JrT25QZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTtcblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuXG4gIHtcbiAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW5jIHJlbmRlciwgc28gd2Ugc2hvdWxkIGhhdmUgZmluaXNoZWQgdGhlIHdob2xlIHRyZWUuXG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIFJvb3RJbmNvbXBsZXRlO1xuICB9IGVsc2Uge1xuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNldENoaWxkTGFuZXMoY29tcGxldGVkV29yayk7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCAmJiAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAocmV0dXJuRmliZXIuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3Q7XG4gICAgICAgIH0gLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmIG5lZWRlZCxcbiAgICAgICAgLy8gYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cblxuXG4gICAgICAgIHZhciBmbGFncyA9IGNvbXBsZXRlZFdvcmsuZmxhZ3M7IC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdC4gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlXG4gICAgICAgIC8vIGNvbW1pdHRlZC5cblxuICAgICAgICBpZiAoZmxhZ3MgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG5cblxuICAgICAgaWYgKF9uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICAgIF9uZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IF9uZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgZWZmZWN0IGxpc3QuXG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspIHtcbiAgaWYgKCAvLyBUT0RPOiBNb3ZlIHRoaXMgY2hlY2sgb3V0IG9mIHRoZSBob3QgcGF0aCBieSBtb3ZpbmcgYHJlc2V0Q2hpbGRMYW5lc2BcbiAgLy8gdG8gc3dpdGNoIHN0YXRlbWVudCBpbiBgY29tcGxldGVXb3JrYC5cbiAgKGNvbXBsZXRlZFdvcmsudGFnID09PSBMZWdhY3lIaWRkZW5Db21wb25lbnQgfHwgY29tcGxldGVkV29yay50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkgJiYgY29tcGxldGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmICFpbmNsdWRlc1NvbWVMYW5lKHN1YnRyZWVSZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkgJiYgKGNvbXBsZXRlZFdvcmsubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9MYW5lcykge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZExhbmVzID0gTm9MYW5lczsgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG5cbiAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgLy8gb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAvLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uIElmXG4gICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgIC8vIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXNcbiAgICAvLyByZW5kZXIuIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS4gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzXG4gICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgIHZhciBzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCB8fCBjb21wbGV0ZWRXb3JrLmNoaWxkICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZDtcbiAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKGNoaWxkLmxhbmVzLCBjaGlsZC5jaGlsZExhbmVzKSk7XG5cbiAgICAgIGlmIChzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMpIHtcbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gY29tcGxldGVkV29yay50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgaWYgKHByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2NoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChfY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290KSB7XG4gIHZhciByZW5kZXJQcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcbiAgcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgY29tbWl0Um9vdEltcGwuYmluZChudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290SW1wbChyb290LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoISgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gIHZhciBsYW5lcyA9IHJvb3QuZmluaXNoZWRMYW5lcztcblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcblxuICBpZiAoIShmaW5pc2hlZFdvcmsgIT09IHJvb3QuY3VycmVudCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsOyAvLyBVcGRhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IHBlbmRpbmcgdGltZXMgb24gdGhpcyByb290LiBUaGUgbmV3IGZpcnN0XG4gIC8vIHBlbmRpbmcgdGltZSBpcyB3aGF0ZXZlciBpcyBsZWZ0IG9uIHRoZSByb290IGZpYmVyLlxuXG4gIHZhciByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7XG4gIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpOyAvLyBDbGVhciBhbHJlYWR5IGZpbmlzaGVkIGRpc2NyZXRlIHVwZGF0ZXMgaW4gY2FzZSB0aGF0IGEgbGF0ZXIgY2FsbCBvZlxuICAvLyBgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNgIHN0YXJ0cyBhIHVzZWxlc3MgcmVuZGVyIHBhc3Mgd2hpY2ggbWF5IGNhbmNlbHNcbiAgLy8gYSBzY2hlZHVsZWQgdGltZW91dC5cblxuICBpZiAocm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgIGlmICghaGFzRGlzY3JldGVMYW5lcyhyZW1haW5pbmdMYW5lcykgJiYgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcy5oYXMocm9vdCkpIHtcbiAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuZGVsZXRlKHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBXZSBjYW4gcmVzZXQgdGhlc2Ugbm93IHRoYXQgdGhleSBhcmUgZmluaXNoZWQuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICB9IC8vIEdldCB0aGUgbGlzdCBvZiBlZmZlY3RzLlxuXG5cbiAgdmFyIGZpcnN0RWZmZWN0O1xuXG4gIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmIGl0XG4gICAgLy8gaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgfVxuXG4gIGlmIChmaXJzdEVmZmVjdCAhPT0gbnVsbCkge1xuXG4gICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpOyAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDsgLy8gVGhlIGNvbW1pdCBwaGFzZSBpcyBicm9rZW4gaW50byBzZXZlcmFsIHN1Yi1waGFzZXMuIFdlIGRvIGEgc2VwYXJhdGUgcGFzc1xuICAgIC8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG4gICAgLy8gbGF5b3V0IGVmZmVjdHMsIGFuZCBzbyBvbi5cbiAgICAvLyBUaGUgZmlyc3QgcGhhc2UgYSBcImJlZm9yZSBtdXRhdGlvblwiIHBoYXNlLiBXZSB1c2UgdGhpcyBwaGFzZSB0byByZWFkIHRoZVxuICAgIC8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuICAgIC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGlzIGNhbGxlZC5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuXG4gICAgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpc1xuICAgICAgLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfSAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbXV0YXRpb24gcGhhc2UsIHdoZXJlIHdlIG11dGF0ZSB0aGUgaG9zdCB0cmVlLlxuXG5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRNdXRhdGlvbkVmZmVjdHMsIG51bGwsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcbiAgICAvLyB0aGUgaG9zdCB0cmVlIGFmdGVyIGl0J3MgYmVlbiBtdXRhdGVkLiBUaGUgaWRpb21hdGljIHVzZSBjYXNlIGZvciB0aGlzIGlzXG4gICAgLy8gbGF5b3V0LCBidXQgY2xhc3MgY29tcG9uZW50IGxpZmVjeWNsZXMgYWxzbyBmaXJlIGhlcmUgZm9yIGxlZ2FjeSByZWFzb25zLlxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TGF5b3V0RWZmZWN0cywgbnVsbCwgcm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCk7XG5cbiAgICBuZXh0RWZmZWN0ID0gbnVsbDsgLy8gVGVsbCBTY2hlZHVsZXIgdG8geWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUsIHNvIHRoZSBicm93c2VyIGhhcyBhblxuICAgIC8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG5cbiAgICB7XG4gICAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gICAgfVxuXG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSByZW5kZXJQcmlvcml0eUxldmVsO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFyZSBkb25lIHdpdGggdGhlIGVmZmVjdCBjaGFpbiBhdCB0aGlzIHBvaW50IHNvIGxldCdzIGNsZWFyIHRoZVxuICAgIC8vIG5leHRFZmZlY3QgcG9pbnRlcnMgdG8gYXNzaXN0IHdpdGggR0MuIElmIHdlIGhhdmUgcGFzc2l2ZSBlZmZlY3RzLCB3ZSdsbFxuICAgIC8vIGNsZWFyIHRoaXMgaW4gZmx1c2hQYXNzaXZlRWZmZWN0cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHROZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICAgICAgaWYgKG5leHRFZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikge1xuICAgICAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgbmV4dEVmZmVjdCA9IG5leHROZXh0RWZmZWN0O1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG5cbiAgaWYgKHJlbWFpbmluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBleHBpcmF0aW9uVGltZXMgPSBzcGF3bmVkV29ya0R1cmluZ1JlbmRlcjtcbiAgICAgICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwaXJhdGlvblRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgZXhwaXJhdGlvblRpbWVzW2ldLCByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICghcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhc3NpdmUgZWZmZWN0cywgdGhlbiB3ZSBjYW4gY29tcGxldGUgdGhlIHBlbmRpbmcgaW50ZXJhY3Rpb25zLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCB3YWl0IHVudGlsIGFmdGVyIHRoZSBwYXNzaXZlIGVmZmVjdHMgYXJlIGZsdXNoZWQuXG4gICAgICAvLyBXYWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgcmVtYWluaW5nIHdvcmsgaGFzIGJlZW4gc2NoZWR1bGVkLFxuICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBwcmVtYXR1cmVseSBzaWduYWwgY29tcGxldGUgZm9yIGludGVyYWN0aW9ucyB3aGVuIHRoZXJlJ3MgZS5nLiBoaWRkZW4gd29yay5cbiAgICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gU3luY0xhbmUpIHtcbiAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cbiAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cblxuICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG5cbiAge1xuICAgIG9uQ29tbWl0Um9vdCQxKCk7XG4gIH0gLy8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuICAvLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cblxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cbiAgaWYgKGhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgICB0aHJvdyBfZXJyb3IzO1xuICB9XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIGEgUmVhY3RET00ucmVuZGVyLWVkIHJvb3QgaW5zaWRlIG9mIGJhdGNoZWRVcGRhdGVzLiBUaGUgY29tbWl0IGZpcmVkXG4gICAgLy8gc3luY2hyb25vdXNseSwgYnV0IGxheW91dCB1cGRhdGVzIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIGJhdGNoLlxuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBJZiBsYXlvdXQgd29yayB3YXMgc2NoZWR1bGVkLCBmbHVzaCBpdCBub3cuXG5cblxuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgJiYgZm9jdXNlZEluc3RhbmNlSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICBpZiAoKG5leHRFZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgaWYgKGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgdGhlIGhvdCBwYXRoIHVzaW5nIGEgZGVkaWNhdGVkIGVmZmVjdCB0YWcuXG4gICAgICAgIGlmIChuZXh0RWZmZWN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgaXNTdXNwZW5zZUJvdW5kYXJ5QmVpbmdIaWRkZW4oY3VycmVudCwgbmV4dEVmZmVjdCkgJiYgZG9lc0ZpYmVyQ29udGFpbihuZXh0RWZmZWN0LCBmb2N1c2VkSW5zdGFuY2VIYW5kbGUpKSB7XG4gICAgICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBmbHVzaCBhdFxuICAgICAgLy8gdGhlIGVhcmxpZXN0IG9wcG9ydHVuaXR5LlxuICAgICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICAvLyBUT0RPOiBTaG91bGQgcHJvYmFibHkgbW92ZSB0aGUgYnVsayBvZiB0aGlzIGZ1bmN0aW9uIHRvIGNvbW1pdFdvcmsuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnkgcG9zc2libGVcbiAgICAvLyBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGUgZWZmZWN0IHRhZyBhbmRcbiAgICAvLyBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cblxuXG4gICAgdmFyIHByaW1hcnlGbGFncyA9IGZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uIHwgSHlkcmF0aW5nKTtcblxuICAgIHN3aXRjaCAocHJpbWFyeUZsYWdzKSB7XG4gICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWQgZG9lc1xuICAgICAgICAgIC8vIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGUgdG8ga2lsbCB0aGlzLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpOyAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgICAgICAgIC8vIGluc2VydGVkLCBiZWZvcmUgYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG5cbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5QbGFjZW1lbnQ7IC8vIFVwZGF0ZVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIeWRyYXRpbmc6XG4gICAgICAgIHtcbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5IeWRyYXRpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIeWRyYXRpbmdBbmRVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5IeWRyYXRpbmc7IC8vIFVwZGF0ZVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfY3VycmVudDMgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MywgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uKHJvb3QsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMocm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblxuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoZmxhZ3MgJiAoVXBkYXRlIHwgQ2FsbGJhY2spKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0TGlmZUN5Y2xlcyhyb290LCBjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbiAgaWYgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ICE9PSBOb1ByaW9yaXR5JDEpIHtcbiAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eTtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcblxuICAgIHtcbiAgICAgIHJldHVybiBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsLCBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpYmVyLCBlZmZlY3QpIHtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50LnB1c2goZWZmZWN0LCBmaWJlcik7XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNVbm1vdW50LnB1c2goZWZmZWN0LCBmaWJlcik7XG5cbiAge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmZsYWdzIHw9IFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlUGFzc2l2ZUVmZmVjdENyZWF0ZShlZmZlY3QpIHtcbiAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gIGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCkge1xuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzO1xuICB2YXIgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpOyAvLyBJdCdzIGltcG9ydGFudCB0aGF0IEFMTCBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0IGRlc3Ryb3kgZnVuY3Rpb25zIGFyZSBjYWxsZWRcbiAgLy8gYmVmb3JlIEFOWSBwYXNzaXZlIGVmZmVjdCBjcmVhdGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQuXG4gIC8vIE90aGVyd2lzZSBlZmZlY3RzIGluIHNpYmxpbmcgY29tcG9uZW50cyBtaWdodCBpbnRlcmZlcmUgd2l0aCBlYWNoIG90aGVyLlxuICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IG1heSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGUgYSByZWZcbiAgLy8gdmFsdWUgc2V0IGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50LlxuICAvLyBMYXlvdXQgZWZmZWN0cyBoYXZlIHRoZSBzYW1lIGNvbnN0cmFpbnQuXG4gIC8vIEZpcnN0IHBhc3M6IERlc3Ryb3kgc3RhbGUgcGFzc2l2ZSBlZmZlY3RzLlxuXG4gIHZhciB1bm1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNVbm1vdW50O1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudEVmZmVjdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdCA9IHVubW91bnRFZmZlY3RzW2ldO1xuICAgIHZhciBmaWJlciA9IHVubW91bnRFZmZlY3RzW2kgKyAxXTtcbiAgICB2YXIgZGVzdHJveSA9IF9lZmZlY3QuZGVzdHJveTtcbiAgICBfZWZmZWN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgICB7XG4gICAgICBmaWJlci5mbGFncyAmPSB+UGFzc2l2ZVVubW91bnRQZW5kaW5nRGV2O1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGRlc3Ryb3ksIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBpZiAoIShmaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTZWNvbmQgcGFzczogQ3JlYXRlIG5ldyBwYXNzaXZlIGVmZmVjdHMuXG5cblxuICB2YXIgbW91bnRFZmZlY3RzID0gcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50O1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzTW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW91bnRFZmZlY3RzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgIHZhciBfZWZmZWN0MiA9IG1vdW50RWZmZWN0c1tfaV07XG4gICAgdmFyIF9maWJlciA9IG1vdW50RWZmZWN0c1tfaSArIDFdO1xuXG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKF9maWJlcik7XG5cbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUsIG51bGwsIF9lZmZlY3QyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgaWYgKCEoX2ZpYmVyICE9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZXJyb3I0ID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKF9maWJlciwgX2Vycm9yNCk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9IC8vIE5vdGU6IFRoaXMgY3VycmVudGx5IGFzc3VtZXMgdGhlcmUgYXJlIG5vIHBhc3NpdmUgZWZmZWN0cyBvbiB0aGUgcm9vdCBmaWJlclxuICAvLyBiZWNhdXNlIHRoZSByb290IGlzIG5vdCBwYXJ0IG9mIGl0cyBvd24gZWZmZWN0IGxpc3QuXG4gIC8vIFRoaXMgY291bGQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cblxuICB2YXIgZWZmZWN0ID0gcm9vdC5jdXJyZW50LmZpcnN0RWZmZWN0O1xuXG4gIHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dE5leHRFZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDsgLy8gUmVtb3ZlIG5leHRFZmZlY3QgcG9pbnRlciB0byBhc3Npc3QgR0NcblxuICAgIGVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICAgIGlmIChlZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikge1xuICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZWZmZWN0KTtcbiAgICB9XG5cbiAgICBlZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gICAgZmluaXNoUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTsgLy8gSWYgYWRkaXRpb25hbCBwYXNzaXZlIGVmZmVjdHMgd2VyZSBzY2hlZHVsZWQsIGluY3JlbWVudCBhIGNvdW50ZXIuIElmIHRoaXNcbiAgLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuXG4gIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsID8gMCA6IG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCArIDE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgaWYgKCFoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IHRydWU7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxudmFyIG9uVW5jYXVnaHRFcnJvciA9IHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcjtcblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIsIGVycm9ySW5mbywgU3luY0xhbmUpO1xuICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlKTtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChyb290RmliZXIsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBTeW5jTGFuZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQuXG4gICAgICAgICAgLy8gV2UgY2FuJ3Qgc2NoZWR1bGUgYW55IGZvbGxvdyB1cCB3b3JrIGZvciB0aGUgcm9vdCBiZWNhdXNlIHRoZSBmaWJlciBpcyBhbHJlYWR5IHVubW91bnRlZCxcbiAgICAgICAgICAvLyBidXQgd2UgY2FuIHN0aWxsIGNhbGwgdGhlIGxvZy1vbmx5IGJvdW5kYXJ5IHNvIHRoZSBlcnJvciBpc24ndCBzd2FsbG93ZWQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPIFRoaXMgaXMgb25seSBhIHRlbXBvcmFyeSBiYW5kYWlkIGZvciB0aGUgb2xkIHJlY29uY2lsZXIgZm9yay5cbiAgICAgICAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc3BlY2lhbCBjYXNlIG9uY2UgdGhlIG5ldyBmb3JrIGlzIG1lcmdlZC5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvclRvSWdub3JlKSB7Ly8gVE9ETyBJZ25vcmUgdGhpcyBlcnJvcj8gUmV0aHJvdyBpdD9cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGFuIGVkZ2UgY2FzZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiYgaXNTdWJzZXRPZkxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBwaW5nZWRMYW5lcykpIHtcbiAgICAvLyBSZWNlaXZlZCBhIHBpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5XG4gICAgLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuICAgIC8vIHRoZSBsb2dpYyBvZiB3aGV0aGVyIG9yIG5vdCBhIHJvb3Qgc3VzcGVuZHMgb25jZSBpdCBjb21wbGV0ZXMuXG4gICAgLy8gVE9ETzogSWYgd2UncmUgcmVuZGVyaW5nIHN5bmMgZWl0aGVyIGR1ZSB0byBTeW5jLCBCYXRjaGVkIG9yIGV4cGlyZWQsXG4gICAgLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG4gICAgLy8gSWYgd2UncmUgc3VzcGVuZGVkIHdpdGggZGVsYXksIG9yIGlmIGl0J3MgYSByZXRyeSwgd2UnbGwgYWx3YXlzIHN1c3BlbmRcbiAgICAvLyBzbyB3ZSBjYW4gYWx3YXlzIHJlc3RhcnQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJiBpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSAmJiBub3coKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHBpbmdlZExhbmVzKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgaWYgKHJldHJ5TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgcmV0cnlMYW5lID0gcmVxdWVzdFJldHJ5TGFuZShib3VuZGFyeUZpYmVyKTtcbiAgfSAvLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cblxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCByZXRyeUxhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJldHJ5TGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7IC8vIERlZmF1bHRcblxuICB2YXIgcmV0cnlDYWNoZTtcblxuICB7XG4gICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgaWYgKHJldHJ5Q2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn0gLy8gQ29tcHV0ZXMgdGhlIG5leHQgSnVzdCBOb3RpY2VhYmxlIERpZmZlcmVuY2UgKEpORCkgYm91bmRhcnkuXG4vLyBUaGUgdGhlb3J5IGlzIHRoYXQgYSBwZXJzb24gY2FuJ3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuXG4vLyBUaGVyZWZvcmUsIGlmIHdlIHdhaXQgYSBiaXQgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5IHRoYXQgd29uJ3QgdHJhbnNsYXRlIHRvIGEgbm90aWNlYWJsZVxuLy8gZGlmZmVyZW5jZSBpbiB0aGUgZXhwZXJpZW5jZS4gSG93ZXZlciwgd2FpdGluZyBmb3IgbG9uZ2VyIG1pZ2h0IG1lYW4gdGhhdCB3ZSBjYW4gYXZvaWRcbi8vIHNob3dpbmcgYW4gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFRoZSBsb25nZXIgd2UgaGF2ZSBhbHJlYWR5IHdhaXRlZCwgdGhlIGhhcmRlciBpdFxuLy8gaXMgdG8gdGVsbCBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLiBUaGVyZWZvcmUsIHRoZSBsb25nZXIgd2UndmUgYWxyZWFkeSB3YWl0ZWQsXG4vLyB0aGUgbG9uZ2VyIHdlIGNhbiB3YWl0IGFkZGl0aW9uYWxseS4gQXQgc29tZSBwb2ludCB3ZSBoYXZlIHRvIGdpdmUgdXAgdGhvdWdoLlxuLy8gV2UgcGljayBhIHRyYWluIG1vZGVsIHdoZXJlIHRoZSBuZXh0IGJvdW5kYXJ5IGNvbW1pdHMgYXQgYSBjb25zaXN0ZW50IHNjaGVkdWxlLlxuLy8gVGhlc2UgcGFydGljdWxhciBudW1iZXJzIGFyZSB2YWd1ZSBlc3RpbWF0ZXMuIFdlIGV4cGVjdCB0byBhZGp1c3QgdGhlbSBiYXNlZCBvbiByZXNlYXJjaC5cblxuZnVuY3Rpb24gam5kKHRpbWVFbGFwc2VkKSB7XG4gIHJldHVybiB0aW1lRWxhcHNlZCA8IDEyMCA/IDEyMCA6IHRpbWVFbGFwc2VkIDwgNDgwID8gNDgwIDogdGltZUVsYXBzZWQgPCAxMDgwID8gMTA4MCA6IHRpbWVFbGFwc2VkIDwgMTkyMCA/IDE5MjAgOiB0aW1lRWxhcHNlZCA8IDMwMDAgPyAzMDAwIDogdGltZUVsYXBzZWQgPCA0MzIwID8gNDMyMCA6IGNlaWwodGltZUVsYXBzZWQgLyAxOTYwKSAqIDE5NjA7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yTmVzdGVkVXBkYXRlcygpIHtcbiAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCkge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblxuICAgICAgZXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgXCJjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IFwiICsgJ2hhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uICcgKyAnZXZlcnkgcmVuZGVyLicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKSB7XG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFdlIGxldCB0aGUgb3RoZXIgd2FybmluZyBhYm91dCByZW5kZXIgcGhhc2UgdXBkYXRlcyBkZWFsIHdpdGggdGhpcyBvbmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEoZmliZXIubW9kZSAmIChCbG9ja2luZ01vZGUgfCBDb25jdXJyZW50TW9kZSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmICh0YWcgIT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgJiYgdGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW2NvbXBvbmVudE5hbWVdKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IG1vdW50ZWQgeWV0LiBcIiArICdUaGlzIGluZGljYXRlcyB0aGF0IHlvdSBoYXZlIGEgc2lkZS1lZmZlY3QgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gdGhhdCAnICsgJ2FzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byAnICsgJ3VzZUVmZmVjdCBpbnN0ZWFkLicpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkRmliZXJJbkRFVihmaWJlcikge1xuICB7XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmICh0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IEJsb2NrKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gZm9yIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLCBub3QgaW50ZXJuYWwgb25lcyBsaWtlIFN1c3BlbnNlLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIHVubW91bnRzIGZvciB0aGlzIEZpYmVyLFxuICAgIC8vIHdlIGNhbiBhc3N1bWUgdGhhdCB0aGV5IHdvdWxkIGhhdmUgcHJldmVudGVkIHRoaXMgdXBkYXRlLlxuXG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZVVubW91bnRQZW5kaW5nRGV2KSAhPT0gTm9GbGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG5cblxuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnUmVhY3RDb21wb25lbnQnO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cykgOyBlbHNlIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgICBlcnJvcihcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluICVzLicsIHRhZyA9PT0gQ2xhc3NDb21wb25lbnQgPyAndGhlIGNvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZCcgOiAnYSB1c2VFZmZlY3QgY2xlYW51cCBmdW5jdGlvbicpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGJlZ2luV29yayQxO1xuXG57XG4gIHZhciBkdW1teUZpYmVyID0gbnVsbDtcblxuICBiZWdpbldvcmskMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IHRocm93cyBhbiBlcnJvciwgd2UgcmVwbGF5IGl0IGFnYWluIGluIGEgc3luY2hyb25vdXNseVxuICAgIC8vIGRpc3BhdGNoZWQgZXZlbnQsIHNvIHRoYXQgdGhlIGRlYnVnZ2VyIHdpbGwgdHJlYXQgaXQgYXMgYW4gdW5jYXVnaHRcbiAgICAvLyBlcnJvciBTZWUgUmVhY3RFcnJvclV0aWxzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgIC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNvcHkgdGhlIHdvcmstaW4tcHJvZ3Jlc3Mgb250byBhIGR1bW15XG4gICAgLy8gZmliZXIuIElmIGJlZ2luV29yayB0aHJvd3MsIHdlJ2xsIHVzZSB0aGlzIHRvIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICB2YXIgb3JpZ2luYWxXb3JrSW5Qcm9ncmVzc0NvcHkgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihkdW1teUZpYmVyLCB1bml0T2ZXb3JrKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGxhbmVzKTtcbiAgICB9IGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICBpZiAob3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfSAvLyBLZWVwIHRoaXMgY29kZSBpbiBzeW5jIHdpdGggaGFuZGxlRXJyb3I7IGFueSBjaGFuZ2VzIGhlcmUgbXVzdCBoYXZlXG4gICAgICAvLyBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdGhlcmUuXG5cblxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpOyAvLyBEb24ndCByZXNldCBjdXJyZW50IGRlYnVnIGZpYmVyLCBzaW5jZSB3ZSdyZSBhYm91dCB0byB3b3JrIG9uIHRoZVxuICAgICAgLy8gc2FtZSBmaWJlciBhZ2Fpbi5cbiAgICAgIC8vIFVud2luZCB0aGUgZmFpbGVkIHN0YWNrIGZyYW1lXG5cbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayh1bml0T2ZXb3JrKTsgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvcGVydGllcyBvZiB0aGUgZmliZXIuXG5cbiAgICAgIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHVuaXRPZldvcmssIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5KTtcblxuICAgICAgaWYgKCB1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgcHJvZmlsZXIgdGltZXIuXG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgICAgIH0gLy8gUnVuIGJlZ2luV29yayBhZ2Fpbi5cblxuXG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgYmVnaW5Xb3JrLCBudWxsLCBjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTsgLy8gYGludm9rZUd1YXJkZWRDYWxsYmFja2Agc29tZXRpbWVzIHNldHMgYW4gZXhwYW5kbyBgX3N1cHByZXNzTG9nZ2luZ2AuXG4gICAgICAgIC8vIFJldGhyb3cgdGhpcyBlcnJvciBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBvbmUuXG5cbiAgICAgICAgdGhyb3cgcmVwbGF5RXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGJyYW5jaCBpcyByZWFjaGFibGUgaWYgdGhlIHJlbmRlciBwaGFzZSBpcyBpbXB1cmUuXG4gICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ7XG5cbntcbiAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50ID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcikge1xuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnVW5rbm93bic7IC8vIERlZHVwZSBieSB0aGUgcmVuZGVyaW5nIGNvbXBvbmVudCBiZWNhdXNlIGl0J3MgdGhlIG9uZSB0aGF0IG5lZWRzIHRvIGJlIGZpeGVkLlxuXG4gICAgICAgICAgICB2YXIgZGVkdXBlS2V5ID0gcmVuZGVyaW5nQ29tcG9uZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKGRlZHVwZUtleSkpIHtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChkZWR1cGVLZXkpO1xuICAgICAgICAgICAgICB2YXIgc2V0U3RhdGVDb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhICcgKyAnZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgJyArICdmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJywgc2V0U3RhdGVDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcikge1xuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJyArICdmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIGEgJ3NoYXJlZCcgdmFyaWFibGUgdGhhdCBjaGFuZ2VzIHdoZW4gYWN0KCkgb3BlbnMvY2xvc2VzIGluIHRlc3RzLlxuXG5cbnZhciBJc1RoaXNSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5mdW5jdGlvbiB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoZmliZXIpIHtcbiAge1xuICAgIGlmICggSXNTb21lUmVuZGVyZXJBY3RpbmcuY3VycmVudCA9PT0gdHJ1ZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ICE9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgd3JvbmcgYWN0KCkgYXJvdW5kIHlvdXIgdGVzdCBpbnRlcmFjdGlvbnMuXFxuXCIgKyAnQmUgc3VyZSB0byB1c2UgdGhlIG1hdGNoaW5nIHZlcnNpb24gb2YgYWN0KCkgY29ycmVzcG9uZGluZyB0byB5b3VyIHJlbmRlcmVyOlxcblxcbicgKyAnLy8gZm9yIHJlYWN0LWRvbTpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCB7YWN0fSBmcicgKyBcIm9tICdyZWFjdC1kb20vdGVzdC11dGlscyc7XFxuXCIgKyAnLy8gLi4uXFxuJyArICdhY3QoKCkgPT4gLi4uKTtcXG5cXG4nICsgJy8vIGZvciByZWFjdC10ZXN0LXJlbmRlcmVyOlxcbicgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnaW1wb3J0IFRlc3RSZW5kZXJlciBmcicgKyBcIm9tIHJlYWN0LXRlc3QtcmVuZGVyZXInO1xcblwiICsgJ2NvbnN0IHthY3R9ID0gVGVzdFJlbmRlcmVyO1xcbicgKyAnLy8gLi4uXFxuJyArICdhY3QoKCkgPT4gLi4uKTsnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdFZmZlY3RzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICggKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSAhPT0gTm9Nb2RlICYmIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlICYmIElzVGhpc1JlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIHRvICVzIHJhbiBhbiBlZmZlY3QsIGJ1dCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICggZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlICYmIElzVGhpc1JlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2ID0gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWOyAvLyBJbiB0ZXN0cywgd2Ugd2FudCB0byBlbmZvcmNlIGEgbW9ja2VkIHNjaGVkdWxlci5cblxudmFyIGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID0gZmFsc2U7IC8vIFRPRE8gQmVmb3JlIHdlIHJlbGVhc2UgY29uY3VycmVudCBtb2RlLCByZXZpc2l0IHRoaXMgYW5kIGRlY2lkZSB3aGV0aGVyIGEgbW9ja2VkXG4vLyBzY2hlZHVsZXIgaXMgdGhlIGFjdHVhbCByZWNvbW1lbmRhdGlvbi4gVGhlIGFsdGVybmF0aXZlIGNvdWxkIGJlIGEgdGVzdGluZyBidWlsZCxcbi8vIGEgbmV3IGxpYiwgb3Igd2hhdGV2ZXI7IHdlIGR1bm5vIGp1c3QgeWV0LiBUaGlzIG1lc3NhZ2UgaXMgZm9yIGVhcmx5IGFkb3B0ZXJzXG4vLyB0byBnZXQgdGhlaXIgdGVzdHMgcmlnaHQuXG5cbmZ1bmN0aW9uIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkFib3V0VW5tb2NrZWRTY2hlZHVsZXIgPT09IGZhbHNlICYmIFNjaGVkdWxlci51bnN0YWJsZV9mbHVzaEFsbFdpdGhvdXRBc3NlcnRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUgfHwgZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignSW4gQ29uY3VycmVudCBvciBTeW5jIG1vZGVzLCB0aGUgXCJzY2hlZHVsZXJcIiBtb2R1bGUgbmVlZHMgdG8gYmUgbW9ja2VkICcgKyAndG8gZ3VhcmFudGVlIGNvbnNpc3RlbnQgYmVoYXZpb3VyIGFjcm9zcyB0ZXN0cyBhbmQgYnJvd3NlcnMuICcgKyAnRm9yIGV4YW1wbGUsIHdpdGggamVzdDogXFxuJyArIC8vIEJyZWFrIHVwIHJlcXVpcmVzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICBcImplc3QubW9jaygnc2NoZWR1bGVyJywgKCkgPT4gcmVxdWlyZVwiICsgXCIoJ3NjaGVkdWxlci91bnN0YWJsZV9tb2NrJykpO1xcblxcblwiICsgJ0ZvciBtb3JlIGluZm8sIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9tb2NrLXNjaGVkdWxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlVGhyZWFkSUQocm9vdCwgbGFuZSkge1xuICAvLyBJbnRlcmFjdGlvbiB0aHJlYWRzIGFyZSB1bmlxdWUgcGVyIHJvb3QgYW5kIGV4cGlyYXRpb24gdGltZS5cbiAgLy8gTk9URTogSW50ZW50aW9uYWxseSB1bnNvdW5kIGNhc3QuIEFsbCB0aGF0IG1hdHRlcnMgaXMgdGhhdCBpdCdzIGEgbnVtYmVyXG4gIC8vIGFuZCBpdCByZXByZXNlbnRzIGEgYmF0Y2ggb2Ygd29yay4gQ291bGQgbWFrZSBhIGhlbHBlciBmdW5jdGlvbiBpbnN0ZWFkLFxuICAvLyBidXQgbWVoIHRoaXMgaXMgZmluZSBmb3Igbm93LlxuICByZXR1cm4gbGFuZSAqIDEwMDAgKyByb290LmludGVyYWN0aW9uVGhyZWFkSUQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtTcGF3bmVkV29yayhsYW5lKSB7XG5cbiAgaWYgKHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID09PSBudWxsKSB7XG4gICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBbbGFuZV07XG4gIH0gZWxzZSB7XG4gICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIucHVzaChsYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUludGVyYWN0aW9ucyhyb290LCBsYW5lLCBpbnRlcmFjdGlvbnMpIHtcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25zID0gcGVuZGluZ0ludGVyYWN0aW9uTWFwLmdldChsYW5lKTtcblxuICAgIGlmIChwZW5kaW5nSW50ZXJhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgIGludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpZiAoIXBlbmRpbmdJbnRlcmFjdGlvbnMuaGFzKGludGVyYWN0aW9uKSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciBwcmV2aW91c2x5IHVuc2NoZWR1bGVkIGludGVyYWN0aW9uLlxuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuc2V0KGxhbmUsIG5ldyBTZXQoaW50ZXJhY3Rpb25zKSk7IC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG5cbiAgICAgIGludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKSB7XG5cbiAgc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50KTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrT25QZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKSB7XG4gIC8vIHdlIGNhbiBhY2N1cmF0ZWx5IGF0dHJpYnV0ZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gaXQsIEFuZCBzbyB0aGF0IGNhc2NhZGluZ1xuICAvLyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuXG4gIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gIHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxlZEludGVyYWN0aW9ucywgc2NoZWR1bGVkTGFuZSkge1xuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGxhbmVzLCBzY2hlZHVsZWRMYW5lKSkge1xuICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7IC8vIFN0b3JlIHRoZSBjdXJyZW50IHNldCBvZiBpbnRlcmFjdGlvbnMgb24gdGhlIEZpYmVyUm9vdCBmb3IgYSBmZXcgcmVhc29uczpcbiAgLy8gV2UgY2FuIHJlLXVzZSBpdCBpbiBob3QgZnVuY3Rpb25zIGxpa2UgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KClcbiAgLy8gd2l0aG91dCBoYXZpbmcgdG8gcmVjYWxjdWxhdGUgaXQuIFdlIHdpbGwgYWxzbyB1c2UgaXQgaW4gY29tbWl0V29yaygpIHRvXG4gIC8vIHBhc3MgdG8gYW55IFByb2ZpbGVyIG9uUmVuZGVyKCkgaG9va3MuIFRoaXMgYWxzbyBwcm92aWRlcyBEZXZUb29scyB3aXRoIGFcbiAgLy8gd2F5IHRvIGFjY2VzcyBpdCB3aGVuIHRoZSBvbkNvbW1pdFJvb3QoKSBob29rIGlzIGNhbGxlZC5cblxuICByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zO1xuXG4gIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmVzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblxuICB2YXIgcmVtYWluaW5nTGFuZXNBZnRlckNvbW1pdCA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICB2YXIgc3Vic2NyaWJlcjtcblxuICB0cnkge1xuICAgIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgICAgLy8gRklYTUU6IE1vcmUgdGhhbiBvbmUgbGFuZSBjYW4gZmluaXNoIGluIGEgc2luZ2xlIGNvbW1pdC5cbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciB0aHJvd3MsIHJldGhyb3cgaXQgaW4gYSBzZXBhcmF0ZSB0YXNrXG4gICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBDbGVhciBjb21wbGV0ZWQgaW50ZXJhY3Rpb25zIGZyb20gdGhlIHBlbmRpbmcgTWFwLlxuICAgIC8vIFVubGVzcyB0aGUgcmVuZGVyIHdhcyBzdXNwZW5kZWQgb3IgY2FzY2FkaW5nIHdvcmsgd2FzIHNjaGVkdWxlZCxcbiAgICAvLyBJbiB3aGljaCBjYXNl4oCTIGxlYXZlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHVudGlsIHRoZSBzdWJzZXF1ZW50IHJlbmRlci5cbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9uTWFwID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXA7XG4gICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxlZEludGVyYWN0aW9ucywgbGFuZSkge1xuICAgICAgLy8gT25seSBkZWNyZW1lbnQgdGhlIHBlbmRpbmcgaW50ZXJhY3Rpb24gY291bnQgaWYgd2UncmUgZG9uZS5cbiAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgd29yayBhdCB0aGUgY3VycmVudCBwcmlvcml0eSxcbiAgICAgIC8vIFRoYXQgaW5kaWNhdGVzIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIHN1c3BlbnNlIGRhdGEuXG4gICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVtYWluaW5nTGFuZXNBZnRlckNvbW1pdCwgbGFuZSkpIHtcbiAgICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLmRlbGV0ZShsYW5lKTtcbiAgICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciB0aHJvd3MsIHJldGhyb3cgaXQgaW4gYSBzZXBhcmF0ZSB0YXNrXG4gICAgICAgICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8vIGBhY3RgIHRlc3RpbmcgQVBJXG5cbmZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpIHtcbiAgLy8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbiAgcmV0dXJuICBhY3RpbmdVcGRhdGVzU2NvcGVEZXB0aCA+IDA7XG59XG4vLyBzbyB3ZSBjYW4gdGVsbCBpZiBhbnkgYXN5bmMgYWN0KCkgY2FsbHMgdHJ5IHRvIHJ1biBpbiBwYXJhbGxlbC5cblxuXG52YXIgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPSAwO1xuXG5mdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcikge1xuICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbn1cblxudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cblxudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpO1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgZGVidWdDb3VudGVyID0gMTtcblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmVsZW1lbnRUeXBlID0gbnVsbDtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBFZmZlY3RzXG5cbiAgdGhpcy5mbGFncyA9IE5vRmxhZ3M7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbiAgICAvL1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuICAgIC8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4gICAgLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4gICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4gICAgLy9cbiAgICAvLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47IC8vIEl0J3Mgb2theSB0byByZXBsYWNlIHRoZSBpbml0aWFsIGRvdWJsZXMgd2l0aCBzbWlzIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgIC8vIFRoaXMgd29uJ3QgdHJpZ2dlciB0aGUgcGVyZm9ybWFuY2UgY2xpZmYgbWVudGlvbmVkIGFib3ZlLFxuICAgIC8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG5cbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICAvLyBUaGlzIGlzbid0IGRpcmVjdGx5IHVzZWQgYnV0IGlzIGhhbmR5IGZvciBkZWJ1Z2dpbmcgaW50ZXJuYWxzOlxuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG5cblxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0JDEodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnQgOiBGdW5jdGlvbkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgIHJldHVybiBGb3J3YXJkUmVmO1xuICAgIH1cblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICByZXR1cm4gTWVtb0NvbXBvbmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEID0gY3VycmVudC5fZGVidWdJRDtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXM7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wczsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IE5vRmxhZ3M7IC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gIH07IC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG5cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn0gLy8gVXNlZCB0byByZXVzZSBhIEZpYmVyIGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIHJlc2V0cyB0aGUgRmliZXIgdG8gd2hhdCBjcmVhdGVGaWJlciBvciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZFxuICAvLyBoYXZlIHNldCB0aGUgdmFsdWVzIHRvIGJlZm9yZSBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIElkZWFsbHkgdGhpcyB3b3VsZG4ndFxuICAvLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG4gIC8vIHdoZW4gdGhleSBzaG91bGQgYmUgcmVhZGluZyBmcm9tIGN1cnJlbnQgYW5kIHdyaXRpbmcgdG8gd29ya0luUHJvZ3Jlc3MuXG4gIC8vIFdlIGFzc3VtZSBwZW5kaW5nUHJvcHMsIGluZGV4LCBrZXksIHJlZiwgcmV0dXJuIGFyZSBzdGlsbCB1bnRvdWNoZWQgdG9cbiAgLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cbiAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcgYnV0IGtlZXAgYW55IFBsYWNlbWVudCB0YWdzLCBzaW5jZSB0aGF0J3Mgc29tZXRoaW5nXG4gIC8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gUGxhY2VtZW50OyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRvIGNyZWF0ZUZpYmVyJ3MgaW5pdGlhbCB2YWx1ZXMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZykge1xuICB2YXIgbW9kZTtcblxuICBpZiAodGFnID09PSBDb25jdXJyZW50Um9vdCkge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZSB8IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSBpZiAodGFnID09PSBCbG9ja2luZ1Jvb3QpIHtcbiAgICBtb2RlID0gQmxvY2tpbmdNb2RlIHwgU3RyaWN0TW9kZTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlID0gTm9Nb2RlO1xuICB9XG5cbiAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IERlYnVnVHJhY2luZ01vZGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEJsb2NrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGZpYmVyLnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG5cbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIGtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgcGVuZGluZ1Byb3BzLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgYXMgYSBwcm9wJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpOyAvLyBUT0RPOiBUaGUgUHJvZmlsZXIgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci50eXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgICAgZWZmZWN0RHVyYXRpb246IDAsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIFN1c3BlbnNlQ29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGZpeGVkIGluIGdldENvbXBvbmVudE5hbWUgc28gdGhhdCBpdCByZWxpZXMgb24gdGhlIHRhZ1xuICAvLyBpbnN0ZWFkLlxuXG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG5cbiAge1xuICAgIC8vIFRPRE86IFRoZSBTdXNwZW5zZUxpc3RDb21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgICAvLyBpbnN0ZWFkLlxuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihPZmZzY3JlZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIE9mZnNjcmVlbkNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICB7XG4gICAgZmliZXIudHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tTGVnYWN5SGlkZGVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihMZWdhY3lIaWRkZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIExlZ2FjeUhpZGRlbiBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICB7XG4gICAgZmliZXIudHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7IC8vIFRPRE86IFRoZXNlIHNob3VsZCBub3QgbmVlZCBhIHR5cGUuXG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gIT09IG51bGwgPyBwb3J0YWwuY2hpbGRyZW4gOiBbXTtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFBvcnRhbCwgcGVuZGluZ1Byb3BzLCBwb3J0YWwua2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufSAvLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbiAgICAvLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG4gICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgfSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuXG4gIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuICB0YXJnZXQua2V5ID0gc291cmNlLmtleTtcbiAgdGFyZ2V0LmVsZW1lbnRUeXBlID0gc291cmNlLmVsZW1lbnRUeXBlO1xuICB0YXJnZXQudHlwZSA9IHNvdXJjZS50eXBlO1xuICB0YXJnZXQuc3RhdGVOb2RlID0gc291cmNlLnN0YXRlTm9kZTtcbiAgdGFyZ2V0LnJldHVybiA9IHNvdXJjZS5yZXR1cm47XG4gIHRhcmdldC5jaGlsZCA9IHNvdXJjZS5jaGlsZDtcbiAgdGFyZ2V0LnNpYmxpbmcgPSBzb3VyY2Uuc2libGluZztcbiAgdGFyZ2V0LmluZGV4ID0gc291cmNlLmluZGV4O1xuICB0YXJnZXQucmVmID0gc291cmNlLnJlZjtcbiAgdGFyZ2V0LnBlbmRpbmdQcm9wcyA9IHNvdXJjZS5wZW5kaW5nUHJvcHM7XG4gIHRhcmdldC5tZW1vaXplZFByb3BzID0gc291cmNlLm1lbW9pemVkUHJvcHM7XG4gIHRhcmdldC51cGRhdGVRdWV1ZSA9IHNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgdGFyZ2V0Lm1lbW9pemVkU3RhdGUgPSBzb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgdGFyZ2V0LmRlcGVuZGVuY2llcyA9IHNvdXJjZS5kZXBlbmRlbmNpZXM7XG4gIHRhcmdldC5tb2RlID0gc291cmNlLm1vZGU7XG4gIHRhcmdldC5mbGFncyA9IHNvdXJjZS5mbGFncztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQubGFuZXMgPSBzb3VyY2UubGFuZXM7XG4gIHRhcmdldC5jaGlsZExhbmVzID0gc291cmNlLmNoaWxkTGFuZXM7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuXG4gIHtcbiAgICB0YXJnZXQuYWN0dWFsRHVyYXRpb24gPSBzb3VyY2UuYWN0dWFsRHVyYXRpb247XG4gICAgdGFyZ2V0LmFjdHVhbFN0YXJ0VGltZSA9IHNvdXJjZS5hY3R1YWxTdGFydFRpbWU7XG4gICAgdGFyZ2V0LnNlbGZCYXNlRHVyYXRpb24gPSBzb3VyY2Uuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB0YXJnZXQudHJlZUJhc2VEdXJhdGlvbiA9IHNvdXJjZS50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnTmVlZHNSZW1vdW50ID0gc291cmNlLl9kZWJ1Z05lZWRzUmVtb3VudDtcbiAgdGFyZ2V0Ll9kZWJ1Z0hvb2tUeXBlcyA9IHNvdXJjZS5fZGVidWdIb29rVHlwZXM7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIHRoaXMucGluZ0NhY2hlID0gbnVsbDtcbiAgdGhpcy5maW5pc2hlZFdvcmsgPSBudWxsO1xuICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLmh5ZHJhdGUgPSBoeWRyYXRlO1xuICB0aGlzLmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZVByaW9yaXR5O1xuICB0aGlzLmV2ZW50VGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO1xuICB0aGlzLnBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5leHBpcmVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLm11dGFibGVSZWFkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcblxuICB7XG4gICAgdGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLmludGVyYWN0aW9uVGhyZWFkSUQgPSB0cmFjaW5nLnVuc3RhYmxlX2dldFRocmVhZElEKCk7XG4gICAgdGhpcy5tZW1vaXplZEludGVyYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBCbG9ja2luZ1Jvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlQmxvY2tpbmdSb290KCknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb25jdXJyZW50Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVSb290KCknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWdhY3lSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUxlZ2FjeVJvb3QoKSc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgdmFyIHJvb3QgPSBuZXcgRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnKTtcbiAgcm9vdC5jdXJyZW50ID0gdW5pbml0aWFsaXplZEZpYmVyO1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG4vLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdmVyc2lvbiB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG1hdGNoZXMgdGhlIG9uZVxuLy8gdGhhdCBpcyBldmVudHVhbGx5IHJlYWQgZHVyaW5nIGh5ZHJhdGlvbi5cbi8vIElmIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlcmUncyBhIHBvdGVudGlhbCB0ZWFyIGFuZCBhIGZ1bGwgZGVvcHQgcmVuZGVyIGlzIHJlcXVpcmVkLlxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCwgbXV0YWJsZVNvdXJjZSkge1xuICB2YXIgZ2V0VmVyc2lvbiA9IG11dGFibGVTb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihtdXRhYmxlU291cmNlLl9zb3VyY2UpOyAvLyBUT0RPIENsZWFyIHRoaXMgZGF0YSBvbmNlIGFsbCBwZW5kaW5nIGh5ZHJhdGlvbiB3b3JrIGlzIGZpbmlzaGVkLlxuICAvLyBSZXRhaW5pbmcgaXQgZm9yZXZlciBtYXkgaW50ZXJmZXJlIHdpdGggR0MuXG5cbiAgaWYgKHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9PSBudWxsKSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gW211dGFibGVTb3VyY2UsIHZlcnNpb25dO1xuICB9IGVsc2Uge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5wdXNoKG11dGFibGVTb3VyY2UsIHZlcnNpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG52YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcbnZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTtcblxue1xuICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gZmliZXIudHlwZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIE9iamVjdC5rZXlzKGNvbXBvbmVudCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGhvc3RGaWJlcik7XG5cbiAgICAgICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIHJlc2V0IHRvIHByZXZpb3VzIGJ1dCB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaW5cbiAgICAgICAgICAvLyByZW5kZXIgYW5kIHRoZXJlJ3MgYW5vdGhlciB3YXJuaW5nIGZvciB0aGF0IGFueXdheS5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgICAgc2V0Q3VycmVudEZpYmVyKHByZXZpb3VzRmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGh5ZHJhdGlvbkNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBvblNjaGVkdWxlUm9vdChjb250YWluZXIsIGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuXG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmVW5tb2NrZWRTY2hlZHVsZXIoY3VycmVudCQxKTtcbiAgICAgIHdhcm5JZk5vdFNjb3BlZFdpdGhNYXRjaGluZ0FjdChjdXJyZW50JDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCQxKTtcblxuICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoY3VycmVudC50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9O1xuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG5cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBlbnF1ZXVlVXBkYXRlKGN1cnJlbnQkMSwgdXBkYXRlKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGN1cnJlbnQkMSwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGhpZ2hlclByaW9yaXR5TGFuZShzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSwgcmV0cnlMYW5lKTtcbiAgfVxufSAvLyBJbmNyZWFzZXMgdGhlIHByaW9yaXR5IG9mIHRoZW5uYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgbWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLCByZXRyeUxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24kMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgb3RoZXIgdGhhbiBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eSQyKHByaW9yaXR5LCBmbikge1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChob3N0RmliZXIudGFnID09PSBGdW5kYW1lbnRhbENvbXBvbmVudCkge1xuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlLmluc3RhbmNlO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbnZhciBzaG91bGRTdXNwZW5kSW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRTdXNwZW5kKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG59XG52YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsO1xudmFyIHNjaGVkdWxlVXBkYXRlID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhEZWxldGUgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZUltcGwgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgdXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKCAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICBvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aCkge1xuICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKG9sZFBhdGhbaV0gIT09IG5ld1BhdGhbaV0pIHtcbiAgICAgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXRJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gQXJyYXkuaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoUmVuYW1lKGhvb2subWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuICAgIGJ1bmRsZVR5cGU6IGRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsXG4gICAgdmVyc2lvbjogZGV2VG9vbHNDb25maWcudmVyc2lvbixcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgIHJlbmRlcmVyQ29uZmlnOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZTogb3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wczogb3ZlcnJpZGVQcm9wcyxcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIHx8IGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgLy8gUmVhY3QgUmVmcmVzaFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSZWZyZXNoOiAgc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6ICBzY2hlZHVsZVJvb3QgLFxuICAgIHNldFJlZnJlc2hIYW5kbGVyOiAgc2V0UmVmcmVzaEhhbmRsZXIgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbiAgICBnZXRDdXJyZW50RmliZXI6ICBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyBcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0RE9NUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gY3JlYXRlUm9vdEltcGwoY29udGFpbmVyLCBDb25jdXJyZW50Um9vdCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQmxvY2tpbmdSb290KGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKTtcbn1cblxuUmVhY3RET01Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTUJsb2NraW5nUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuICcgKyAnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKHJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhlICcgKyAncm9vdCBjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyBcInJvb3QudW5tb3VudCgpIHRvIGVtcHR5IGEgcm9vdCdzIGNvbnRhaW5lci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIG51bGwpO1xufTtcblxuUmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50ID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3VubW91bnQoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgY29udGFpbmVyID0gcm9vdC5jb250YWluZXJJbmZvO1xuICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKSB7XG4gIC8vIFRhZyBpcyBlaXRoZXIgTGVnYWN5Um9vdCBvciBDb25jdXJyZW50IFJvb3RcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICB2YXIgaHlkcmF0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyB8fCBudWxsO1xuICB2YXIgbXV0YWJsZVNvdXJjZXMgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRpb25PcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRpb25PcHRpb25zLm11dGFibGVTb3VyY2VzIHx8IG51bGw7XG4gIHZhciByb290ID0gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgdGFnLCBoeWRyYXRlKTtcbiAgbWFya0NvbnRhaW5lckFzUm9vdChyb290LmN1cnJlbnQsIGNvbnRhaW5lcik7XG4gIHZhciBjb250YWluZXJOb2RlVHlwZSA9IGNvbnRhaW5lci5ub2RlVHlwZTtcblxuICB7XG4gICAgdmFyIHJvb3RDb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIH1cblxuICBpZiAobXV0YWJsZVNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGFibGVTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IG11dGFibGVTb3VyY2VzW2ldO1xuICAgICAgcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gY3JlYXRlTGVnYWN5Um9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIExlZ2FjeVJvb3QsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncztcbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxue1xuICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcblxuICAgIGlmIChoYXNOb25Sb290UmVhY3RDaGlsZCAmJiAhaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGNvbnRhaW5lci50YWdOYW1lICYmIGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdCT0RZJykge1xuICAgICAgZXJyb3IoJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKSB7XG4gIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpOyAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cblxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nO1xuXG4gICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAge1xuICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcigncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcblxuICAgICAgd2FybigncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE4LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlTGVnYWN5Um9vdChjb250YWluZXIsIHNob3VsZEh5ZHJhdGUgPyB7XG4gICAgaHlkcmF0ZTogdHJ1ZVxuICB9IDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIHRvcExldmVsVXBkYXRlV2FybmluZ3MoY29udGFpbmVyKTtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH0gLy8gVE9ETzogV2l0aG91dCBgYW55YCB0eXBlLCBGbG93IHNheXMgXCJQcm9wZXJ0eSBjYW5ub3QgYmUgYWNjZXNzZWQgb24gYW55XG4gIC8vIG1lbWJlciBvZiBpbnRlcnNlY3Rpb24gdHlwZS5cIiBXaHl5eXl5eS5cblxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIHZhciBmaWJlclJvb3Q7XG5cbiAgaWYgKCFyb290KSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKTtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH0gLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCBmaWJlclJvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZpYmVyUm9vdCA9IHJvb3QuX2ludGVybmFsUm9vdDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG5cbiAgICAgICAgX29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH0gLy8gVXBkYXRlXG5cblxuICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2UoZmliZXJSb290KTtcbn1cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHtcbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwgJ2ZpbmRET01Ob2RlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00uaHlkcmF0ZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgY3JlYXRlUm9vdChjb250YWluZXIsIHtoeWRyYXRlOiB0cnVlfSkucmVuZGVyKGVsZW1lbnQpPycpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG5cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiByZW5kZXIoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCByb290LnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgaGFzKHBhcmVudENvbXBvbmVudCkpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwicGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnRcIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgaXNNb2Rlcm5Sb290ID0gaXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSAmJiBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzTW9kZXJuUm9vdCkge1xuICAgICAgZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC51bm1vdW50KCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAge1xuICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuXG4gICAgICBpZiAocmVuZGVyZWRCeURpZmZlcmVudFJlYWN0KSB7XG4gICAgICAgIGVycm9yKFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cblxuXG4gICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBzaG91bGQgcHJvYmFibHkgdXNlIGBkZWxldGUgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXJgXG4gICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShfcm9vdEVsKSk7IC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgIGlmIChoYXNOb25Sb290UmVhY3RDaGlsZCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKTtcbnNldEF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShydW5XaXRoUHJpb3JpdHkkMik7XG52YXIgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSBmYWxzZTtcblxue1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIE1hcCBoYXMgbm8gcHJvdG90eXBlXG4gIE1hcC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBTZXQgaGFzIG5vIHByb3RvdHlwZVxuICBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yKCdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5zZXRSZXN0b3JlSW1wbGVtZW50YXRpb24ocmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKTtcbnNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oYmF0Y2hlZFVwZGF0ZXMkMSwgZGlzY3JldGVVcGRhdGVzJDEsIGZsdXNoRGlzY3JldGVVcGRhdGVzLCBiYXRjaGVkRXZlbnRVcGRhdGVzJDEpO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9IC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIC8vICRGbG93Rml4TWUgVGhlIEZsb3cgdHlwZSBpcyBvcGFxdWUgYnV0IHRoZXJlJ3Mgbm8gd2F5IHRvIGFjdHVhbGx5IGNyZWF0ZSBpdC5cblxuXG4gIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuXG4gIHJldHVybiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCkge1xuICAgICAgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdUaGUgUmVhY3RET00udW5zdGFibGVfY3JlYXRlUG9ydGFsKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE4Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdERPTS5jcmVhdGVQb3J0YWwoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLCAnICsgJ2J1dCB3aXRob3V0IHRoZSBcInVuc3RhYmxlX1wiIHByZWZpeC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwga2V5KTtcbn1cblxudmFyIEludGVybmFscyA9IHtcbiAgLy8gS2VlcCBpbiBzeW5jIHdpdGggUmVhY3RUZXN0VXRpbHMuanMsIGFuZCBSZWFjdFRlc3RVdGlsc0FjdC5qcy5cbiAgLy8gVGhpcyBpcyBhbiBhcnJheSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvbi5cbiAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSwgZ2V0Tm9kZUZyb21JbnN0YW5jZSwgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSwgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGZsdXNoUGFzc2l2ZUVmZmVjdHMsIC8vIFRPRE86IFRoaXMgaXMgcmVsYXRlZCB0byBgYWN0YCwgbm90IGV2ZW50cy4gTW92ZSB0byBzZXBhcmF0ZSBrZXk/XG4gIElzVGhpc1JlbmRlcmVyQWN0aW5nXVxufTtcbnZhciBmb3VuZERldlRvb2xzID0gaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAgMSAsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBjYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7IC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cblxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWwkMTtcbmV4cG9ydHMuZmluZERPTU5vZGUgPSBmaW5kRE9NTm9kZTtcbmV4cG9ydHMuZmx1c2hTeW5jID0gZmx1c2hTeW5jO1xuZXhwb3J0cy5oeWRyYXRlID0gaHlkcmF0ZTtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBiYXRjaGVkVXBkYXRlcyQxO1xuZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWwgPSB1bnN0YWJsZV9jcmVhdGVQb3J0YWw7XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/cjs/react-dom.development.js\n");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nfunction checkDCE() {\r\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\r\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\r\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\r\n        return;\r\n    }\r\n    if (true) {\r\n        // This branch is unreachable because this function is only called\r\n        // in production, but the condition is true only in development.\r\n        // Therefore if the branch is still here, dead code elimination wasn't\r\n        // properly applied.\r\n        // Don't change the message. React DevTools relies on it. Also make sure\r\n        // this message doesn't occur elsewhere in this function, or it will cause\r\n        // a false positive.\r\n        throw new Error('^_^');\r\n    }\r\n    try {\r\n        // Verify that the code above has been dead code eliminated (DCE'd).\r\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\r\n    }\r\n    catch (err) {\r\n        // DevTools shouldn't crash React, no matter what.\r\n        // We should still report in case we break this code.\r\n        console.error(err);\r\n    }\r\n}\r\nif (false) {}\r\nelse {\r\n    module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzPzhiYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTLFFBQVE7SUFDZiwyQ0FBMkM7SUFDM0MsSUFDRSxPQUFPLDhCQUE4QixLQUFLLFdBQVc7UUFDckQsT0FBTyw4QkFBOEIsQ0FBQyxRQUFRLEtBQUssVUFBVSxFQUM3RDtRQUNBLE9BQU87S0FDUjtJQUNELElBQUksSUFBcUMsRUFBRTtRQUN6QyxrRUFBa0U7UUFDbEUsZ0VBQWdFO1FBQ2hFLHNFQUFzRTtRQUN0RSxvQkFBb0I7UUFDcEIsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSxvQkFBb0I7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN4QjtJQUNELElBQUk7UUFDRixvRUFBb0U7UUFDcEUsOEJBQThCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ25EO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDWixrREFBa0Q7UUFDbEQscURBQXFEO1FBQ3JELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDcEI7QUFDSCxDQUFDO0FBRUQsSUFBSSxLQUFxQyxFQUFFLEVBSzFDO0tBQU07SUFDTCxNQUFNLENBQUMsT0FBTyxHQUFHLG1CQUFPLENBQUMsNkZBQWdDLENBQUMsQ0FBQztDQUM1RCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-dom/index.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v17.0.1\r\n * react.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nif (true) {\r\n    (function () {\r\n        'use strict';\r\n        var _assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\r\n        // TODO: this is special because it gets imported during build.\r\n        var ReactVersion = '17.0.1';\r\n        // ATTENTION\r\n        // When adding new symbols to this file,\r\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\r\n        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\r\n        // nor polyfill, then a plain number is used for performance.\r\n        var REACT_ELEMENT_TYPE = 0xeac7;\r\n        var REACT_PORTAL_TYPE = 0xeaca;\r\n        exports.Fragment = 0xeacb;\r\n        exports.StrictMode = 0xeacc;\r\n        exports.Profiler = 0xead2;\r\n        var REACT_PROVIDER_TYPE = 0xeacd;\r\n        var REACT_CONTEXT_TYPE = 0xeace;\r\n        var REACT_FORWARD_REF_TYPE = 0xead0;\r\n        exports.Suspense = 0xead1;\r\n        var REACT_SUSPENSE_LIST_TYPE = 0xead8;\r\n        var REACT_MEMO_TYPE = 0xead3;\r\n        var REACT_LAZY_TYPE = 0xead4;\r\n        var REACT_BLOCK_TYPE = 0xead9;\r\n        var REACT_SERVER_BLOCK_TYPE = 0xeada;\r\n        var REACT_FUNDAMENTAL_TYPE = 0xead5;\r\n        var REACT_SCOPE_TYPE = 0xead7;\r\n        var REACT_OPAQUE_ID_TYPE = 0xeae0;\r\n        var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\r\n        var REACT_OFFSCREEN_TYPE = 0xeae2;\r\n        var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\r\n        if (typeof Symbol === 'function' && Symbol.for) {\r\n            var symbolFor = Symbol.for;\r\n            REACT_ELEMENT_TYPE = symbolFor('react.element');\r\n            REACT_PORTAL_TYPE = symbolFor('react.portal');\r\n            exports.Fragment = symbolFor('react.fragment');\r\n            exports.StrictMode = symbolFor('react.strict_mode');\r\n            exports.Profiler = symbolFor('react.profiler');\r\n            REACT_PROVIDER_TYPE = symbolFor('react.provider');\r\n            REACT_CONTEXT_TYPE = symbolFor('react.context');\r\n            REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\r\n            exports.Suspense = symbolFor('react.suspense');\r\n            REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\r\n            REACT_MEMO_TYPE = symbolFor('react.memo');\r\n            REACT_LAZY_TYPE = symbolFor('react.lazy');\r\n            REACT_BLOCK_TYPE = symbolFor('react.block');\r\n            REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\r\n            REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\r\n            REACT_SCOPE_TYPE = symbolFor('react.scope');\r\n            REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\r\n            REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\r\n            REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\r\n            REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\r\n        }\r\n        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\r\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\r\n        function getIteratorFn(maybeIterable) {\r\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\r\n                return null;\r\n            }\r\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n            if (typeof maybeIterator === 'function') {\r\n                return maybeIterator;\r\n            }\r\n            return null;\r\n        }\r\n        /**\r\n         * Keeps track of the current dispatcher.\r\n         */\r\n        var ReactCurrentDispatcher = {\r\n            /**\r\n             * @internal\r\n             * @type {ReactComponent}\r\n             */\r\n            current: null\r\n        };\r\n        /**\r\n         * Keeps track of the current batch's configuration such as how long an update\r\n         * should suspend for if it needs to.\r\n         */\r\n        var ReactCurrentBatchConfig = {\r\n            transition: 0\r\n        };\r\n        /**\r\n         * Keeps track of the current owner.\r\n         *\r\n         * The current owner is the component who should own any components that are\r\n         * currently being constructed.\r\n         */\r\n        var ReactCurrentOwner = {\r\n            /**\r\n             * @internal\r\n             * @type {ReactComponent}\r\n             */\r\n            current: null\r\n        };\r\n        var ReactDebugCurrentFrame = {};\r\n        var currentExtraStackFrame = null;\r\n        function setExtraStackFrame(stack) {\r\n            {\r\n                currentExtraStackFrame = stack;\r\n            }\r\n        }\r\n        {\r\n            ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\r\n                {\r\n                    currentExtraStackFrame = stack;\r\n                }\r\n            }; // Stack implementation injected by the current renderer.\r\n            ReactDebugCurrentFrame.getCurrentStack = null;\r\n            ReactDebugCurrentFrame.getStackAddendum = function () {\r\n                var stack = ''; // Add an extra top frame while an element is being validated\r\n                if (currentExtraStackFrame) {\r\n                    stack += currentExtraStackFrame;\r\n                } // Delegate to the injected renderer-specific implementation\r\n                var impl = ReactDebugCurrentFrame.getCurrentStack;\r\n                if (impl) {\r\n                    stack += impl() || '';\r\n                }\r\n                return stack;\r\n            };\r\n        }\r\n        /**\r\n         * Used by act() to track whether you're inside an act() scope.\r\n         */\r\n        var IsSomeRendererActing = {\r\n            current: false\r\n        };\r\n        var ReactSharedInternals = {\r\n            ReactCurrentDispatcher: ReactCurrentDispatcher,\r\n            ReactCurrentBatchConfig: ReactCurrentBatchConfig,\r\n            ReactCurrentOwner: ReactCurrentOwner,\r\n            IsSomeRendererActing: IsSomeRendererActing,\r\n            // Used by renderers to avoid bundling object-assign twice in UMD bundles:\r\n            assign: _assign\r\n        };\r\n        {\r\n            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\r\n        }\r\n        // by calls to these methods by a Babel plugin.\r\n        //\r\n        // In PROD (or in packages without access to React internals),\r\n        // they are left as they are instead.\r\n        function warn(format) {\r\n            {\r\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                    args[_key - 1] = arguments[_key];\r\n                }\r\n                printWarning('warn', format, args);\r\n            }\r\n        }\r\n        function error(format) {\r\n            {\r\n                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n                    args[_key2 - 1] = arguments[_key2];\r\n                }\r\n                printWarning('error', format, args);\r\n            }\r\n        }\r\n        function printWarning(level, format, args) {\r\n            // When changing this logic, you might want to also\r\n            // update consoleWithStackDev.www.js as well.\r\n            {\r\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n                if (stack !== '') {\r\n                    format += '%s';\r\n                    args = args.concat([stack]);\r\n                }\r\n                var argsWithFormat = args.map(function (item) {\r\n                    return '' + item;\r\n                }); // Careful: RN currently depends on this prefix\r\n                argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\r\n                // breaks IE9: https://github.com/facebook/react/issues/13610\r\n                // eslint-disable-next-line react-internal/no-production-logging\r\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n            }\r\n        }\r\n        var didWarnStateUpdateForUnmountedComponent = {};\r\n        function warnNoop(publicInstance, callerName) {\r\n            {\r\n                var _constructor = publicInstance.constructor;\r\n                var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\r\n                var warningKey = componentName + \".\" + callerName;\r\n                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\r\n                    return;\r\n                }\r\n                error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\r\n                didWarnStateUpdateForUnmountedComponent[warningKey] = true;\r\n            }\r\n        }\r\n        /**\r\n         * This is the abstract API for an update queue.\r\n         */\r\n        var ReactNoopUpdateQueue = {\r\n            /**\r\n             * Checks whether or not this composite component is mounted.\r\n             * @param {ReactClass} publicInstance The instance we want to test.\r\n             * @return {boolean} True if mounted, false otherwise.\r\n             * @protected\r\n             * @final\r\n             */\r\n            isMounted: function (publicInstance) {\r\n                return false;\r\n            },\r\n            /**\r\n             * Forces an update. This should only be invoked when it is known with\r\n             * certainty that we are **not** in a DOM transaction.\r\n             *\r\n             * You may want to call this when you know that some deeper aspect of the\r\n             * component's state has changed but `setState` was not called.\r\n             *\r\n             * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n             * `componentWillUpdate` and `componentDidUpdate`.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} callerName name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueForceUpdate: function (publicInstance, callback, callerName) {\r\n                warnNoop(publicInstance, 'forceUpdate');\r\n            },\r\n            /**\r\n             * Replaces all of the state. Always use this or `setState` to mutate state.\r\n             * You should treat `this.state` as immutable.\r\n             *\r\n             * There is no guarantee that `this.state` will be immediately updated, so\r\n             * accessing `this.state` after calling this method may return the old value.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {object} completeState Next state.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} callerName name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\r\n                warnNoop(publicInstance, 'replaceState');\r\n            },\r\n            /**\r\n             * Sets a subset of the state. This only exists because _pendingState is\r\n             * internal. This provides a merging strategy that is not available to deep\r\n             * properties which is confusing. TODO: Expose pendingState or don't use it\r\n             * during the merge.\r\n             *\r\n             * @param {ReactClass} publicInstance The instance that should rerender.\r\n             * @param {object} partialState Next partial state to be merged with state.\r\n             * @param {?function} callback Called after component is updated.\r\n             * @param {?string} Name of the calling function in the public API.\r\n             * @internal\r\n             */\r\n            enqueueSetState: function (publicInstance, partialState, callback, callerName) {\r\n                warnNoop(publicInstance, 'setState');\r\n            }\r\n        };\r\n        var emptyObject = {};\r\n        {\r\n            Object.freeze(emptyObject);\r\n        }\r\n        /**\r\n         * Base class helpers for the updating state of a component.\r\n         */\r\n        function Component(props, context, updater) {\r\n            this.props = props;\r\n            this.context = context; // If a component has string refs, we will assign a different object later.\r\n            this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\r\n            // renderer.\r\n            this.updater = updater || ReactNoopUpdateQueue;\r\n        }\r\n        Component.prototype.isReactComponent = {};\r\n        /**\r\n         * Sets a subset of the state. Always use this to mutate\r\n         * state. You should treat `this.state` as immutable.\r\n         *\r\n         * There is no guarantee that `this.state` will be immediately updated, so\r\n         * accessing `this.state` after calling this method may return the old value.\r\n         *\r\n         * There is no guarantee that calls to `setState` will run synchronously,\r\n         * as they may eventually be batched together.  You can provide an optional\r\n         * callback that will be executed when the call to setState is actually\r\n         * completed.\r\n         *\r\n         * When a function is provided to setState, it will be called at some point in\r\n         * the future (not synchronously). It will be called with the up to date\r\n         * component arguments (state, props, context). These values can be different\r\n         * from this.* because your function may be called after receiveProps but before\r\n         * shouldComponentUpdate, and this new state, props, and context will not yet be\r\n         * assigned to this.\r\n         *\r\n         * @param {object|function} partialState Next partial state or function to\r\n         *        produce next partial state to be merged with current state.\r\n         * @param {?function} callback Called after state is updated.\r\n         * @final\r\n         * @protected\r\n         */\r\n        Component.prototype.setState = function (partialState, callback) {\r\n            if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {\r\n                {\r\n                    throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\r\n                }\r\n            }\r\n            this.updater.enqueueSetState(this, partialState, callback, 'setState');\r\n        };\r\n        /**\r\n         * Forces an update. This should only be invoked when it is known with\r\n         * certainty that we are **not** in a DOM transaction.\r\n         *\r\n         * You may want to call this when you know that some deeper aspect of the\r\n         * component's state has changed but `setState` was not called.\r\n         *\r\n         * This will not invoke `shouldComponentUpdate`, but it will invoke\r\n         * `componentWillUpdate` and `componentDidUpdate`.\r\n         *\r\n         * @param {?function} callback Called after update is complete.\r\n         * @final\r\n         * @protected\r\n         */\r\n        Component.prototype.forceUpdate = function (callback) {\r\n            this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\r\n        };\r\n        /**\r\n         * Deprecated APIs. These APIs used to exist on classic React classes but since\r\n         * we would like to deprecate them, we're not going to move them over to this\r\n         * modern base class. Instead, we define a getter that warns if it's accessed.\r\n         */\r\n        {\r\n            var deprecatedAPIs = {\r\n                isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\r\n                replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\r\n            };\r\n            var defineDeprecationWarning = function (methodName, info) {\r\n                Object.defineProperty(Component.prototype, methodName, {\r\n                    get: function () {\r\n                        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\r\n                        return undefined;\r\n                    }\r\n                });\r\n            };\r\n            for (var fnName in deprecatedAPIs) {\r\n                if (deprecatedAPIs.hasOwnProperty(fnName)) {\r\n                    defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\r\n                }\r\n            }\r\n        }\r\n        function ComponentDummy() { }\r\n        ComponentDummy.prototype = Component.prototype;\r\n        /**\r\n         * Convenience component with default shallow equality check for sCU.\r\n         */\r\n        function PureComponent(props, context, updater) {\r\n            this.props = props;\r\n            this.context = context; // If a component has string refs, we will assign a different object later.\r\n            this.refs = emptyObject;\r\n            this.updater = updater || ReactNoopUpdateQueue;\r\n        }\r\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\r\n        pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\r\n        _assign(pureComponentPrototype, Component.prototype);\r\n        pureComponentPrototype.isPureReactComponent = true;\r\n        // an immutable object with a single mutable value\r\n        function createRef() {\r\n            var refObject = {\r\n                current: null\r\n            };\r\n            {\r\n                Object.seal(refObject);\r\n            }\r\n            return refObject;\r\n        }\r\n        function getWrappedName(outerType, innerType, wrapperName) {\r\n            var functionName = innerType.displayName || innerType.name || '';\r\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\r\n        }\r\n        function getContextName(type) {\r\n            return type.displayName || 'Context';\r\n        }\r\n        function getComponentName(type) {\r\n            if (type == null) {\r\n                // Host root, text node or just invalid type.\r\n                return null;\r\n            }\r\n            {\r\n                if (typeof type.tag === 'number') {\r\n                    error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\r\n                }\r\n            }\r\n            if (typeof type === 'function') {\r\n                return type.displayName || type.name || null;\r\n            }\r\n            if (typeof type === 'string') {\r\n                return type;\r\n            }\r\n            switch (type) {\r\n                case exports.Fragment:\r\n                    return 'Fragment';\r\n                case REACT_PORTAL_TYPE:\r\n                    return 'Portal';\r\n                case exports.Profiler:\r\n                    return 'Profiler';\r\n                case exports.StrictMode:\r\n                    return 'StrictMode';\r\n                case exports.Suspense:\r\n                    return 'Suspense';\r\n                case REACT_SUSPENSE_LIST_TYPE:\r\n                    return 'SuspenseList';\r\n            }\r\n            if (typeof type === 'object') {\r\n                switch (type.$$typeof) {\r\n                    case REACT_CONTEXT_TYPE:\r\n                        var context = type;\r\n                        return getContextName(context) + '.Consumer';\r\n                    case REACT_PROVIDER_TYPE:\r\n                        var provider = type;\r\n                        return getContextName(provider._context) + '.Provider';\r\n                    case REACT_FORWARD_REF_TYPE:\r\n                        return getWrappedName(type, type.render, 'ForwardRef');\r\n                    case REACT_MEMO_TYPE:\r\n                        return getComponentName(type.type);\r\n                    case REACT_BLOCK_TYPE:\r\n                        return getComponentName(type._render);\r\n                    case REACT_LAZY_TYPE:\r\n                        {\r\n                            var lazyComponent = type;\r\n                            var payload = lazyComponent._payload;\r\n                            var init = lazyComponent._init;\r\n                            try {\r\n                                return getComponentName(init(payload));\r\n                            }\r\n                            catch (x) {\r\n                                return null;\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n        var RESERVED_PROPS = {\r\n            key: true,\r\n            ref: true,\r\n            __self: true,\r\n            __source: true\r\n        };\r\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\r\n        {\r\n            didWarnAboutStringRefs = {};\r\n        }\r\n        function hasValidRef(config) {\r\n            {\r\n                if (hasOwnProperty.call(config, 'ref')) {\r\n                    var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\r\n                    if (getter && getter.isReactWarning) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return config.ref !== undefined;\r\n        }\r\n        function hasValidKey(config) {\r\n            {\r\n                if (hasOwnProperty.call(config, 'key')) {\r\n                    var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\r\n                    if (getter && getter.isReactWarning) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return config.key !== undefined;\r\n        }\r\n        function defineKeyPropWarningGetter(props, displayName) {\r\n            var warnAboutAccessingKey = function () {\r\n                {\r\n                    if (!specialPropKeyWarningShown) {\r\n                        specialPropKeyWarningShown = true;\r\n                        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n                    }\r\n                }\r\n            };\r\n            warnAboutAccessingKey.isReactWarning = true;\r\n            Object.defineProperty(props, 'key', {\r\n                get: warnAboutAccessingKey,\r\n                configurable: true\r\n            });\r\n        }\r\n        function defineRefPropWarningGetter(props, displayName) {\r\n            var warnAboutAccessingRef = function () {\r\n                {\r\n                    if (!specialPropRefWarningShown) {\r\n                        specialPropRefWarningShown = true;\r\n                        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\r\n                    }\r\n                }\r\n            };\r\n            warnAboutAccessingRef.isReactWarning = true;\r\n            Object.defineProperty(props, 'ref', {\r\n                get: warnAboutAccessingRef,\r\n                configurable: true\r\n            });\r\n        }\r\n        function warnIfStringRefCannotBeAutoConverted(config) {\r\n            {\r\n                if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\r\n                    var componentName = getComponentName(ReactCurrentOwner.current.type);\r\n                    if (!didWarnAboutStringRefs[componentName]) {\r\n                        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\r\n                        didWarnAboutStringRefs[componentName] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Factory method to create a new React element. This no longer adheres to\r\n         * the class pattern, so do not use new to call it. Also, instanceof check\r\n         * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\r\n         * if something is a React Element.\r\n         *\r\n         * @param {*} type\r\n         * @param {*} props\r\n         * @param {*} key\r\n         * @param {string|object} ref\r\n         * @param {*} owner\r\n         * @param {*} self A *temporary* helper to detect places where `this` is\r\n         * different from the `owner` when React.createElement is called, so that we\r\n         * can warn. We want to get rid of owner and replace string `ref`s with arrow\r\n         * functions, and as long as `this` and owner are the same, there will be no\r\n         * change in behavior.\r\n         * @param {*} source An annotation object (added by a transpiler or otherwise)\r\n         * indicating filename, line number, and/or other information.\r\n         * @internal\r\n         */\r\n        var ReactElement = function (type, key, ref, self, source, owner, props) {\r\n            var element = {\r\n                // This tag allows us to uniquely identify this as a React Element\r\n                $$typeof: REACT_ELEMENT_TYPE,\r\n                // Built-in properties that belong on the element\r\n                type: type,\r\n                key: key,\r\n                ref: ref,\r\n                props: props,\r\n                // Record the component responsible for creating this element.\r\n                _owner: owner\r\n            };\r\n            {\r\n                // The validation flag is currently mutative. We put it on\r\n                // an external backing store so that we can freeze the whole object.\r\n                // This can be replaced with a WeakMap once they are implemented in\r\n                // commonly used development environments.\r\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\r\n                // the validation flag non-enumerable (where possible, which should\r\n                // include every environment we run tests in), so the test framework\r\n                // ignores it.\r\n                Object.defineProperty(element._store, 'validated', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: true,\r\n                    value: false\r\n                }); // self and source are DEV only properties.\r\n                Object.defineProperty(element, '_self', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: false,\r\n                    value: self\r\n                }); // Two elements created in two different places should be considered\r\n                // equal for testing purposes and therefore we hide it from enumeration.\r\n                Object.defineProperty(element, '_source', {\r\n                    configurable: false,\r\n                    enumerable: false,\r\n                    writable: false,\r\n                    value: source\r\n                });\r\n                if (Object.freeze) {\r\n                    Object.freeze(element.props);\r\n                    Object.freeze(element);\r\n                }\r\n            }\r\n            return element;\r\n        };\r\n        /**\r\n         * Create and return a new ReactElement of the given type.\r\n         * See https://reactjs.org/docs/react-api.html#createelement\r\n         */\r\n        function createElement(type, config, children) {\r\n            var propName; // Reserved names are extracted\r\n            var props = {};\r\n            var key = null;\r\n            var ref = null;\r\n            var self = null;\r\n            var source = null;\r\n            if (config != null) {\r\n                if (hasValidRef(config)) {\r\n                    ref = config.ref;\r\n                    {\r\n                        warnIfStringRefCannotBeAutoConverted(config);\r\n                    }\r\n                }\r\n                if (hasValidKey(config)) {\r\n                    key = '' + config.key;\r\n                }\r\n                self = config.__self === undefined ? null : config.__self;\r\n                source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\r\n                for (propName in config) {\r\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                        props[propName] = config[propName];\r\n                    }\r\n                }\r\n            } // Children can be more than one argument, and those are transferred onto\r\n            // the newly allocated props object.\r\n            var childrenLength = arguments.length - 2;\r\n            if (childrenLength === 1) {\r\n                props.children = children;\r\n            }\r\n            else if (childrenLength > 1) {\r\n                var childArray = Array(childrenLength);\r\n                for (var i = 0; i < childrenLength; i++) {\r\n                    childArray[i] = arguments[i + 2];\r\n                }\r\n                {\r\n                    if (Object.freeze) {\r\n                        Object.freeze(childArray);\r\n                    }\r\n                }\r\n                props.children = childArray;\r\n            } // Resolve default props\r\n            if (type && type.defaultProps) {\r\n                var defaultProps = type.defaultProps;\r\n                for (propName in defaultProps) {\r\n                    if (props[propName] === undefined) {\r\n                        props[propName] = defaultProps[propName];\r\n                    }\r\n                }\r\n            }\r\n            {\r\n                if (key || ref) {\r\n                    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\r\n                    if (key) {\r\n                        defineKeyPropWarningGetter(props, displayName);\r\n                    }\r\n                    if (ref) {\r\n                        defineRefPropWarningGetter(props, displayName);\r\n                    }\r\n                }\r\n            }\r\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n        }\r\n        function cloneAndReplaceKey(oldElement, newKey) {\r\n            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\r\n            return newElement;\r\n        }\r\n        /**\r\n         * Clone and return a new ReactElement using element as the starting point.\r\n         * See https://reactjs.org/docs/react-api.html#cloneelement\r\n         */\r\n        function cloneElement(element, config, children) {\r\n            if (!!(element === null || element === undefined)) {\r\n                {\r\n                    throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\r\n                }\r\n            }\r\n            var propName; // Original props are copied\r\n            var props = _assign({}, element.props); // Reserved names are extracted\r\n            var key = element.key;\r\n            var ref = element.ref; // Self is preserved since the owner is preserved.\r\n            var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\r\n            // transpiler, and the original source is probably a better indicator of the\r\n            // true owner.\r\n            var source = element._source; // Owner will be preserved, unless ref is overridden\r\n            var owner = element._owner;\r\n            if (config != null) {\r\n                if (hasValidRef(config)) {\r\n                    // Silently steal the ref from the parent.\r\n                    ref = config.ref;\r\n                    owner = ReactCurrentOwner.current;\r\n                }\r\n                if (hasValidKey(config)) {\r\n                    key = '' + config.key;\r\n                } // Remaining properties override existing props\r\n                var defaultProps;\r\n                if (element.type && element.type.defaultProps) {\r\n                    defaultProps = element.type.defaultProps;\r\n                }\r\n                for (propName in config) {\r\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                        if (config[propName] === undefined && defaultProps !== undefined) {\r\n                            // Resolve default props\r\n                            props[propName] = defaultProps[propName];\r\n                        }\r\n                        else {\r\n                            props[propName] = config[propName];\r\n                        }\r\n                    }\r\n                }\r\n            } // Children can be more than one argument, and those are transferred onto\r\n            // the newly allocated props object.\r\n            var childrenLength = arguments.length - 2;\r\n            if (childrenLength === 1) {\r\n                props.children = children;\r\n            }\r\n            else if (childrenLength > 1) {\r\n                var childArray = Array(childrenLength);\r\n                for (var i = 0; i < childrenLength; i++) {\r\n                    childArray[i] = arguments[i + 2];\r\n                }\r\n                props.children = childArray;\r\n            }\r\n            return ReactElement(element.type, key, ref, self, source, owner, props);\r\n        }\r\n        /**\r\n         * Verifies the object is a ReactElement.\r\n         * See https://reactjs.org/docs/react-api.html#isvalidelement\r\n         * @param {?object} object\r\n         * @return {boolean} True if `object` is a ReactElement.\r\n         * @final\r\n         */\r\n        function isValidElement(object) {\r\n            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n        }\r\n        var SEPARATOR = '.';\r\n        var SUBSEPARATOR = ':';\r\n        /**\r\n         * Escape and wrap key so it is safe to use as a reactid\r\n         *\r\n         * @param {string} key to be escaped.\r\n         * @return {string} the escaped key.\r\n         */\r\n        function escape(key) {\r\n            var escapeRegex = /[=:]/g;\r\n            var escaperLookup = {\r\n                '=': '=0',\r\n                ':': '=2'\r\n            };\r\n            var escapedString = key.replace(escapeRegex, function (match) {\r\n                return escaperLookup[match];\r\n            });\r\n            return '$' + escapedString;\r\n        }\r\n        /**\r\n         * TODO: Test that a single child and an array with one item have the same key\r\n         * pattern.\r\n         */\r\n        var didWarnAboutMaps = false;\r\n        var userProvidedKeyEscapeRegex = /\\/+/g;\r\n        function escapeUserProvidedKey(text) {\r\n            return text.replace(userProvidedKeyEscapeRegex, '$&/');\r\n        }\r\n        /**\r\n         * Generate a key string that identifies a element within a set.\r\n         *\r\n         * @param {*} element A element that could contain a manual key.\r\n         * @param {number} index Index that is used if a manual key is not provided.\r\n         * @return {string}\r\n         */\r\n        function getElementKey(element, index) {\r\n            // Do some typechecking here since we call this blindly. We want to ensure\r\n            // that we don't block potential future ES APIs.\r\n            if (typeof element === 'object' && element !== null && element.key != null) {\r\n                // Explicit key\r\n                return escape('' + element.key);\r\n            } // Implicit key determined by the index in the set\r\n            return index.toString(36);\r\n        }\r\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\r\n            var type = typeof children;\r\n            if (type === 'undefined' || type === 'boolean') {\r\n                // All of the above are perceived as null.\r\n                children = null;\r\n            }\r\n            var invokeCallback = false;\r\n            if (children === null) {\r\n                invokeCallback = true;\r\n            }\r\n            else {\r\n                switch (type) {\r\n                    case 'string':\r\n                    case 'number':\r\n                        invokeCallback = true;\r\n                        break;\r\n                    case 'object':\r\n                        switch (children.$$typeof) {\r\n                            case REACT_ELEMENT_TYPE:\r\n                            case REACT_PORTAL_TYPE:\r\n                                invokeCallback = true;\r\n                        }\r\n                }\r\n            }\r\n            if (invokeCallback) {\r\n                var _child = children;\r\n                var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\r\n                // so that it's consistent if the number of children grows:\r\n                var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\r\n                if (Array.isArray(mappedChild)) {\r\n                    var escapedChildKey = '';\r\n                    if (childKey != null) {\r\n                        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\r\n                    }\r\n                    mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\r\n                        return c;\r\n                    });\r\n                }\r\n                else if (mappedChild != null) {\r\n                    if (isValidElement(mappedChild)) {\r\n                        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\r\n                        // traverseAllChildren used to do for objects as children\r\n                        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\r\n                        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\r\n                            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\r\n                    }\r\n                    array.push(mappedChild);\r\n                }\r\n                return 1;\r\n            }\r\n            var child;\r\n            var nextName;\r\n            var subtreeCount = 0; // Count of children found in the current subtree.\r\n            var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\r\n            if (Array.isArray(children)) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    child = children[i];\r\n                    nextName = nextNamePrefix + getElementKey(child, i);\r\n                    subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\r\n                }\r\n            }\r\n            else {\r\n                var iteratorFn = getIteratorFn(children);\r\n                if (typeof iteratorFn === 'function') {\r\n                    var iterableChildren = children;\r\n                    {\r\n                        // Warn about using Maps as children\r\n                        if (iteratorFn === iterableChildren.entries) {\r\n                            if (!didWarnAboutMaps) {\r\n                                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\r\n                            }\r\n                            didWarnAboutMaps = true;\r\n                        }\r\n                    }\r\n                    var iterator = iteratorFn.call(iterableChildren);\r\n                    var step;\r\n                    var ii = 0;\r\n                    while (!(step = iterator.next()).done) {\r\n                        child = step.value;\r\n                        nextName = nextNamePrefix + getElementKey(child, ii++);\r\n                        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\r\n                    }\r\n                }\r\n                else if (type === 'object') {\r\n                    var childrenString = '' + children;\r\n                    {\r\n                        {\r\n                            throw Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). If you meant to render a collection of children, use an array instead.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return subtreeCount;\r\n        }\r\n        /**\r\n         * Maps children that are typically specified as `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#reactchildrenmap\r\n         *\r\n         * The provided mapFunction(child, index) will be called for each\r\n         * leaf child.\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @param {function(*, int)} func The map function.\r\n         * @param {*} context Context for mapFunction.\r\n         * @return {object} Object containing the ordered map of results.\r\n         */\r\n        function mapChildren(children, func, context) {\r\n            if (children == null) {\r\n                return children;\r\n            }\r\n            var result = [];\r\n            var count = 0;\r\n            mapIntoArray(children, result, '', '', function (child) {\r\n                return func.call(context, child, count++);\r\n            });\r\n            return result;\r\n        }\r\n        /**\r\n         * Count the number of children that are typically specified as\r\n         * `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#reactchildrencount\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @return {number} The number of children.\r\n         */\r\n        function countChildren(children) {\r\n            var n = 0;\r\n            mapChildren(children, function () {\r\n                n++; // Don't return anything\r\n            });\r\n            return n;\r\n        }\r\n        /**\r\n         * Iterates through children that are typically specified as `props.children`.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\r\n         *\r\n         * The provided forEachFunc(child, index) will be called for each\r\n         * leaf child.\r\n         *\r\n         * @param {?*} children Children tree container.\r\n         * @param {function(*, int)} forEachFunc\r\n         * @param {*} forEachContext Context for forEachContext.\r\n         */\r\n        function forEachChildren(children, forEachFunc, forEachContext) {\r\n            mapChildren(children, function () {\r\n                forEachFunc.apply(this, arguments); // Don't return anything.\r\n            }, forEachContext);\r\n        }\r\n        /**\r\n         * Flatten a children object (typically specified as `props.children`) and\r\n         * return an array with appropriately re-keyed children.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\r\n         */\r\n        function toArray(children) {\r\n            return mapChildren(children, function (child) {\r\n                return child;\r\n            }) || [];\r\n        }\r\n        /**\r\n         * Returns the first child in a collection of children and verifies that there\r\n         * is only one child in the collection.\r\n         *\r\n         * See https://reactjs.org/docs/react-api.html#reactchildrenonly\r\n         *\r\n         * The current implementation of this function assumes that a single child gets\r\n         * passed without a wrapper, but the purpose of this helper function is to\r\n         * abstract away the particular structure of children.\r\n         *\r\n         * @param {?object} children Child collection structure.\r\n         * @return {ReactElement} The first and only `ReactElement` contained in the\r\n         * structure.\r\n         */\r\n        function onlyChild(children) {\r\n            if (!isValidElement(children)) {\r\n                {\r\n                    throw Error(\"React.Children.only expected to receive a single React element child.\");\r\n                }\r\n            }\r\n            return children;\r\n        }\r\n        function createContext(defaultValue, calculateChangedBits) {\r\n            if (calculateChangedBits === undefined) {\r\n                calculateChangedBits = null;\r\n            }\r\n            else {\r\n                {\r\n                    if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {\r\n                        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);\r\n                    }\r\n                }\r\n            }\r\n            var context = {\r\n                $$typeof: REACT_CONTEXT_TYPE,\r\n                _calculateChangedBits: calculateChangedBits,\r\n                // As a workaround to support multiple concurrent renderers, we categorize\r\n                // some renderers as primary and others as secondary. We only expect\r\n                // there to be two concurrent renderers at most: React Native (primary) and\r\n                // Fabric (secondary); React DOM (primary) and React ART (secondary).\r\n                // Secondary renderers store their context values on separate fields.\r\n                _currentValue: defaultValue,\r\n                _currentValue2: defaultValue,\r\n                // Used to track how many concurrent renderers this context currently\r\n                // supports within in a single renderer. Such as parallel server rendering.\r\n                _threadCount: 0,\r\n                // These are circular\r\n                Provider: null,\r\n                Consumer: null\r\n            };\r\n            context.Provider = {\r\n                $$typeof: REACT_PROVIDER_TYPE,\r\n                _context: context\r\n            };\r\n            var hasWarnedAboutUsingNestedContextConsumers = false;\r\n            var hasWarnedAboutUsingConsumerProvider = false;\r\n            var hasWarnedAboutDisplayNameOnConsumer = false;\r\n            {\r\n                // A separate object, but proxies back to the original context object for\r\n                // backwards compatibility. It has a different $$typeof, so we can properly\r\n                // warn for the incorrect usage of Context as a Consumer.\r\n                var Consumer = {\r\n                    $$typeof: REACT_CONTEXT_TYPE,\r\n                    _context: context,\r\n                    _calculateChangedBits: context._calculateChangedBits\r\n                }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\r\n                Object.defineProperties(Consumer, {\r\n                    Provider: {\r\n                        get: function () {\r\n                            if (!hasWarnedAboutUsingConsumerProvider) {\r\n                                hasWarnedAboutUsingConsumerProvider = true;\r\n                                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\r\n                            }\r\n                            return context.Provider;\r\n                        },\r\n                        set: function (_Provider) {\r\n                            context.Provider = _Provider;\r\n                        }\r\n                    },\r\n                    _currentValue: {\r\n                        get: function () {\r\n                            return context._currentValue;\r\n                        },\r\n                        set: function (_currentValue) {\r\n                            context._currentValue = _currentValue;\r\n                        }\r\n                    },\r\n                    _currentValue2: {\r\n                        get: function () {\r\n                            return context._currentValue2;\r\n                        },\r\n                        set: function (_currentValue2) {\r\n                            context._currentValue2 = _currentValue2;\r\n                        }\r\n                    },\r\n                    _threadCount: {\r\n                        get: function () {\r\n                            return context._threadCount;\r\n                        },\r\n                        set: function (_threadCount) {\r\n                            context._threadCount = _threadCount;\r\n                        }\r\n                    },\r\n                    Consumer: {\r\n                        get: function () {\r\n                            if (!hasWarnedAboutUsingNestedContextConsumers) {\r\n                                hasWarnedAboutUsingNestedContextConsumers = true;\r\n                                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\r\n                            }\r\n                            return context.Consumer;\r\n                        }\r\n                    },\r\n                    displayName: {\r\n                        get: function () {\r\n                            return context.displayName;\r\n                        },\r\n                        set: function (displayName) {\r\n                            if (!hasWarnedAboutDisplayNameOnConsumer) {\r\n                                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\r\n                                hasWarnedAboutDisplayNameOnConsumer = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\r\n                context.Consumer = Consumer;\r\n            }\r\n            {\r\n                context._currentRenderer = null;\r\n                context._currentRenderer2 = null;\r\n            }\r\n            return context;\r\n        }\r\n        var Uninitialized = -1;\r\n        var Pending = 0;\r\n        var Resolved = 1;\r\n        var Rejected = 2;\r\n        function lazyInitializer(payload) {\r\n            if (payload._status === Uninitialized) {\r\n                var ctor = payload._result;\r\n                var thenable = ctor(); // Transition to the next state.\r\n                var pending = payload;\r\n                pending._status = Pending;\r\n                pending._result = thenable;\r\n                thenable.then(function (moduleObject) {\r\n                    if (payload._status === Pending) {\r\n                        var defaultExport = moduleObject.default;\r\n                        {\r\n                            if (defaultExport === undefined) {\r\n                                error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\r\n                                    'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\r\n                            }\r\n                        } // Transition to the next state.\r\n                        var resolved = payload;\r\n                        resolved._status = Resolved;\r\n                        resolved._result = defaultExport;\r\n                    }\r\n                }, function (error) {\r\n                    if (payload._status === Pending) {\r\n                        // Transition to the next state.\r\n                        var rejected = payload;\r\n                        rejected._status = Rejected;\r\n                        rejected._result = error;\r\n                    }\r\n                });\r\n            }\r\n            if (payload._status === Resolved) {\r\n                return payload._result;\r\n            }\r\n            else {\r\n                throw payload._result;\r\n            }\r\n        }\r\n        function lazy(ctor) {\r\n            var payload = {\r\n                // We use these fields to store the result.\r\n                _status: -1,\r\n                _result: ctor\r\n            };\r\n            var lazyType = {\r\n                $$typeof: REACT_LAZY_TYPE,\r\n                _payload: payload,\r\n                _init: lazyInitializer\r\n            };\r\n            {\r\n                // In production, this would just set it on the object.\r\n                var defaultProps;\r\n                var propTypes; // $FlowFixMe\r\n                Object.defineProperties(lazyType, {\r\n                    defaultProps: {\r\n                        configurable: true,\r\n                        get: function () {\r\n                            return defaultProps;\r\n                        },\r\n                        set: function (newDefaultProps) {\r\n                            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\r\n                            defaultProps = newDefaultProps; // Match production behavior more closely:\r\n                            // $FlowFixMe\r\n                            Object.defineProperty(lazyType, 'defaultProps', {\r\n                                enumerable: true\r\n                            });\r\n                        }\r\n                    },\r\n                    propTypes: {\r\n                        configurable: true,\r\n                        get: function () {\r\n                            return propTypes;\r\n                        },\r\n                        set: function (newPropTypes) {\r\n                            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\r\n                            propTypes = newPropTypes; // Match production behavior more closely:\r\n                            // $FlowFixMe\r\n                            Object.defineProperty(lazyType, 'propTypes', {\r\n                                enumerable: true\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return lazyType;\r\n        }\r\n        function forwardRef(render) {\r\n            {\r\n                if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\r\n                    error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\r\n                }\r\n                else if (typeof render !== 'function') {\r\n                    error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\r\n                }\r\n                else {\r\n                    if (render.length !== 0 && render.length !== 2) {\r\n                        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\r\n                    }\r\n                }\r\n                if (render != null) {\r\n                    if (render.defaultProps != null || render.propTypes != null) {\r\n                        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\r\n                    }\r\n                }\r\n            }\r\n            var elementType = {\r\n                $$typeof: REACT_FORWARD_REF_TYPE,\r\n                render: render\r\n            };\r\n            {\r\n                var ownName;\r\n                Object.defineProperty(elementType, 'displayName', {\r\n                    enumerable: false,\r\n                    configurable: true,\r\n                    get: function () {\r\n                        return ownName;\r\n                    },\r\n                    set: function (name) {\r\n                        ownName = name;\r\n                        if (render.displayName == null) {\r\n                            render.displayName = name;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return elementType;\r\n        }\r\n        // Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\r\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\r\n        function isValidElementType(type) {\r\n            if (typeof type === 'string' || typeof type === 'function') {\r\n                return true;\r\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\r\n            if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {\r\n                return true;\r\n            }\r\n            if (typeof type === 'object' && type !== null) {\r\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function memo(type, compare) {\r\n            {\r\n                if (!isValidElementType(type)) {\r\n                    error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\r\n                }\r\n            }\r\n            var elementType = {\r\n                $$typeof: REACT_MEMO_TYPE,\r\n                type: type,\r\n                compare: compare === undefined ? null : compare\r\n            };\r\n            {\r\n                var ownName;\r\n                Object.defineProperty(elementType, 'displayName', {\r\n                    enumerable: false,\r\n                    configurable: true,\r\n                    get: function () {\r\n                        return ownName;\r\n                    },\r\n                    set: function (name) {\r\n                        ownName = name;\r\n                        if (type.displayName == null) {\r\n                            type.displayName = name;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            return elementType;\r\n        }\r\n        function resolveDispatcher() {\r\n            var dispatcher = ReactCurrentDispatcher.current;\r\n            if (!(dispatcher !== null)) {\r\n                {\r\n                    throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\r\n                }\r\n            }\r\n            return dispatcher;\r\n        }\r\n        function useContext(Context, unstable_observedBits) {\r\n            var dispatcher = resolveDispatcher();\r\n            {\r\n                if (unstable_observedBits !== undefined) {\r\n                    error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\\n\\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');\r\n                } // TODO: add a more generic warning for invalid values.\r\n                if (Context._context !== undefined) {\r\n                    var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\r\n                    // and nobody should be using this in existing code.\r\n                    if (realContext.Consumer === Context) {\r\n                        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\r\n                    }\r\n                    else if (realContext.Provider === Context) {\r\n                        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\r\n                    }\r\n                }\r\n            }\r\n            return dispatcher.useContext(Context, unstable_observedBits);\r\n        }\r\n        function useState(initialState) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useState(initialState);\r\n        }\r\n        function useReducer(reducer, initialArg, init) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useReducer(reducer, initialArg, init);\r\n        }\r\n        function useRef(initialValue) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useRef(initialValue);\r\n        }\r\n        function useEffect(create, deps) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useEffect(create, deps);\r\n        }\r\n        function useLayoutEffect(create, deps) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useLayoutEffect(create, deps);\r\n        }\r\n        function useCallback(callback, deps) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useCallback(callback, deps);\r\n        }\r\n        function useMemo(create, deps) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useMemo(create, deps);\r\n        }\r\n        function useImperativeHandle(ref, create, deps) {\r\n            var dispatcher = resolveDispatcher();\r\n            return dispatcher.useImperativeHandle(ref, create, deps);\r\n        }\r\n        function useDebugValue(value, formatterFn) {\r\n            {\r\n                var dispatcher = resolveDispatcher();\r\n                return dispatcher.useDebugValue(value, formatterFn);\r\n            }\r\n        }\r\n        // Helpers to patch console.logs to avoid logging during side-effect free\r\n        // replaying on render function. This currently only patches the object\r\n        // lazily which won't cover if the log function was extracted eagerly.\r\n        // We could also eagerly patch the method.\r\n        var disabledDepth = 0;\r\n        var prevLog;\r\n        var prevInfo;\r\n        var prevWarn;\r\n        var prevError;\r\n        var prevGroup;\r\n        var prevGroupCollapsed;\r\n        var prevGroupEnd;\r\n        function disabledLog() { }\r\n        disabledLog.__reactDisabledLog = true;\r\n        function disableLogs() {\r\n            {\r\n                if (disabledDepth === 0) {\r\n                    /* eslint-disable react-internal/no-production-logging */\r\n                    prevLog = console.log;\r\n                    prevInfo = console.info;\r\n                    prevWarn = console.warn;\r\n                    prevError = console.error;\r\n                    prevGroup = console.group;\r\n                    prevGroupCollapsed = console.groupCollapsed;\r\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\r\n                    var props = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        value: disabledLog,\r\n                        writable: true\r\n                    }; // $FlowFixMe Flow thinks console is immutable.\r\n                    Object.defineProperties(console, {\r\n                        info: props,\r\n                        log: props,\r\n                        warn: props,\r\n                        error: props,\r\n                        group: props,\r\n                        groupCollapsed: props,\r\n                        groupEnd: props\r\n                    });\r\n                    /* eslint-enable react-internal/no-production-logging */\r\n                }\r\n                disabledDepth++;\r\n            }\r\n        }\r\n        function reenableLogs() {\r\n            {\r\n                disabledDepth--;\r\n                if (disabledDepth === 0) {\r\n                    /* eslint-disable react-internal/no-production-logging */\r\n                    var props = {\r\n                        configurable: true,\r\n                        enumerable: true,\r\n                        writable: true\r\n                    }; // $FlowFixMe Flow thinks console is immutable.\r\n                    Object.defineProperties(console, {\r\n                        log: _assign({}, props, {\r\n                            value: prevLog\r\n                        }),\r\n                        info: _assign({}, props, {\r\n                            value: prevInfo\r\n                        }),\r\n                        warn: _assign({}, props, {\r\n                            value: prevWarn\r\n                        }),\r\n                        error: _assign({}, props, {\r\n                            value: prevError\r\n                        }),\r\n                        group: _assign({}, props, {\r\n                            value: prevGroup\r\n                        }),\r\n                        groupCollapsed: _assign({}, props, {\r\n                            value: prevGroupCollapsed\r\n                        }),\r\n                        groupEnd: _assign({}, props, {\r\n                            value: prevGroupEnd\r\n                        })\r\n                    });\r\n                    /* eslint-enable react-internal/no-production-logging */\r\n                }\r\n                if (disabledDepth < 0) {\r\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\r\n                }\r\n            }\r\n        }\r\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\r\n        var prefix;\r\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\r\n            {\r\n                if (prefix === undefined) {\r\n                    // Extract the VM specific prefix used by each line.\r\n                    try {\r\n                        throw Error();\r\n                    }\r\n                    catch (x) {\r\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\r\n                        prefix = match && match[1] || '';\r\n                    }\r\n                } // We use the prefix to ensure our stacks line up with native stack frames.\r\n                return '\\n' + prefix + name;\r\n            }\r\n        }\r\n        var reentry = false;\r\n        var componentFrameCache;\r\n        {\r\n            var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\r\n            componentFrameCache = new PossiblyWeakMap();\r\n        }\r\n        function describeNativeComponentFrame(fn, construct) {\r\n            // If something asked for a stack inside a fake render, it should get ignored.\r\n            if (!fn || reentry) {\r\n                return '';\r\n            }\r\n            {\r\n                var frame = componentFrameCache.get(fn);\r\n                if (frame !== undefined) {\r\n                    return frame;\r\n                }\r\n            }\r\n            var control;\r\n            reentry = true;\r\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\r\n            Error.prepareStackTrace = undefined;\r\n            var previousDispatcher;\r\n            {\r\n                previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\r\n                // for warnings.\r\n                ReactCurrentDispatcher$1.current = null;\r\n                disableLogs();\r\n            }\r\n            try {\r\n                // This should throw.\r\n                if (construct) {\r\n                    // Something should be setting the props in the constructor.\r\n                    var Fake = function () {\r\n                        throw Error();\r\n                    }; // $FlowFixMe\r\n                    Object.defineProperty(Fake.prototype, 'props', {\r\n                        set: function () {\r\n                            // We use a throwing setter instead of frozen or non-writable props\r\n                            // because that won't throw in a non-strict mode function.\r\n                            throw Error();\r\n                        }\r\n                    });\r\n                    if (typeof Reflect === 'object' && Reflect.construct) {\r\n                        // We construct a different control for this case to include any extra\r\n                        // frames added by the construct call.\r\n                        try {\r\n                            Reflect.construct(Fake, []);\r\n                        }\r\n                        catch (x) {\r\n                            control = x;\r\n                        }\r\n                        Reflect.construct(fn, [], Fake);\r\n                    }\r\n                    else {\r\n                        try {\r\n                            Fake.call();\r\n                        }\r\n                        catch (x) {\r\n                            control = x;\r\n                        }\r\n                        fn.call(Fake.prototype);\r\n                    }\r\n                }\r\n                else {\r\n                    try {\r\n                        throw Error();\r\n                    }\r\n                    catch (x) {\r\n                        control = x;\r\n                    }\r\n                    fn();\r\n                }\r\n            }\r\n            catch (sample) {\r\n                // This is inlined manually because closure doesn't do it for us.\r\n                if (sample && control && typeof sample.stack === 'string') {\r\n                    // This extracts the first frame from the sample that isn't also in the control.\r\n                    // Skipping one frame that we assume is the frame that calls the two.\r\n                    var sampleLines = sample.stack.split('\\n');\r\n                    var controlLines = control.stack.split('\\n');\r\n                    var s = sampleLines.length - 1;\r\n                    var c = controlLines.length - 1;\r\n                    while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\r\n                        // We expect at least one stack frame to be shared.\r\n                        // Typically this will be the root most one. However, stack frames may be\r\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\r\n                        // earlier than the other. We assume that the sample is longer or the same\r\n                        // and there for cut off earlier. So we should find the root most frame in\r\n                        // the sample somewhere in the control.\r\n                        c--;\r\n                    }\r\n                    for (; s >= 1 && c >= 0; s--, c--) {\r\n                        // Next we find the first one that isn't the same which should be the\r\n                        // frame that called our sample function and the control.\r\n                        if (sampleLines[s] !== controlLines[c]) {\r\n                            // In V8, the first line is describing the message but other VMs don't.\r\n                            // If we're about to return the first line, and the control is also on the same\r\n                            // line, that's a pretty good indicator that our sample threw at same line as\r\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\r\n                            // This can happen if you passed a class to function component, or non-function.\r\n                            if (s !== 1 || c !== 1) {\r\n                                do {\r\n                                    s--;\r\n                                    c--; // We may still have similar intermediate frames from the construct call.\r\n                                    // The next one that isn't the same should be our match though.\r\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\r\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\r\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\r\n                                        {\r\n                                            if (typeof fn === 'function') {\r\n                                                componentFrameCache.set(fn, _frame);\r\n                                            }\r\n                                        } // Return the line we found.\r\n                                        return _frame;\r\n                                    }\r\n                                } while (s >= 1 && c >= 0);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            finally {\r\n                reentry = false;\r\n                {\r\n                    ReactCurrentDispatcher$1.current = previousDispatcher;\r\n                    reenableLogs();\r\n                }\r\n                Error.prepareStackTrace = previousPrepareStackTrace;\r\n            } // Fallback to just using the name if we couldn't make it throw.\r\n            var name = fn ? fn.displayName || fn.name : '';\r\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\r\n            {\r\n                if (typeof fn === 'function') {\r\n                    componentFrameCache.set(fn, syntheticFrame);\r\n                }\r\n            }\r\n            return syntheticFrame;\r\n        }\r\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\r\n            {\r\n                return describeNativeComponentFrame(fn, false);\r\n            }\r\n        }\r\n        function shouldConstruct(Component) {\r\n            var prototype = Component.prototype;\r\n            return !!(prototype && prototype.isReactComponent);\r\n        }\r\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n            if (type == null) {\r\n                return '';\r\n            }\r\n            if (typeof type === 'function') {\r\n                {\r\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\r\n                }\r\n            }\r\n            if (typeof type === 'string') {\r\n                return describeBuiltInComponentFrame(type);\r\n            }\r\n            switch (type) {\r\n                case exports.Suspense:\r\n                    return describeBuiltInComponentFrame('Suspense');\r\n                case REACT_SUSPENSE_LIST_TYPE:\r\n                    return describeBuiltInComponentFrame('SuspenseList');\r\n            }\r\n            if (typeof type === 'object') {\r\n                switch (type.$$typeof) {\r\n                    case REACT_FORWARD_REF_TYPE:\r\n                        return describeFunctionComponentFrame(type.render);\r\n                    case REACT_MEMO_TYPE:\r\n                        // Memo may contain any component type so we recursively resolve it.\r\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n                    case REACT_BLOCK_TYPE:\r\n                        return describeFunctionComponentFrame(type._render);\r\n                    case REACT_LAZY_TYPE:\r\n                        {\r\n                            var lazyComponent = type;\r\n                            var payload = lazyComponent._payload;\r\n                            var init = lazyComponent._init;\r\n                            try {\r\n                                // Lazy may contain any component type so we recursively resolve it.\r\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n                            }\r\n                            catch (x) { }\r\n                        }\r\n                }\r\n            }\r\n            return '';\r\n        }\r\n        var loggedTypeFailures = {};\r\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n        function setCurrentlyValidatingElement(element) {\r\n            {\r\n                if (element) {\r\n                    var owner = element._owner;\r\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n                }\r\n                else {\r\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n                }\r\n            }\r\n        }\r\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n            {\r\n                // $FlowFixMe This is okay but Flow doesn't know it.\r\n                var has = Function.call.bind(Object.prototype.hasOwnProperty);\r\n                for (var typeSpecName in typeSpecs) {\r\n                    if (has(typeSpecs, typeSpecName)) {\r\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\r\n                        // fail the render phase where it didn't fail before. So we log it.\r\n                        // After these have been cleaned up, we'll let them throw.\r\n                        try {\r\n                            // This is intentionally an invariant that gets caught. It's the same\r\n                            // behavior as without this statement except with a better message.\r\n                            if (typeof typeSpecs[typeSpecName] !== 'function') {\r\n                                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\r\n                                err.name = 'Invariant Violation';\r\n                                throw err;\r\n                            }\r\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\r\n                        }\r\n                        catch (ex) {\r\n                            error$1 = ex;\r\n                        }\r\n                        if (error$1 && !(error$1 instanceof Error)) {\r\n                            setCurrentlyValidatingElement(element);\r\n                            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\r\n                            setCurrentlyValidatingElement(null);\r\n                        }\r\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n                            // Only monitor this failure once because there tends to be a lot of the\r\n                            // same error.\r\n                            loggedTypeFailures[error$1.message] = true;\r\n                            setCurrentlyValidatingElement(element);\r\n                            error('Failed %s type: %s', location, error$1.message);\r\n                            setCurrentlyValidatingElement(null);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function setCurrentlyValidatingElement$1(element) {\r\n            {\r\n                if (element) {\r\n                    var owner = element._owner;\r\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n                    setExtraStackFrame(stack);\r\n                }\r\n                else {\r\n                    setExtraStackFrame(null);\r\n                }\r\n            }\r\n        }\r\n        var propTypesMisspellWarningShown;\r\n        {\r\n            propTypesMisspellWarningShown = false;\r\n        }\r\n        function getDeclarationErrorAddendum() {\r\n            if (ReactCurrentOwner.current) {\r\n                var name = getComponentName(ReactCurrentOwner.current.type);\r\n                if (name) {\r\n                    return '\\n\\nCheck the render method of `' + name + '`.';\r\n                }\r\n            }\r\n            return '';\r\n        }\r\n        function getSourceInfoErrorAddendum(source) {\r\n            if (source !== undefined) {\r\n                var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\r\n                var lineNumber = source.lineNumber;\r\n                return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\r\n            }\r\n            return '';\r\n        }\r\n        function getSourceInfoErrorAddendumForProps(elementProps) {\r\n            if (elementProps !== null && elementProps !== undefined) {\r\n                return getSourceInfoErrorAddendum(elementProps.__source);\r\n            }\r\n            return '';\r\n        }\r\n        /**\r\n         * Warn if there's no key explicitly set on dynamic arrays of children or\r\n         * object keys are not valid. This allows us to keep track of children between\r\n         * updates.\r\n         */\r\n        var ownerHasKeyUseWarning = {};\r\n        function getCurrentComponentErrorInfo(parentType) {\r\n            var info = getDeclarationErrorAddendum();\r\n            if (!info) {\r\n                var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\r\n                if (parentName) {\r\n                    info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n                }\r\n            }\r\n            return info;\r\n        }\r\n        /**\r\n         * Warn if the element doesn't have an explicit key assigned to it.\r\n         * This element is in an array. The array could grow and shrink or be\r\n         * reordered. All children that haven't already been validated are required to\r\n         * have a \"key\" property assigned to it. Error statuses are cached so a warning\r\n         * will only be shown once.\r\n         *\r\n         * @internal\r\n         * @param {ReactElement} element Element that requires a key.\r\n         * @param {*} parentType element's parent's type.\r\n         */\r\n        function validateExplicitKey(element, parentType) {\r\n            if (!element._store || element._store.validated || element.key != null) {\r\n                return;\r\n            }\r\n            element._store.validated = true;\r\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n                return;\r\n            }\r\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\r\n            // property, it may be the creator of the child that's responsible for\r\n            // assigning it a key.\r\n            var childOwner = '';\r\n            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\r\n                // Give the component that originally created this child.\r\n                childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\r\n            }\r\n            {\r\n                setCurrentlyValidatingElement$1(element);\r\n                error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n                setCurrentlyValidatingElement$1(null);\r\n            }\r\n        }\r\n        /**\r\n         * Ensure that every element either is passed in a static location, in an\r\n         * array with an explicit keys property defined, or in an object literal\r\n         * with valid key property.\r\n         *\r\n         * @internal\r\n         * @param {ReactNode} node Statically passed child of any type.\r\n         * @param {*} parentType node's parent's type.\r\n         */\r\n        function validateChildKeys(node, parentType) {\r\n            if (typeof node !== 'object') {\r\n                return;\r\n            }\r\n            if (Array.isArray(node)) {\r\n                for (var i = 0; i < node.length; i++) {\r\n                    var child = node[i];\r\n                    if (isValidElement(child)) {\r\n                        validateExplicitKey(child, parentType);\r\n                    }\r\n                }\r\n            }\r\n            else if (isValidElement(node)) {\r\n                // This element was passed in a valid location.\r\n                if (node._store) {\r\n                    node._store.validated = true;\r\n                }\r\n            }\r\n            else if (node) {\r\n                var iteratorFn = getIteratorFn(node);\r\n                if (typeof iteratorFn === 'function') {\r\n                    // Entry iterators used to provide implicit keys,\r\n                    // but now we print a separate warning for them later.\r\n                    if (iteratorFn !== node.entries) {\r\n                        var iterator = iteratorFn.call(node);\r\n                        var step;\r\n                        while (!(step = iterator.next()).done) {\r\n                            if (isValidElement(step.value)) {\r\n                                validateExplicitKey(step.value, parentType);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Given an element, validate that its props follow the propTypes definition,\r\n         * provided by the type.\r\n         *\r\n         * @param {ReactElement} element\r\n         */\r\n        function validatePropTypes(element) {\r\n            {\r\n                var type = element.type;\r\n                if (type === null || type === undefined || typeof type === 'string') {\r\n                    return;\r\n                }\r\n                var propTypes;\r\n                if (typeof type === 'function') {\r\n                    propTypes = type.propTypes;\r\n                }\r\n                else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\r\n                    // Inner props are checked in the reconciler.\r\n                    type.$$typeof === REACT_MEMO_TYPE)) {\r\n                    propTypes = type.propTypes;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n                if (propTypes) {\r\n                    // Intentionally inside to avoid triggering lazy initializers:\r\n                    var name = getComponentName(type);\r\n                    checkPropTypes(propTypes, element.props, 'prop', name, element);\r\n                }\r\n                else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\r\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\r\n                    var _name = getComponentName(type);\r\n                    error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\r\n                }\r\n                if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\r\n                    error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Given a fragment, validate that it can only be provided with fragment props\r\n         * @param {ReactElement} fragment\r\n         */\r\n        function validateFragmentProps(fragment) {\r\n            {\r\n                var keys = Object.keys(fragment.props);\r\n                for (var i = 0; i < keys.length; i++) {\r\n                    var key = keys[i];\r\n                    if (key !== 'children' && key !== 'key') {\r\n                        setCurrentlyValidatingElement$1(fragment);\r\n                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\r\n                        setCurrentlyValidatingElement$1(null);\r\n                        break;\r\n                    }\r\n                }\r\n                if (fragment.ref !== null) {\r\n                    setCurrentlyValidatingElement$1(fragment);\r\n                    error('Invalid attribute `ref` supplied to `React.Fragment`.');\r\n                    setCurrentlyValidatingElement$1(null);\r\n                }\r\n            }\r\n        }\r\n        function createElementWithValidation(type, props, children) {\r\n            var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\r\n            // succeed and there will likely be errors in render.\r\n            if (!validType) {\r\n                var info = '';\r\n                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\r\n                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\r\n                }\r\n                var sourceInfo = getSourceInfoErrorAddendumForProps(props);\r\n                if (sourceInfo) {\r\n                    info += sourceInfo;\r\n                }\r\n                else {\r\n                    info += getDeclarationErrorAddendum();\r\n                }\r\n                var typeString;\r\n                if (type === null) {\r\n                    typeString = 'null';\r\n                }\r\n                else if (Array.isArray(type)) {\r\n                    typeString = 'array';\r\n                }\r\n                else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n                    typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\r\n                    info = ' Did you accidentally export a JSX literal instead of a component?';\r\n                }\r\n                else {\r\n                    typeString = typeof type;\r\n                }\r\n                {\r\n                    error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\r\n                }\r\n            }\r\n            var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\r\n            // TODO: Drop this when these are no longer allowed as the type argument.\r\n            if (element == null) {\r\n                return element;\r\n            } // Skip key warning if the type isn't valid since our key validation logic\r\n            // doesn't expect a non-string/function type and can throw confusing errors.\r\n            // We don't want exception behavior to differ between dev and prod.\r\n            // (Rendering will throw with a helpful message and as soon as the type is\r\n            // fixed, the key warnings will appear.)\r\n            if (validType) {\r\n                for (var i = 2; i < arguments.length; i++) {\r\n                    validateChildKeys(arguments[i], type);\r\n                }\r\n            }\r\n            if (type === exports.Fragment) {\r\n                validateFragmentProps(element);\r\n            }\r\n            else {\r\n                validatePropTypes(element);\r\n            }\r\n            return element;\r\n        }\r\n        var didWarnAboutDeprecatedCreateFactory = false;\r\n        function createFactoryWithValidation(type) {\r\n            var validatedFactory = createElementWithValidation.bind(null, type);\r\n            validatedFactory.type = type;\r\n            {\r\n                if (!didWarnAboutDeprecatedCreateFactory) {\r\n                    didWarnAboutDeprecatedCreateFactory = true;\r\n                    warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\r\n                } // Legacy hook: remove it\r\n                Object.defineProperty(validatedFactory, 'type', {\r\n                    enumerable: false,\r\n                    get: function () {\r\n                        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\r\n                        Object.defineProperty(this, 'type', {\r\n                            value: type\r\n                        });\r\n                        return type;\r\n                    }\r\n                });\r\n            }\r\n            return validatedFactory;\r\n        }\r\n        function cloneElementWithValidation(element, props, children) {\r\n            var newElement = cloneElement.apply(this, arguments);\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                validateChildKeys(arguments[i], newElement.type);\r\n            }\r\n            validatePropTypes(newElement);\r\n            return newElement;\r\n        }\r\n        {\r\n            try {\r\n                var frozenObject = Object.freeze({});\r\n                /* eslint-disable no-new */\r\n                new Map([[frozenObject, null]]);\r\n                new Set([frozenObject]);\r\n                /* eslint-enable no-new */\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        var createElement$1 = createElementWithValidation;\r\n        var cloneElement$1 = cloneElementWithValidation;\r\n        var createFactory = createFactoryWithValidation;\r\n        var Children = {\r\n            map: mapChildren,\r\n            forEach: forEachChildren,\r\n            count: countChildren,\r\n            toArray: toArray,\r\n            only: onlyChild\r\n        };\r\n        exports.Children = Children;\r\n        exports.Component = Component;\r\n        exports.PureComponent = PureComponent;\r\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\r\n        exports.cloneElement = cloneElement$1;\r\n        exports.createContext = createContext;\r\n        exports.createElement = createElement$1;\r\n        exports.createFactory = createFactory;\r\n        exports.createRef = createRef;\r\n        exports.forwardRef = forwardRef;\r\n        exports.isValidElement = isValidElement;\r\n        exports.lazy = lazy;\r\n        exports.memo = memo;\r\n        exports.useCallback = useCallback;\r\n        exports.useContext = useContext;\r\n        exports.useDebugValue = useDebugValue;\r\n        exports.useEffect = useEffect;\r\n        exports.useImperativeHandle = useImperativeHandle;\r\n        exports.useLayoutEffect = useLayoutEffect;\r\n        exports.useMemo = useMemo;\r\n        exports.useReducer = useReducer;\r\n        exports.useRef = useRef;\r\n        exports.useState = useState;\r\n        exports.version = ReactVersion;\r\n    })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzPzcyZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7R0FPRztBQUVVO0FBRWIsSUFBSSxJQUFxQyxFQUFFO0lBQ3pDLENBQUM7UUFDSCxZQUFZLENBQUM7UUFFYixJQUFJLE9BQU8sR0FBRyxtQkFBTyxDQUFDLDREQUFlLENBQUMsQ0FBQztRQUV2QywrREFBK0Q7UUFDL0QsSUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDO1FBRTVCLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLG1GQUFtRjtRQUNuRiw2REFBNkQ7UUFDN0QsSUFBSSxrQkFBa0IsR0FBRyxNQUFNLENBQUM7UUFDaEMsSUFBSSxpQkFBaUIsR0FBRyxNQUFNLENBQUM7UUFDL0IsT0FBTyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7UUFDMUIsT0FBTyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUM7UUFDNUIsT0FBTyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7UUFDMUIsSUFBSSxtQkFBbUIsR0FBRyxNQUFNLENBQUM7UUFDakMsSUFBSSxrQkFBa0IsR0FBRyxNQUFNLENBQUM7UUFDaEMsSUFBSSxzQkFBc0IsR0FBRyxNQUFNLENBQUM7UUFDcEMsT0FBTyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUM7UUFDMUIsSUFBSSx3QkFBd0IsR0FBRyxNQUFNLENBQUM7UUFDdEMsSUFBSSxlQUFlLEdBQUcsTUFBTSxDQUFDO1FBQzdCLElBQUksZUFBZSxHQUFHLE1BQU0sQ0FBQztRQUM3QixJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQztRQUM5QixJQUFJLHVCQUF1QixHQUFHLE1BQU0sQ0FBQztRQUNyQyxJQUFJLHNCQUFzQixHQUFHLE1BQU0sQ0FBQztRQUNwQyxJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQztRQUM5QixJQUFJLG9CQUFvQixHQUFHLE1BQU0sQ0FB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cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4xXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4xJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react.development.js\n");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (false) {}\r\nelse {\r\n    module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanM/YWI1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztLQUFNO0lBQ0wsTUFBTSxDQUFDLE9BQU8sR0FBRyxtQkFBTyxDQUFDLGlGQUE0QixDQUFDLENBQUM7Q0FDeEQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/index.js\n");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v0.20.1\r\n * scheduler-tracing.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nif (true) {\r\n    (function () {\r\n        'use strict';\r\n        var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.\r\n        var interactionIDCounter = 0;\r\n        var threadIDCounter = 0; // Set of currently traced interactions.\r\n        // Interactions \"stack\"–\r\n        // Meaning that newly traced interactions are appended to the previously active set.\r\n        // When an interaction goes out of scope, the previous set (if any) is restored.\r\n        exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.\r\n        exports.__subscriberRef = null;\r\n        {\r\n            exports.__interactionsRef = {\r\n                current: new Set()\r\n            };\r\n            exports.__subscriberRef = {\r\n                current: null\r\n            };\r\n        }\r\n        function unstable_clear(callback) {\r\n            var prevInteractions = exports.__interactionsRef.current;\r\n            exports.__interactionsRef.current = new Set();\r\n            try {\r\n                return callback();\r\n            }\r\n            finally {\r\n                exports.__interactionsRef.current = prevInteractions;\r\n            }\r\n        }\r\n        function unstable_getCurrent() {\r\n            {\r\n                return exports.__interactionsRef.current;\r\n            }\r\n        }\r\n        function unstable_getThreadID() {\r\n            return ++threadIDCounter;\r\n        }\r\n        function unstable_trace(name, timestamp, callback) {\r\n            var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\r\n            var interaction = {\r\n                __count: 1,\r\n                id: interactionIDCounter++,\r\n                name: name,\r\n                timestamp: timestamp\r\n            };\r\n            var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.\r\n            // To do that, clone the current interactions.\r\n            // The previous set will be restored upon completion.\r\n            var interactions = new Set(prevInteractions);\r\n            interactions.add(interaction);\r\n            exports.__interactionsRef.current = interactions;\r\n            var subscriber = exports.__subscriberRef.current;\r\n            var returnValue;\r\n            try {\r\n                if (subscriber !== null) {\r\n                    subscriber.onInteractionTraced(interaction);\r\n                }\r\n            }\r\n            finally {\r\n                try {\r\n                    if (subscriber !== null) {\r\n                        subscriber.onWorkStarted(interactions, threadID);\r\n                    }\r\n                }\r\n                finally {\r\n                    try {\r\n                        returnValue = callback();\r\n                    }\r\n                    finally {\r\n                        exports.__interactionsRef.current = prevInteractions;\r\n                        try {\r\n                            if (subscriber !== null) {\r\n                                subscriber.onWorkStopped(interactions, threadID);\r\n                            }\r\n                        }\r\n                        finally {\r\n                            interaction.__count--; // If no async work was scheduled for this interaction,\r\n                            // Notify subscribers that it's completed.\r\n                            if (subscriber !== null && interaction.__count === 0) {\r\n                                subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return returnValue;\r\n        }\r\n        function unstable_wrap(callback) {\r\n            var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\r\n            var wrappedInteractions = exports.__interactionsRef.current;\r\n            var subscriber = exports.__subscriberRef.current;\r\n            if (subscriber !== null) {\r\n                subscriber.onWorkScheduled(wrappedInteractions, threadID);\r\n            } // Update the pending async work count for the current interactions.\r\n            // Update after calling subscribers in case of error.\r\n            wrappedInteractions.forEach(function (interaction) {\r\n                interaction.__count++;\r\n            });\r\n            var hasRun = false;\r\n            function wrapped() {\r\n                var prevInteractions = exports.__interactionsRef.current;\r\n                exports.__interactionsRef.current = wrappedInteractions;\r\n                subscriber = exports.__subscriberRef.current;\r\n                try {\r\n                    var returnValue;\r\n                    try {\r\n                        if (subscriber !== null) {\r\n                            subscriber.onWorkStarted(wrappedInteractions, threadID);\r\n                        }\r\n                    }\r\n                    finally {\r\n                        try {\r\n                            returnValue = callback.apply(undefined, arguments);\r\n                        }\r\n                        finally {\r\n                            exports.__interactionsRef.current = prevInteractions;\r\n                            if (subscriber !== null) {\r\n                                subscriber.onWorkStopped(wrappedInteractions, threadID);\r\n                            }\r\n                        }\r\n                    }\r\n                    return returnValue;\r\n                }\r\n                finally {\r\n                    if (!hasRun) {\r\n                        // We only expect a wrapped function to be executed once,\r\n                        // But in the event that it's executed more than once–\r\n                        // Only decrement the outstanding interaction counts once.\r\n                        hasRun = true; // Update pending async counts for all wrapped interactions.\r\n                        // If this was the last scheduled async work for any of them,\r\n                        // Mark them as completed.\r\n                        wrappedInteractions.forEach(function (interaction) {\r\n                            interaction.__count--;\r\n                            if (subscriber !== null && interaction.__count === 0) {\r\n                                subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            wrapped.cancel = function cancel() {\r\n                subscriber = exports.__subscriberRef.current;\r\n                try {\r\n                    if (subscriber !== null) {\r\n                        subscriber.onWorkCanceled(wrappedInteractions, threadID);\r\n                    }\r\n                }\r\n                finally {\r\n                    // Update pending async counts for all wrapped interactions.\r\n                    // If this was the last scheduled async work for any of them,\r\n                    // Mark them as completed.\r\n                    wrappedInteractions.forEach(function (interaction) {\r\n                        interaction.__count--;\r\n                        if (subscriber && interaction.__count === 0) {\r\n                            subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            return wrapped;\r\n        }\r\n        var subscribers = null;\r\n        {\r\n            subscribers = new Set();\r\n        }\r\n        function unstable_subscribe(subscriber) {\r\n            {\r\n                subscribers.add(subscriber);\r\n                if (subscribers.size === 1) {\r\n                    exports.__subscriberRef.current = {\r\n                        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\r\n                        onInteractionTraced: onInteractionTraced,\r\n                        onWorkCanceled: onWorkCanceled,\r\n                        onWorkScheduled: onWorkScheduled,\r\n                        onWorkStarted: onWorkStarted,\r\n                        onWorkStopped: onWorkStopped\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        function unstable_unsubscribe(subscriber) {\r\n            {\r\n                subscribers.delete(subscriber);\r\n                if (subscribers.size === 0) {\r\n                    exports.__subscriberRef.current = null;\r\n                }\r\n            }\r\n        }\r\n        function onInteractionTraced(interaction) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onInteractionTraced(interaction);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        function onInteractionScheduledWorkCompleted(interaction) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onInteractionScheduledWorkCompleted(interaction);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        function onWorkScheduled(interactions, threadID) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onWorkScheduled(interactions, threadID);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        function onWorkStarted(interactions, threadID) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onWorkStarted(interactions, threadID);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        function onWorkStopped(interactions, threadID) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onWorkStopped(interactions, threadID);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        function onWorkCanceled(interactions, threadID) {\r\n            var didCatchError = false;\r\n            var caughtError = null;\r\n            subscribers.forEach(function (subscriber) {\r\n                try {\r\n                    subscriber.onWorkCanceled(interactions, threadID);\r\n                }\r\n                catch (error) {\r\n                    if (!didCatchError) {\r\n                        didCatchError = true;\r\n                        caughtError = error;\r\n                    }\r\n                }\r\n            });\r\n            if (didCatchError) {\r\n                throw caughtError;\r\n            }\r\n        }\r\n        exports.unstable_clear = unstable_clear;\r\n        exports.unstable_getCurrent = unstable_getCurrent;\r\n        exports.unstable_getThreadID = unstable_getThreadID;\r\n        exports.unstable_subscribe = unstable_subscribe;\r\n        exports.unstable_trace = unstable_trace;\r\n        exports.unstable_unsubscribe = unstable_unsubscribe;\r\n        exports.unstable_wrap = unstable_wrap;\r\n    })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXItdHJhY2luZy5kZXZlbG9wbWVudC5qcz8xOTc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0dBT0c7QUFFVTtBQUViLElBQUksSUFBcUMsRUFBRTtJQUN6QyxDQUFDO1FBQ0gsWUFBWSxDQUFDO1FBRWIsSUFBSSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQyx3Q0FBd0M7UUFFbkUsSUFBSSxvQkFBb0IsR0FBRyxDQUFDLENBQUM7UUFDN0IsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUMsd0NBQXdDO1FBQ2pFLHdCQUF3QjtRQUN4QixvRkFBb0Y7UUFDcEYsZ0ZBQWdGO1FBRWhGLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsQ0FBQyx5REFBeUQ7UUFFM0YsT0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7UUFFL0I7WUFDRSxPQUFPLENBQUMsaUJBQWlCLEdBQUc7Z0JBQzFCLE9BQU8sRUFBRSxJQUFJLEdBQUcsRUFBRTthQUNuQixDQUFDO1lBQ0YsT0FBTyxDQUFDLGVBQWUsR0FBRztnQkFDeEIsT0FBTyxFQUFFLElBQUk7YUFDZCxDQUFDO1NBQ0g7UUFDRCxTQUFTLGNBQWMsQ0FBQyxRQUFRO1lBRTlCLElBQUksZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQztZQUN6RCxPQUFPLENBQUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7WUFFOUMsSUFBSTtnQkFDRixPQUFPLFFBQVEsRUFBRSxDQUFDO2FBQ25CO29CQUFTO2dCQUNSLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsZ0JBQWdCLENBQUM7YUFDdEQ7UUFDSCxDQUFDO1FBQ0QsU0FBUyxtQkFBbUI7WUFDMUI7Z0JBQ0UsT0FBTyxPQUFPLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO2FB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Q2xELE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxvQkFBb0IsQ0FBQztRQUNwRCxPQUFPLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7UUFDaEQsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDeEMsT0FBTyxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO1FBQ3BELE9BQU8sQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0lBQ3BDLENBQUMsQ0FBQyxFQUFFLENBQUM7Q0FDTiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjIwLjFcbiAqIHNjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIERFRkFVTFRfVEhSRUFEX0lEID0gMDsgLy8gQ291bnRlcnMgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLlxuXG52YXIgaW50ZXJhY3Rpb25JRENvdW50ZXIgPSAwO1xudmFyIHRocmVhZElEQ291bnRlciA9IDA7IC8vIFNldCBvZiBjdXJyZW50bHkgdHJhY2VkIGludGVyYWN0aW9ucy5cbi8vIEludGVyYWN0aW9ucyBcInN0YWNrXCLigJNcbi8vIE1lYW5pbmcgdGhhdCBuZXdseSB0cmFjZWQgaW50ZXJhY3Rpb25zIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXNseSBhY3RpdmUgc2V0LlxuLy8gV2hlbiBhbiBpbnRlcmFjdGlvbiBnb2VzIG91dCBvZiBzY29wZSwgdGhlIHByZXZpb3VzIHNldCAoaWYgYW55KSBpcyByZXN0b3JlZC5cblxuZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZiA9IG51bGw7IC8vIExpc3RlbmVyKHMpIHRvIG5vdGlmeSB3aGVuIGludGVyYWN0aW9ucyBiZWdpbiBhbmQgZW5kLlxuXG5leHBvcnRzLl9fc3Vic2NyaWJlclJlZiA9IG51bGw7XG5cbntcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZiA9IHtcbiAgICBjdXJyZW50OiBuZXcgU2V0KClcbiAgfTtcbiAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gdW5zdGFibGVfY2xlYXIoY2FsbGJhY2spIHtcblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudCgpIHtcbiAge1xuICAgIHJldHVybiBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldFRocmVhZElEKCkge1xuICByZXR1cm4gKyt0aHJlYWRJRENvdW50ZXI7XG59XG5mdW5jdGlvbiB1bnN0YWJsZV90cmFjZShuYW1lLCB0aW1lc3RhbXAsIGNhbGxiYWNrKSB7XG4gIHZhciB0aHJlYWRJRCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogREVGQVVMVF9USFJFQURfSUQ7XG5cbiAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgIF9fY291bnQ6IDEsXG4gICAgaWQ6IGludGVyYWN0aW9uSURDb3VudGVyKyssXG4gICAgbmFtZTogbmFtZSxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICB9O1xuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDsgLy8gVHJhY2VkIGludGVyYWN0aW9ucyBzaG91bGQgc3RhY2svYWNjdW11bGF0ZS5cbiAgLy8gVG8gZG8gdGhhdCwgY2xvbmUgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuICAvLyBUaGUgcHJldmlvdXMgc2V0IHdpbGwgYmUgcmVzdG9yZWQgdXBvbiBjb21wbGV0aW9uLlxuXG4gIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KHByZXZJbnRlcmFjdGlvbnMpO1xuICBpbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gaW50ZXJhY3Rpb25zO1xuICB2YXIgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gIHZhciByZXR1cm5WYWx1ZTtcblxuICB0cnkge1xuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tOyAvLyBJZiBubyBhc3luYyB3b3JrIHdhcyBzY2hlZHVsZWQgZm9yIHRoaXMgaW50ZXJhY3Rpb24sXG4gICAgICAgICAgLy8gTm90aWZ5IHN1YnNjcmliZXJzIHRoYXQgaXQncyBjb21wbGV0ZWQuXG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwKGNhbGxiYWNrKSB7XG4gIHZhciB0aHJlYWRJRCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9USFJFQURfSUQ7XG5cbiAgdmFyIHdyYXBwZWRJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIHZhciBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgfSAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuICAvLyBVcGRhdGUgYWZ0ZXIgY2FsbGluZyBzdWJzY3JpYmVycyBpbiBjYXNlIG9mIGVycm9yLlxuXG5cbiAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgfSk7XG4gIHZhciBoYXNSdW4gPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHdyYXBwZWRJbnRlcmFjdGlvbnM7XG4gICAgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJldHVyblZhbHVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghaGFzUnVuKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgZXhwZWN0IGEgd3JhcHBlZCBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlLFxuICAgICAgICAvLyBCdXQgaW4gdGhlIGV2ZW50IHRoYXQgaXQncyBleGVjdXRlZCBtb3JlIHRoYW4gb25jZeKAk1xuICAgICAgICAvLyBPbmx5IGRlY3JlbWVudCB0aGUgb3V0c3RhbmRpbmcgaW50ZXJhY3Rpb24gY291bnRzIG9uY2UuXG4gICAgICAgIGhhc1J1biA9IHRydWU7IC8vIFVwZGF0ZSBwZW5kaW5nIGFzeW5jIGNvdW50cyBmb3IgYWxsIHdyYXBwZWQgaW50ZXJhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAgIC8vIE1hcmsgdGhlbSBhcyBjb21wbGV0ZWQuXG5cbiAgICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlZC5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGFzeW5jIGNvdW50cyBmb3IgYWxsIHdyYXBwZWQgaW50ZXJhY3Rpb25zLlxuICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cbiAgICAgIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgIGlmIChzdWJzY3JpYmVyICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG52YXIgc3Vic2NyaWJlcnMgPSBudWxsO1xuXG57XG4gIHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgIG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkOiBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZCxcbiAgICAgICAgb25JbnRlcmFjdGlvblRyYWNlZDogb25JbnRlcmFjdGlvblRyYWNlZCxcbiAgICAgICAgb25Xb3JrQ2FuY2VsZWQ6IG9uV29ya0NhbmNlbGVkLFxuICAgICAgICBvbldvcmtTY2hlZHVsZWQ6IG9uV29ya1NjaGVkdWxlZCxcbiAgICAgICAgb25Xb3JrU3RhcnRlZDogb25Xb3JrU3RhcnRlZCxcbiAgICAgICAgb25Xb3JrU3RvcHBlZDogb25Xb3JrU3RvcHBlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3Vuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAge1xuICAgIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcblxuICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwKSB7XG4gICAgICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbikge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrQ2FuY2VsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0cy51bnN0YWJsZV9jbGVhciA9IHVuc3RhYmxlX2NsZWFyO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50ID0gdW5zdGFibGVfZ2V0Q3VycmVudDtcbmV4cG9ydHMudW5zdGFibGVfZ2V0VGhyZWFkSUQgPSB1bnN0YWJsZV9nZXRUaHJlYWRJRDtcbmV4cG9ydHMudW5zdGFibGVfc3Vic2NyaWJlID0gdW5zdGFibGVfc3Vic2NyaWJlO1xuZXhwb3J0cy51bnN0YWJsZV90cmFjZSA9IHVuc3RhYmxlX3RyYWNlO1xuZXhwb3J0cy51bnN0YWJsZV91bnN1YnNjcmliZSA9IHVuc3RhYmxlX3Vuc3Vic2NyaWJlO1xuZXhwb3J0cy51bnN0YWJsZV93cmFwID0gdW5zdGFibGVfd3JhcDtcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler-tracing.development.js\n");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v0.20.1\r\n * scheduler.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nif (true) {\r\n    (function () {\r\n        'use strict';\r\n        var enableSchedulerDebugging = false;\r\n        var enableProfiling = true;\r\n        var requestHostCallback;\r\n        var requestHostTimeout;\r\n        var cancelHostTimeout;\r\n        var requestPaint;\r\n        var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\r\n        if (hasPerformanceNow) {\r\n            var localPerformance = performance;\r\n            exports.unstable_now = function () {\r\n                return localPerformance.now();\r\n            };\r\n        }\r\n        else {\r\n            var localDate = Date;\r\n            var initialTime = localDate.now();\r\n            exports.unstable_now = function () {\r\n                return localDate.now() - initialTime;\r\n            };\r\n        }\r\n        if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive\r\n        // implementation using setTimeout.\r\n        typeof window === 'undefined' || // Check if MessageChannel is supported, too.\r\n            typeof MessageChannel !== 'function') {\r\n            // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\r\n            // fallback to a naive implementation.\r\n            var _callback = null;\r\n            var _timeoutID = null;\r\n            var _flushCallback = function () {\r\n                if (_callback !== null) {\r\n                    try {\r\n                        var currentTime = exports.unstable_now();\r\n                        var hasRemainingTime = true;\r\n                        _callback(hasRemainingTime, currentTime);\r\n                        _callback = null;\r\n                    }\r\n                    catch (e) {\r\n                        setTimeout(_flushCallback, 0);\r\n                        throw e;\r\n                    }\r\n                }\r\n            };\r\n            requestHostCallback = function (cb) {\r\n                if (_callback !== null) {\r\n                    // Protect against re-entrancy.\r\n                    setTimeout(requestHostCallback, 0, cb);\r\n                }\r\n                else {\r\n                    _callback = cb;\r\n                    setTimeout(_flushCallback, 0);\r\n                }\r\n            };\r\n            requestHostTimeout = function (cb, ms) {\r\n                _timeoutID = setTimeout(cb, ms);\r\n            };\r\n            cancelHostTimeout = function () {\r\n                clearTimeout(_timeoutID);\r\n            };\r\n            exports.unstable_shouldYield = function () {\r\n                return false;\r\n            };\r\n            requestPaint = exports.unstable_forceFrameRate = function () { };\r\n        }\r\n        else {\r\n            // Capture local references to native APIs, in case a polyfill overrides them.\r\n            var _setTimeout = window.setTimeout;\r\n            var _clearTimeout = window.clearTimeout;\r\n            if (typeof console !== 'undefined') {\r\n                // TODO: Scheduler no longer requires these methods to be polyfilled. But\r\n                // maybe we want to continue warning if they don't exist, to preserve the\r\n                // option to rely on it in the future?\r\n                var requestAnimationFrame = window.requestAnimationFrame;\r\n                var cancelAnimationFrame = window.cancelAnimationFrame;\r\n                if (typeof requestAnimationFrame !== 'function') {\r\n                    // Using console['error'] to evade Babel and ESLint\r\n                    console['error'](\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');\r\n                }\r\n                if (typeof cancelAnimationFrame !== 'function') {\r\n                    // Using console['error'] to evade Babel and ESLint\r\n                    console['error'](\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');\r\n                }\r\n            }\r\n            var isMessageLoopRunning = false;\r\n            var scheduledHostCallback = null;\r\n            var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\r\n            // thread, like user events. By default, it yields multiple times per frame.\r\n            // It does not attempt to align with frame boundaries, since most tasks don't\r\n            // need to be frame aligned; for those that do, use requestAnimationFrame.\r\n            var yieldInterval = 5;\r\n            var deadline = 0; // TODO: Make this configurable\r\n            {\r\n                // `isInputPending` is not available. Since we have no way of knowing if\r\n                // there's pending input, always yield at the end of the frame.\r\n                exports.unstable_shouldYield = function () {\r\n                    return exports.unstable_now() >= deadline;\r\n                }; // Since we yield every frame regardless, `requestPaint` has no effect.\r\n                requestPaint = function () { };\r\n            }\r\n            exports.unstable_forceFrameRate = function (fps) {\r\n                if (fps < 0 || fps > 125) {\r\n                    // Using console['error'] to evade Babel and ESLint\r\n                    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\r\n                    return;\r\n                }\r\n                if (fps > 0) {\r\n                    yieldInterval = Math.floor(1000 / fps);\r\n                }\r\n                else {\r\n                    // reset the framerate\r\n                    yieldInterval = 5;\r\n                }\r\n            };\r\n            var performWorkUntilDeadline = function () {\r\n                if (scheduledHostCallback !== null) {\r\n                    var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync\r\n                    // cycle. This means there's always time remaining at the beginning of\r\n                    // the message event.\r\n                    deadline = currentTime + yieldInterval;\r\n                    var hasTimeRemaining = true;\r\n                    try {\r\n                        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n                        if (!hasMoreWork) {\r\n                            isMessageLoopRunning = false;\r\n                            scheduledHostCallback = null;\r\n                        }\r\n                        else {\r\n                            // If there's more work, schedule the next message event at the end\r\n                            // of the preceding one.\r\n                            port.postMessage(null);\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        // If a scheduler task throws, exit the current browser task so the\r\n                        // error can be observed.\r\n                        port.postMessage(null);\r\n                        throw error;\r\n                    }\r\n                }\r\n                else {\r\n                    isMessageLoopRunning = false;\r\n                } // Yielding to the browser will give it a chance to paint, so we can\r\n            };\r\n            var channel = new MessageChannel();\r\n            var port = channel.port2;\r\n            channel.port1.onmessage = performWorkUntilDeadline;\r\n            requestHostCallback = function (callback) {\r\n                scheduledHostCallback = callback;\r\n                if (!isMessageLoopRunning) {\r\n                    isMessageLoopRunning = true;\r\n                    port.postMessage(null);\r\n                }\r\n            };\r\n            requestHostTimeout = function (callback, ms) {\r\n                taskTimeoutID = _setTimeout(function () {\r\n                    callback(exports.unstable_now());\r\n                }, ms);\r\n            };\r\n            cancelHostTimeout = function () {\r\n                _clearTimeout(taskTimeoutID);\r\n                taskTimeoutID = -1;\r\n            };\r\n        }\r\n        function push(heap, node) {\r\n            var index = heap.length;\r\n            heap.push(node);\r\n            siftUp(heap, node, index);\r\n        }\r\n        function peek(heap) {\r\n            var first = heap[0];\r\n            return first === undefined ? null : first;\r\n        }\r\n        function pop(heap) {\r\n            var first = heap[0];\r\n            if (first !== undefined) {\r\n                var last = heap.pop();\r\n                if (last !== first) {\r\n                    heap[0] = last;\r\n                    siftDown(heap, last, 0);\r\n                }\r\n                return first;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        function siftUp(heap, node, i) {\r\n            var index = i;\r\n            while (true) {\r\n                var parentIndex = index - 1 >>> 1;\r\n                var parent = heap[parentIndex];\r\n                if (parent !== undefined && compare(parent, node) > 0) {\r\n                    // The parent is larger. Swap positions.\r\n                    heap[parentIndex] = node;\r\n                    heap[index] = parent;\r\n                    index = parentIndex;\r\n                }\r\n                else {\r\n                    // The parent is smaller. Exit.\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        function siftDown(heap, node, i) {\r\n            var index = i;\r\n            var length = heap.length;\r\n            while (index < length) {\r\n                var leftIndex = (index + 1) * 2 - 1;\r\n                var left = heap[leftIndex];\r\n                var rightIndex = leftIndex + 1;\r\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\r\n                if (left !== undefined && compare(left, node) < 0) {\r\n                    if (right !== undefined && compare(right, left) < 0) {\r\n                        heap[index] = right;\r\n                        heap[rightIndex] = node;\r\n                        index = rightIndex;\r\n                    }\r\n                    else {\r\n                        heap[index] = left;\r\n                        heap[leftIndex] = node;\r\n                        index = leftIndex;\r\n                    }\r\n                }\r\n                else if (right !== undefined && compare(right, node) < 0) {\r\n                    heap[index] = right;\r\n                    heap[rightIndex] = node;\r\n                    index = rightIndex;\r\n                }\r\n                else {\r\n                    // Neither child is smaller. Exit.\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        function compare(a, b) {\r\n            // Compare sort index first, then task id.\r\n            var diff = a.sortIndex - b.sortIndex;\r\n            return diff !== 0 ? diff : a.id - b.id;\r\n        }\r\n        // TODO: Use symbols?\r\n        var NoPriority = 0;\r\n        var ImmediatePriority = 1;\r\n        var UserBlockingPriority = 2;\r\n        var NormalPriority = 3;\r\n        var LowPriority = 4;\r\n        var IdlePriority = 5;\r\n        var runIdCounter = 0;\r\n        var mainThreadIdCounter = 0;\r\n        var profilingStateSize = 4;\r\n        var sharedProfilingBuffer = // $FlowFixMe Flow doesn't know about SharedArrayBuffer\r\n         typeof SharedArrayBuffer === 'function' ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : // $FlowFixMe Flow doesn't know about ArrayBuffer\r\n            typeof ArrayBuffer === 'function' ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null // Don't crash the init path on IE9\r\n        ;\r\n        var profilingState = sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : []; // We can't read this but it helps save bytes for null checks\r\n        var PRIORITY = 0;\r\n        var CURRENT_TASK_ID = 1;\r\n        var CURRENT_RUN_ID = 2;\r\n        var QUEUE_SIZE = 3;\r\n        {\r\n            profilingState[PRIORITY] = NoPriority; // This is maintained with a counter, because the size of the priority queue\r\n            // array might include canceled tasks.\r\n            profilingState[QUEUE_SIZE] = 0;\r\n            profilingState[CURRENT_TASK_ID] = 0;\r\n        } // Bytes per element is 4\r\n        var INITIAL_EVENT_LOG_SIZE = 131072;\r\n        var MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\r\n        var eventLogSize = 0;\r\n        var eventLogBuffer = null;\r\n        var eventLog = null;\r\n        var eventLogIndex = 0;\r\n        var TaskStartEvent = 1;\r\n        var TaskCompleteEvent = 2;\r\n        var TaskErrorEvent = 3;\r\n        var TaskCancelEvent = 4;\r\n        var TaskRunEvent = 5;\r\n        var TaskYieldEvent = 6;\r\n        var SchedulerSuspendEvent = 7;\r\n        var SchedulerResumeEvent = 8;\r\n        function logEvent(entries) {\r\n            if (eventLog !== null) {\r\n                var offset = eventLogIndex;\r\n                eventLogIndex += entries.length;\r\n                if (eventLogIndex + 1 > eventLogSize) {\r\n                    eventLogSize *= 2;\r\n                    if (eventLogSize > MAX_EVENT_LOG_SIZE) {\r\n                        // Using console['error'] to evade Babel and ESLint\r\n                        console['error'](\"Scheduler Profiling: Event log exceeded maximum size. Don't \" + 'forget to call `stopLoggingProfilingEvents()`.');\r\n                        stopLoggingProfilingEvents();\r\n                        return;\r\n                    }\r\n                    var newEventLog = new Int32Array(eventLogSize * 4);\r\n                    newEventLog.set(eventLog);\r\n                    eventLogBuffer = newEventLog.buffer;\r\n                    eventLog = newEventLog;\r\n                }\r\n                eventLog.set(entries, offset);\r\n            }\r\n        }\r\n        function startLoggingProfilingEvents() {\r\n            eventLogSize = INITIAL_EVENT_LOG_SIZE;\r\n            eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\r\n            eventLog = new Int32Array(eventLogBuffer);\r\n            eventLogIndex = 0;\r\n        }\r\n        function stopLoggingProfilingEvents() {\r\n            var buffer = eventLogBuffer;\r\n            eventLogSize = 0;\r\n            eventLogBuffer = null;\r\n            eventLog = null;\r\n            eventLogIndex = 0;\r\n            return buffer;\r\n        }\r\n        function markTaskStart(task, ms) {\r\n            {\r\n                profilingState[QUEUE_SIZE]++;\r\n                if (eventLog !== null) {\r\n                    // performance.now returns a float, representing milliseconds. When the\r\n                    // event is logged, it's coerced to an int. Convert to microseconds to\r\n                    // maintain extra degrees of precision.\r\n                    logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\r\n                }\r\n            }\r\n        }\r\n        function markTaskCompleted(task, ms) {\r\n            {\r\n                profilingState[PRIORITY] = NoPriority;\r\n                profilingState[CURRENT_TASK_ID] = 0;\r\n                profilingState[QUEUE_SIZE]--;\r\n                if (eventLog !== null) {\r\n                    logEvent([TaskCompleteEvent, ms * 1000, task.id]);\r\n                }\r\n            }\r\n        }\r\n        function markTaskCanceled(task, ms) {\r\n            {\r\n                profilingState[QUEUE_SIZE]--;\r\n                if (eventLog !== null) {\r\n                    logEvent([TaskCancelEvent, ms * 1000, task.id]);\r\n                }\r\n            }\r\n        }\r\n        function markTaskErrored(task, ms) {\r\n            {\r\n                profilingState[PRIORITY] = NoPriority;\r\n                profilingState[CURRENT_TASK_ID] = 0;\r\n                profilingState[QUEUE_SIZE]--;\r\n                if (eventLog !== null) {\r\n                    logEvent([TaskErrorEvent, ms * 1000, task.id]);\r\n                }\r\n            }\r\n        }\r\n        function markTaskRun(task, ms) {\r\n            {\r\n                runIdCounter++;\r\n                profilingState[PRIORITY] = task.priorityLevel;\r\n                profilingState[CURRENT_TASK_ID] = task.id;\r\n                profilingState[CURRENT_RUN_ID] = runIdCounter;\r\n                if (eventLog !== null) {\r\n                    logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\r\n                }\r\n            }\r\n        }\r\n        function markTaskYield(task, ms) {\r\n            {\r\n                profilingState[PRIORITY] = NoPriority;\r\n                profilingState[CURRENT_TASK_ID] = 0;\r\n                profilingState[CURRENT_RUN_ID] = 0;\r\n                if (eventLog !== null) {\r\n                    logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\r\n                }\r\n            }\r\n        }\r\n        function markSchedulerSuspended(ms) {\r\n            {\r\n                mainThreadIdCounter++;\r\n                if (eventLog !== null) {\r\n                    logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\r\n                }\r\n            }\r\n        }\r\n        function markSchedulerUnsuspended(ms) {\r\n            {\r\n                if (eventLog !== null) {\r\n                    logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\r\n                }\r\n            }\r\n        }\r\n        /* eslint-disable no-var */\r\n        // Math.pow(2, 30) - 1\r\n        // 0b111111111111111111111111111111\r\n        var maxSigned31BitInt = 1073741823; // Times out immediately\r\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\r\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\r\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\r\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\r\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\r\n        var taskQueue = [];\r\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\r\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\r\n        var currentTask = null;\r\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.\r\n        var isPerformingWork = false;\r\n        var isHostCallbackScheduled = false;\r\n        var isHostTimeoutScheduled = false;\r\n        function advanceTimers(currentTime) {\r\n            // Check for tasks that are no longer delayed and add them to the queue.\r\n            var timer = peek(timerQueue);\r\n            while (timer !== null) {\r\n                if (timer.callback === null) {\r\n                    // Timer was cancelled.\r\n                    pop(timerQueue);\r\n                }\r\n                else if (timer.startTime <= currentTime) {\r\n                    // Timer fired. Transfer to the task queue.\r\n                    pop(timerQueue);\r\n                    timer.sortIndex = timer.expirationTime;\r\n                    push(taskQueue, timer);\r\n                    {\r\n                        markTaskStart(timer, currentTime);\r\n                        timer.isQueued = true;\r\n                    }\r\n                }\r\n                else {\r\n                    // Remaining timers are pending.\r\n                    return;\r\n                }\r\n                timer = peek(timerQueue);\r\n            }\r\n        }\r\n        function handleTimeout(currentTime) {\r\n            isHostTimeoutScheduled = false;\r\n            advanceTimers(currentTime);\r\n            if (!isHostCallbackScheduled) {\r\n                if (peek(taskQueue) !== null) {\r\n                    isHostCallbackScheduled = true;\r\n                    requestHostCallback(flushWork);\r\n                }\r\n                else {\r\n                    var firstTimer = peek(timerQueue);\r\n                    if (firstTimer !== null) {\r\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function flushWork(hasTimeRemaining, initialTime) {\r\n            {\r\n                markSchedulerUnsuspended(initialTime);\r\n            } // We'll need a host callback the next time work is scheduled.\r\n            isHostCallbackScheduled = false;\r\n            if (isHostTimeoutScheduled) {\r\n                // We scheduled a timeout but it's no longer needed. Cancel it.\r\n                isHostTimeoutScheduled = false;\r\n                cancelHostTimeout();\r\n            }\r\n            isPerformingWork = true;\r\n            var previousPriorityLevel = currentPriorityLevel;\r\n            try {\r\n                if (enableProfiling) {\r\n                    try {\r\n                        return workLoop(hasTimeRemaining, initialTime);\r\n                    }\r\n                    catch (error) {\r\n                        if (currentTask !== null) {\r\n                            var currentTime = exports.unstable_now();\r\n                            markTaskErrored(currentTask, currentTime);\r\n                            currentTask.isQueued = false;\r\n                        }\r\n                        throw error;\r\n                    }\r\n                }\r\n                else {\r\n                    // No catch in prod code path.\r\n                    return workLoop(hasTimeRemaining, initialTime);\r\n                }\r\n            }\r\n            finally {\r\n                currentTask = null;\r\n                currentPriorityLevel = previousPriorityLevel;\r\n                isPerformingWork = false;\r\n                {\r\n                    var _currentTime = exports.unstable_now();\r\n                    markSchedulerSuspended(_currentTime);\r\n                }\r\n            }\r\n        }\r\n        function workLoop(hasTimeRemaining, initialTime) {\r\n            var currentTime = initialTime;\r\n            advanceTimers(currentTime);\r\n            currentTask = peek(taskQueue);\r\n            while (currentTask !== null && !(enableSchedulerDebugging)) {\r\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {\r\n                    // This currentTask hasn't expired, and we've reached the deadline.\r\n                    break;\r\n                }\r\n                var callback = currentTask.callback;\r\n                if (typeof callback === 'function') {\r\n                    currentTask.callback = null;\r\n                    currentPriorityLevel = currentTask.priorityLevel;\r\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\r\n                    markTaskRun(currentTask, currentTime);\r\n                    var continuationCallback = callback(didUserCallbackTimeout);\r\n                    currentTime = exports.unstable_now();\r\n                    if (typeof continuationCallback === 'function') {\r\n                        currentTask.callback = continuationCallback;\r\n                        markTaskYield(currentTask, currentTime);\r\n                    }\r\n                    else {\r\n                        {\r\n                            markTaskCompleted(currentTask, currentTime);\r\n                            currentTask.isQueued = false;\r\n                        }\r\n                        if (currentTask === peek(taskQueue)) {\r\n                            pop(taskQueue);\r\n                        }\r\n                    }\r\n                    advanceTimers(currentTime);\r\n                }\r\n                else {\r\n                    pop(taskQueue);\r\n                }\r\n                currentTask = peek(taskQueue);\r\n            } // Return whether there's additional work\r\n            if (currentTask !== null) {\r\n                return true;\r\n            }\r\n            else {\r\n                var firstTimer = peek(timerQueue);\r\n                if (firstTimer !== null) {\r\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\r\n            switch (priorityLevel) {\r\n                case ImmediatePriority:\r\n                case UserBlockingPriority:\r\n                case NormalPriority:\r\n                case LowPriority:\r\n                case IdlePriority:\r\n                    break;\r\n                default:\r\n                    priorityLevel = NormalPriority;\r\n            }\r\n            var previousPriorityLevel = currentPriorityLevel;\r\n            currentPriorityLevel = priorityLevel;\r\n            try {\r\n                return eventHandler();\r\n            }\r\n            finally {\r\n                currentPriorityLevel = previousPriorityLevel;\r\n            }\r\n        }\r\n        function unstable_next(eventHandler) {\r\n            var priorityLevel;\r\n            switch (currentPriorityLevel) {\r\n                case ImmediatePriority:\r\n                case UserBlockingPriority:\r\n                case NormalPriority:\r\n                    // Shift down to normal priority\r\n                    priorityLevel = NormalPriority;\r\n                    break;\r\n                default:\r\n                    // Anything lower than normal priority should remain at the current level.\r\n                    priorityLevel = currentPriorityLevel;\r\n                    break;\r\n            }\r\n            var previousPriorityLevel = currentPriorityLevel;\r\n            currentPriorityLevel = priorityLevel;\r\n            try {\r\n                return eventHandler();\r\n            }\r\n            finally {\r\n                currentPriorityLevel = previousPriorityLevel;\r\n            }\r\n        }\r\n        function unstable_wrapCallback(callback) {\r\n            var parentPriorityLevel = currentPriorityLevel;\r\n            return function () {\r\n                // This is a fork of runWithPriority, inlined for performance.\r\n                var previousPriorityLevel = currentPriorityLevel;\r\n                currentPriorityLevel = parentPriorityLevel;\r\n                try {\r\n                    return callback.apply(this, arguments);\r\n                }\r\n                finally {\r\n                    currentPriorityLevel = previousPriorityLevel;\r\n                }\r\n            };\r\n        }\r\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\r\n            var currentTime = exports.unstable_now();\r\n            var startTime;\r\n            if (typeof options === 'object' && options !== null) {\r\n                var delay = options.delay;\r\n                if (typeof delay === 'number' && delay > 0) {\r\n                    startTime = currentTime + delay;\r\n                }\r\n                else {\r\n                    startTime = currentTime;\r\n                }\r\n            }\r\n            else {\r\n                startTime = currentTime;\r\n            }\r\n            var timeout;\r\n            switch (priorityLevel) {\r\n                case ImmediatePriority:\r\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\r\n                    break;\r\n                case UserBlockingPriority:\r\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\r\n                    break;\r\n                case IdlePriority:\r\n                    timeout = IDLE_PRIORITY_TIMEOUT;\r\n                    break;\r\n                case LowPriority:\r\n                    timeout = LOW_PRIORITY_TIMEOUT;\r\n                    break;\r\n                case NormalPriority:\r\n                default:\r\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\r\n                    break;\r\n            }\r\n            var expirationTime = startTime + timeout;\r\n            var newTask = {\r\n                id: taskIdCounter++,\r\n                callback: callback,\r\n                priorityLevel: priorityLevel,\r\n                startTime: startTime,\r\n                expirationTime: expirationTime,\r\n                sortIndex: -1\r\n            };\r\n            {\r\n                newTask.isQueued = false;\r\n            }\r\n            if (startTime > currentTime) {\r\n                // This is a delayed task.\r\n                newTask.sortIndex = startTime;\r\n                push(timerQueue, newTask);\r\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\r\n                    // All tasks are delayed, and this is the task with the earliest delay.\r\n                    if (isHostTimeoutScheduled) {\r\n                        // Cancel an existing timeout.\r\n                        cancelHostTimeout();\r\n                    }\r\n                    else {\r\n                        isHostTimeoutScheduled = true;\r\n                    } // Schedule a timeout.\r\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\r\n                }\r\n            }\r\n            else {\r\n                newTask.sortIndex = expirationTime;\r\n                push(taskQueue, newTask);\r\n                {\r\n                    markTaskStart(newTask, currentTime);\r\n                    newTask.isQueued = true;\r\n                } // Schedule a host callback, if needed. If we're already performing work,\r\n                // wait until the next time we yield.\r\n                if (!isHostCallbackScheduled && !isPerformingWork) {\r\n                    isHostCallbackScheduled = true;\r\n                    requestHostCallback(flushWork);\r\n                }\r\n            }\r\n            return newTask;\r\n        }\r\n        function unstable_pauseExecution() {\r\n        }\r\n        function unstable_continueExecution() {\r\n            if (!isHostCallbackScheduled && !isPerformingWork) {\r\n                isHostCallbackScheduled = true;\r\n                requestHostCallback(flushWork);\r\n            }\r\n        }\r\n        function unstable_getFirstCallbackNode() {\r\n            return peek(taskQueue);\r\n        }\r\n        function unstable_cancelCallback(task) {\r\n            {\r\n                if (task.isQueued) {\r\n                    var currentTime = exports.unstable_now();\r\n                    markTaskCanceled(task, currentTime);\r\n                    task.isQueued = false;\r\n                }\r\n            } // Null out the callback to indicate the task has been canceled. (Can't\r\n            // remove from the queue because you can't remove arbitrary nodes from an\r\n            // array based heap, only the first one.)\r\n            task.callback = null;\r\n        }\r\n        function unstable_getCurrentPriorityLevel() {\r\n            return currentPriorityLevel;\r\n        }\r\n        var unstable_requestPaint = requestPaint;\r\n        var unstable_Profiling = {\r\n            startLoggingProfilingEvents: startLoggingProfilingEvents,\r\n            stopLoggingProfilingEvents: stopLoggingProfilingEvents,\r\n            sharedProfilingBuffer: sharedProfilingBuffer\r\n        };\r\n        exports.unstable_IdlePriority = IdlePriority;\r\n        exports.unstable_ImmediatePriority = ImmediatePriority;\r\n        exports.unstable_LowPriority = LowPriority;\r\n        exports.unstable_NormalPriority = NormalPriority;\r\n        exports.unstable_Profiling = unstable_Profiling;\r\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\r\n        exports.unstable_cancelCallback = unstable_cancelCallback;\r\n        exports.unstable_continueExecution = unstable_continueExecution;\r\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n        exports.unstable_next = unstable_next;\r\n        exports.unstable_pauseExecution = unstable_pauseExecution;\r\n        exports.unstable_requestPaint = unstable_requestPaint;\r\n        exports.unstable_runWithPriority = unstable_runWithPriority;\r\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\r\n        exports.unstable_wrapCallback = unstable_wrapCallback;\r\n    })();\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/MzA2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztHQU9HO0FBRVU7QUFFYixJQUFJLElBQXFDLEVBQUU7SUFDekMsQ0FBQztRQUNILFlBQVksQ0FBQztRQUViLElBQUksd0JBQXdCLEdBQUcsS0FBSyxDQUFDO1FBQ3JDLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQztRQUUzQixJQUFJLG1CQUFtQixDQUFDO1FBQ3hCLElBQUksa0JBQWtCLENBQUM7UUFDdkIsSUFBSSxpQkFBaUIsQ0FBQztRQUN0QixJQUFJLFlBQVksQ0FBQztRQUNqQixJQUFJLGlCQUFpQixHQUFHLE9BQU8sV0FBVyxLQUFLLFFBQVEsSUFBSSxPQUFPLFdBQVcsQ0FBQyxHQUFHLEtBQUssVUFBVSxDQUFDO1FBRWpHLElBQUksaUJBQWlCLEVBQUU7WUFDckIsSUFBSSxnQkFBZ0IsR0FBRyxXQUFXLENBQUM7WUFFbkMsT0FBTyxDQUFDLFlBQVksR0FBRztnQkFDckIsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNoQyxDQUFDLENBQUM7U0FDSDthQUFNO1lBQ0wsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLElBQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUVsQyxPQUFPLENBQUMsWUFBWSxHQUFHO2dCQUNyQixPQUFPLFNBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxXQUFXLENBQUM7WUFDdkMsQ0FBQyxDQUFDO1NBQ0g7UUFFRCxLQUFLLHVFQUF1RTtRQUM1RSxtQ0FBbUM7UUFDbkMsT0FBTyxNQUFNLEtBQUssV0FBVyxJQUFJLDZDQUE2QztZQUM5RSxPQUFPLGNBQWMsS0FBSyxVQUFVLEVBQUU7WUFDcEMsd0ZBQXdGO1lBQ3hGLHNDQUFzQztZQUN0QyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUM7WUFD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LENBQUMsNkJBQTZCLEdBQUcsNkJBQTZCLENBQUM7UUFDdEUsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDdEMsT0FBTyxDQUFDLHVCQUF1QixHQUFHLHVCQUF1QixDQUFDO1FBQzFELE9BQU8sQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQztRQUN0RCxPQUFPLENBQUMsd0JBQXdCLEdBQUcsd0JBQXdCLENBQUM7UUFDNUQsT0FBTyxDQUFDLHlCQUF5QixHQUFHLHlCQUF5QixDQUFDO1FBQzlELE9BQU8sQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsQ0FBQztJQUNwRCxDQUFDLENBQUMsRUFBRSxDQUFDO0NBQ04iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMVxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IHRydWU7XG5cbnZhciByZXF1ZXN0SG9zdENhbGxiYWNrO1xudmFyIHJlcXVlc3RIb3N0VGltZW91dDtcbnZhciBjYW5jZWxIb3N0VGltZW91dDtcbnZhciByZXF1ZXN0UGFpbnQ7XG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59XG5cbmlmICggLy8gSWYgU2NoZWR1bGVyIHJ1bnMgaW4gYSBub24tRE9NIGVudmlyb25tZW50LCBpdCBmYWxscyBiYWNrIHRvIGEgbmFpdmVcbi8vIGltcGxlbWVudGF0aW9uIHVzaW5nIHNldFRpbWVvdXQuXG50eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAvLyBDaGVjayBpZiBNZXNzYWdlQ2hhbm5lbCBpcyBzdXBwb3J0ZWQsIHRvby5cbnR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBJZiB0aGlzIGFjY2lkZW50YWxseSBnZXRzIGltcG9ydGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGUuZy4gSmF2YVNjcmlwdENvcmUsXG4gIC8vIGZhbGxiYWNrIHRvIGEgbmFpdmUgaW1wbGVtZW50YXRpb24uXG4gIHZhciBfY2FsbGJhY2sgPSBudWxsO1xuICB2YXIgX3RpbWVvdXRJRCA9IG51bGw7XG5cbiAgdmFyIF9mbHVzaENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIHZhciBoYXNSZW1haW5pbmdUaW1lID0gdHJ1ZTtcblxuICAgICAgICBfY2FsbGJhY2soaGFzUmVtYWluaW5nVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIF9jYWxsYmFjayA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDApO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHJlLWVudHJhbmN5LlxuICAgICAgc2V0VGltZW91dChyZXF1ZXN0SG9zdENhbGxiYWNrLCAwLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9jYWxsYmFjayA9IGNiO1xuICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCk7XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0VGltZW91dCA9IGZ1bmN0aW9uIChjYiwgbXMpIHtcbiAgICBfdGltZW91dElEID0gc2V0VGltZW91dChjYiwgbXMpO1xuICB9O1xuXG4gIGNhbmNlbEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dChfdGltZW91dElEKTtcbiAgfTtcblxuICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXF1ZXN0UGFpbnQgPSBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKCkge307XG59IGVsc2Uge1xuICAvLyBDYXB0dXJlIGxvY2FsIHJlZmVyZW5jZXMgdG8gbmF0aXZlIEFQSXMsIGluIGNhc2UgYSBwb2x5ZmlsbCBvdmVycmlkZXMgdGhlbS5cbiAgdmFyIF9zZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBfY2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dDtcblxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETzogU2NoZWR1bGVyIG5vIGxvbmdlciByZXF1aXJlcyB0aGVzZSBtZXRob2RzIHRvIGJlIHBvbHlmaWxsZWQuIEJ1dFxuICAgIC8vIG1heWJlIHdlIHdhbnQgdG8gY29udGludWUgd2FybmluZyBpZiB0aGV5IGRvbid0IGV4aXN0LCB0byBwcmVzZXJ2ZSB0aGVcbiAgICAvLyBvcHRpb24gdG8gcmVseSBvbiBpdCBpbiB0aGUgZnV0dXJlP1xuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIHZhciBjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWydlcnJvciddKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICB2YXIgdGFza1RpbWVvdXRJRCA9IC0xOyAvLyBTY2hlZHVsZXIgcGVyaW9kaWNhbGx5IHlpZWxkcyBpbiBjYXNlIHRoZXJlIGlzIG90aGVyIHdvcmsgb24gdGhlIG1haW5cbiAgLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuICAvLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuICAvLyBuZWVkIHRvIGJlIGZyYW1lIGFsaWduZWQ7IGZvciB0aG9zZSB0aGF0IGRvLCB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXG4gIHZhciB5aWVsZEludGVydmFsID0gNTtcbiAgdmFyIGRlYWRsaW5lID0gMDsgLy8gVE9ETzogTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuXG4gIHtcbiAgICAvLyBgaXNJbnB1dFBlbmRpbmdgIGlzIG5vdCBhdmFpbGFibGUuIFNpbmNlIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgaWZcbiAgICAvLyB0aGVyZSdzIHBlbmRpbmcgaW5wdXQsIGFsd2F5cyB5aWVsZCBhdCB0aGUgZW5kIG9mIHRoZSBmcmFtZS5cbiAgICBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudW5zdGFibGVfbm93KCkgPj0gZGVhZGxpbmU7XG4gICAgfTsgLy8gU2luY2Ugd2UgeWllbGQgZXZlcnkgZnJhbWUgcmVnYXJkbGVzcywgYHJlcXVlc3RQYWludGAgaGFzIG5vIGVmZmVjdC5cblxuXG4gICAgcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge307XG4gIH1cblxuICBleHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAgIGlmIChmcHMgPCAwIHx8IGZwcyA+IDEyNSkge1xuICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmcHMgPiAwKSB7XG4gICAgICB5aWVsZEludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgICAgeWllbGRJbnRlcnZhbCA9IDU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gWWllbGQgYWZ0ZXIgYHlpZWxkSW50ZXJ2YWxgIG1zLCByZWdhcmRsZXNzIG9mIHdoZXJlIHdlIGFyZSBpbiB0aGUgdnN5bmNcbiAgICAgIC8vIGN5Y2xlLiBUaGlzIG1lYW5zIHRoZXJlJ3MgYWx3YXlzIHRpbWUgcmVtYWluaW5nIGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGV2ZW50LlxuXG4gICAgICBkZWFkbGluZSA9IGN1cnJlbnRUaW1lICsgeWllbGRJbnRlcnZhbDtcbiAgICAgIHZhciBoYXNUaW1lUmVtYWluaW5nID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGhhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKGhhc1RpbWVSZW1haW5pbmcsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBpZiAoIWhhc01vcmVXb3JrKSB7XG4gICAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxuICB9O1xuXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBtcykge1xuICAgIHRhc2tUaW1lb3V0SUQgPSBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgICB9LCBtcyk7XG4gIH07XG5cbiAgY2FuY2VsSG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2NsZWFyVGltZW91dCh0YXNrVGltZW91dElEKTtcblxuICAgIHRhc2tUaW1lb3V0SUQgPSAtMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgdmFyIGZpcnN0ID0gaGVhcFswXTtcbiAgcmV0dXJuIGZpcnN0ID09PSB1bmRlZmluZWQgPyBudWxsIDogZmlyc3Q7XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuXG4gIGlmIChmaXJzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGxhc3QgPSBoZWFwLnBvcCgpO1xuXG4gICAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgICBoZWFwWzBdID0gbGFzdDtcbiAgICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJzdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGxlZnRJbmRleCA9IChpbmRleCArIDEpICogMiAtIDE7XG4gICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgIHZhciByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07IC8vIElmIHRoZSBsZWZ0IG9yIHJpZ2h0IG5vZGUgaXMgc21hbGxlciwgc3dhcCB3aXRoIHRoZSBzbWFsbGVyIG9mIHRob3NlLlxuXG4gICAgaWYgKGxlZnQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKGxlZnQsIG5vZGUpIDwgMCkge1xuICAgICAgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFwW2luZGV4XSA9IGxlZnQ7XG4gICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBjaGlsZCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG59XG5cbi8vIFRPRE86IFVzZSBzeW1ib2xzP1xudmFyIE5vUHJpb3JpdHkgPSAwO1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xudmFyIExvd1ByaW9yaXR5ID0gNDtcbnZhciBJZGxlUHJpb3JpdHkgPSA1O1xuXG52YXIgcnVuSWRDb3VudGVyID0gMDtcbnZhciBtYWluVGhyZWFkSWRDb3VudGVyID0gMDtcbnZhciBwcm9maWxpbmdTdGF0ZVNpemUgPSA0O1xudmFyIHNoYXJlZFByb2ZpbGluZ0J1ZmZlciA9ICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IFNoYXJlZEFycmF5QnVmZmVyXG50eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgU2hhcmVkQXJyYXlCdWZmZXIocHJvZmlsaW5nU3RhdGVTaXplICogSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkgOiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IEFycmF5QnVmZmVyXG50eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgQXJyYXlCdWZmZXIocHJvZmlsaW5nU3RhdGVTaXplICogSW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkgOiBudWxsIC8vIERvbid0IGNyYXNoIHRoZSBpbml0IHBhdGggb24gSUU5XG47XG52YXIgcHJvZmlsaW5nU3RhdGUgPSAgc2hhcmVkUHJvZmlsaW5nQnVmZmVyICE9PSBudWxsID8gbmV3IEludDMyQXJyYXkoc2hhcmVkUHJvZmlsaW5nQnVmZmVyKSA6IFtdOyAvLyBXZSBjYW4ndCByZWFkIHRoaXMgYnV0IGl0IGhlbHBzIHNhdmUgYnl0ZXMgZm9yIG51bGwgY2hlY2tzXG5cbnZhciBQUklPUklUWSA9IDA7XG52YXIgQ1VSUkVOVF9UQVNLX0lEID0gMTtcbnZhciBDVVJSRU5UX1JVTl9JRCA9IDI7XG52YXIgUVVFVUVfU0laRSA9IDM7XG5cbntcbiAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTsgLy8gVGhpcyBpcyBtYWludGFpbmVkIHdpdGggYSBjb3VudGVyLCBiZWNhdXNlIHRoZSBzaXplIG9mIHRoZSBwcmlvcml0eSBxdWV1ZVxuICAvLyBhcnJheSBtaWdodCBpbmNsdWRlIGNhbmNlbGVkIHRhc2tzLlxuXG4gIHByb2ZpbGluZ1N0YXRlW1FVRVVFX1NJWkVdID0gMDtcbiAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IDA7XG59IC8vIEJ5dGVzIHBlciBlbGVtZW50IGlzIDRcblxuXG52YXIgSU5JVElBTF9FVkVOVF9MT0dfU0laRSA9IDEzMTA3MjtcbnZhciBNQVhfRVZFTlRfTE9HX1NJWkUgPSA1MjQyODg7IC8vIEVxdWl2YWxlbnQgdG8gMiBtZWdhYnl0ZXNcblxudmFyIGV2ZW50TG9nU2l6ZSA9IDA7XG52YXIgZXZlbnRMb2dCdWZmZXIgPSBudWxsO1xudmFyIGV2ZW50TG9nID0gbnVsbDtcbnZhciBldmVudExvZ0luZGV4ID0gMDtcbnZhciBUYXNrU3RhcnRFdmVudCA9IDE7XG52YXIgVGFza0NvbXBsZXRlRXZlbnQgPSAyO1xudmFyIFRhc2tFcnJvckV2ZW50ID0gMztcbnZhciBUYXNrQ2FuY2VsRXZlbnQgPSA0O1xudmFyIFRhc2tSdW5FdmVudCA9IDU7XG52YXIgVGFza1lpZWxkRXZlbnQgPSA2O1xudmFyIFNjaGVkdWxlclN1c3BlbmRFdmVudCA9IDc7XG52YXIgU2NoZWR1bGVyUmVzdW1lRXZlbnQgPSA4O1xuXG5mdW5jdGlvbiBsb2dFdmVudChlbnRyaWVzKSB7XG4gIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgIHZhciBvZmZzZXQgPSBldmVudExvZ0luZGV4O1xuICAgIGV2ZW50TG9nSW5kZXggKz0gZW50cmllcy5sZW5ndGg7XG5cbiAgICBpZiAoZXZlbnRMb2dJbmRleCArIDEgPiBldmVudExvZ1NpemUpIHtcbiAgICAgIGV2ZW50TG9nU2l6ZSAqPSAyO1xuXG4gICAgICBpZiAoZXZlbnRMb2dTaXplID4gTUFYX0VWRU5UX0xPR19TSVpFKSB7XG4gICAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgICBjb25zb2xlWydlcnJvciddKFwiU2NoZWR1bGVyIFByb2ZpbGluZzogRXZlbnQgbG9nIGV4Y2VlZGVkIG1heGltdW0gc2l6ZS4gRG9uJ3QgXCIgKyAnZm9yZ2V0IHRvIGNhbGwgYHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzKClgLicpO1xuICAgICAgICBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdFdmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nU2l6ZSAqIDQpO1xuICAgICAgbmV3RXZlbnRMb2cuc2V0KGV2ZW50TG9nKTtcbiAgICAgIGV2ZW50TG9nQnVmZmVyID0gbmV3RXZlbnRMb2cuYnVmZmVyO1xuICAgICAgZXZlbnRMb2cgPSBuZXdFdmVudExvZztcbiAgICB9XG5cbiAgICBldmVudExvZy5zZXQoZW50cmllcywgb2Zmc2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHMoKSB7XG4gIGV2ZW50TG9nU2l6ZSA9IElOSVRJQUxfRVZFTlRfTE9HX1NJWkU7XG4gIGV2ZW50TG9nQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGV2ZW50TG9nU2l6ZSAqIDQpO1xuICBldmVudExvZyA9IG5ldyBJbnQzMkFycmF5KGV2ZW50TG9nQnVmZmVyKTtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG59XG5mdW5jdGlvbiBzdG9wTG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cygpIHtcbiAgdmFyIGJ1ZmZlciA9IGV2ZW50TG9nQnVmZmVyO1xuICBldmVudExvZ1NpemUgPSAwO1xuICBldmVudExvZ0J1ZmZlciA9IG51bGw7XG4gIGV2ZW50TG9nID0gbnVsbDtcbiAgZXZlbnRMb2dJbmRleCA9IDA7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBtYXJrVGFza1N0YXJ0KHRhc2ssIG1zKSB7XG4gIHtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXSsrO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICAvLyBwZXJmb3JtYW5jZS5ub3cgcmV0dXJucyBhIGZsb2F0LCByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzLiBXaGVuIHRoZVxuICAgICAgLy8gZXZlbnQgaXMgbG9nZ2VkLCBpdCdzIGNvZXJjZWQgdG8gYW4gaW50LiBDb252ZXJ0IHRvIG1pY3Jvc2Vjb25kcyB0b1xuICAgICAgLy8gbWFpbnRhaW4gZXh0cmEgZGVncmVlcyBvZiBwcmVjaXNpb24uXG4gICAgICBsb2dFdmVudChbVGFza1N0YXJ0RXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgdGFzay5wcmlvcml0eUxldmVsXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0NvbXBsZXRlZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtRVUVVRV9TSVpFXS0tO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza0NvbXBsZXRlRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZF0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tDYW5jZWxlZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tDYW5jZWxFdmVudCwgbXMgKiAxMDAwLCB0YXNrLmlkXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrVGFza0Vycm9yZWQodGFzaywgbXMpIHtcbiAge1xuICAgIHByb2ZpbGluZ1N0YXRlW1BSSU9SSVRZXSA9IE5vUHJpb3JpdHk7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IDA7XG4gICAgcHJvZmlsaW5nU3RhdGVbUVVFVUVfU0laRV0tLTtcblxuICAgIGlmIChldmVudExvZyAhPT0gbnVsbCkge1xuICAgICAgbG9nRXZlbnQoW1Rhc2tFcnJvckV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWRdKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtUYXNrUnVuKHRhc2ssIG1zKSB7XG4gIHtcbiAgICBydW5JZENvdW50ZXIrKztcbiAgICBwcm9maWxpbmdTdGF0ZVtQUklPUklUWV0gPSB0YXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9UQVNLX0lEXSA9IHRhc2suaWQ7XG4gICAgcHJvZmlsaW5nU3RhdGVbQ1VSUkVOVF9SVU5fSURdID0gcnVuSWRDb3VudGVyO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1J1bkV2ZW50LCBtcyAqIDEwMDAsIHRhc2suaWQsIHJ1bklkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Rhc2tZaWVsZCh0YXNrLCBtcykge1xuICB7XG4gICAgcHJvZmlsaW5nU3RhdGVbUFJJT1JJVFldID0gTm9Qcmlvcml0eTtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1RBU0tfSURdID0gMDtcbiAgICBwcm9maWxpbmdTdGF0ZVtDVVJSRU5UX1JVTl9JRF0gPSAwO1xuXG4gICAgaWYgKGV2ZW50TG9nICE9PSBudWxsKSB7XG4gICAgICBsb2dFdmVudChbVGFza1lpZWxkRXZlbnQsIG1zICogMTAwMCwgdGFzay5pZCwgcnVuSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU2NoZWR1bGVyU3VzcGVuZGVkKG1zKSB7XG4gIHtcbiAgICBtYWluVGhyZWFkSWRDb3VudGVyKys7XG5cbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJTdXNwZW5kRXZlbnQsIG1zICogMTAwMCwgbWFpblRocmVhZElkQ291bnRlcl0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKG1zKSB7XG4gIHtcbiAgICBpZiAoZXZlbnRMb2cgIT09IG51bGwpIHtcbiAgICAgIGxvZ0V2ZW50KFtTY2hlZHVsZXJSZXN1bWVFdmVudCwgbXMgKiAxMDAwLCBtYWluVGhyZWFkSWRDb3VudGVyXSk7XG4gICAgfVxuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwOyAvLyBOZXZlciB0aW1lcyBvdXRcblxudmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmN5LlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuXG4gICAgICB7XG4gICAgICAgIG1hcmtUYXNrU3RhcnQodGltZXIsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGltZXIuaXNRdWV1ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB7XG4gICAgbWFya1NjaGVkdWxlclVuc3VzcGVuZGVkKGluaXRpYWxUaW1lKTtcbiAgfSAvLyBXZSdsbCBuZWVkIGEgaG9zdCBjYWxsYmFjayB0aGUgbmV4dCB0aW1lIHdvcmsgaXMgc2NoZWR1bGVkLlxuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgdmFyIF9jdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIG1hcmtTY2hlZHVsZXJTdXNwZW5kZWQoX2N1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcblxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIShlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgKSkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmICghaGFzVGltZVJlbWFpbmluZyB8fCBleHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkKCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG4gICAgICBtYXJrVGFza1J1bihjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgbWFya1Rhc2tZaWVsZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtUYXNrQ29tcGxldGVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRhc2suaXNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICB7XG4gICAgbmV3VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuXG4gICAge1xuICAgICAgbWFya1Rhc2tTdGFydChuZXdUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICBuZXdUYXNrLmlzUXVldWVkID0gdHJ1ZTtcbiAgICB9IC8vIFNjaGVkdWxlIGEgaG9zdCBjYWxsYmFjaywgaWYgbmVlZGVkLiBJZiB3ZSdyZSBhbHJlYWR5IHBlcmZvcm1pbmcgd29yayxcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIHtcbiAgICBpZiAodGFzay5pc1F1ZXVlZCkge1xuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIG1hcmtUYXNrQ2FuY2VsZWQodGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgdGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSAvLyBOdWxsIG91dCB0aGUgY2FsbGJhY2sgdG8gaW5kaWNhdGUgdGhlIHRhc2sgaGFzIGJlZW4gY2FuY2VsZWQuIChDYW4ndFxuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbnZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSAge1xuICBzdGFydExvZ2dpbmdQcm9maWxpbmdFdmVudHM6IHN0YXJ0TG9nZ2luZ1Byb2ZpbGluZ0V2ZW50cyxcbiAgc3RvcExvZ2dpbmdQcm9maWxpbmdFdmVudHM6IHN0b3BMb2dnaW5nUHJvZmlsaW5nRXZlbnRzLFxuICBzaGFyZWRQcm9maWxpbmdCdWZmZXI6IHNoYXJlZFByb2ZpbGluZ0J1ZmZlclxufSA7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (false) {}\r\nelse {\r\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzQwMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUM7S0FBTTtJQUNMLE1BQU0sQ0FBQyxPQUFPLEdBQUcsbUJBQU8sQ0FBQyw2RkFBZ0MsQ0FBQyxDQUFDO0NBQzVEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/index.js\n");

/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nif (false) {}\r\nelse {\r\n    module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ \"./node_modules/scheduler/cjs/scheduler-tracing.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL3RyYWNpbmcuanM/NmYwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztLQUFNO0lBQ0wsTUFBTSxDQUFDLE9BQU8sR0FBRyxtQkFBTyxDQUFDLDZHQUF3QyxDQUFDLENBQUM7Q0FDcEUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL3RyYWNpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scheduler/tracing.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsU0FBSTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUVBQXFFLHFCQUFxQixhQUFhOztBQUV2Rzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar App_modules_scss_1 = __importDefault(__webpack_require__(/*! ./App.modules.scss */ \"./src/App.modules.scss\"));\r\n__webpack_require__(/*! ./custom.css */ \"./src/custom.css\");\r\nvar classnames_1 = __importDefault(__webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\"));\r\nvar App = function () {\r\n    return (react_1.default.createElement(\"div\", { className: classnames_1.default(App_modules_scss_1.default.header, 'color') }, \"This is App Component!\"));\r\n};\r\nexports.default = App;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLmpzP2JlOTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpR0FBMEI7QUFDMUIsa0hBQW1DO0FBQ25DLDREQUFzQjtBQUN0QixnSEFBMkI7QUFFM0IsSUFBTSxHQUFHLEdBQUc7SUFDUixPQUFPLENBQ0gsdUNBQUssU0FBUyxFQUFFLG9CQUFFLENBQUMsMEJBQUMsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLDZCQUUvQixDQUNUO0FBQ0wsQ0FBQztBQUNELGtCQUFlLEdBQUcsQ0FBQyIsImZpbGUiOiIuL3NyYy9BcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgcyBmcm9tICcuL0FwcC5tb2R1bGVzLnNjc3MnO1xyXG5pbXBvcnQgJy4vY3VzdG9tLmNzcyc7XHJcbmltcG9ydCBjbiBmcm9tICdjbGFzc25hbWVzJ1xyXG5cclxuY29uc3QgQXBwID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y24ocy5oZWFkZXIsICdjb2xvcicpfT5cclxuICAgICAgICAgICAgVGhpcyBpcyBBcHAgQ29tcG9uZW50IVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IEFwcDtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/App.js\n");

/***/ }),

/***/ "./src/App.modules.scss":
/*!******************************!*\
  !*** ./src/App.modules.scss ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_App_modules_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/sass-loader/dist/cjs.js!./App.modules.scss */ \"./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/App.modules.scss\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_App_modules_scss__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_App_modules_scss__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLm1vZHVsZXMuc2Nzcz9mNmM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlGO0FBQ3pGLFlBQWdKOztBQUVoSjs7QUFFQTtBQUNBOztBQUVBLGFBQWEsMEdBQUcsQ0FBQywwSUFBTzs7OztBQUlULHlNQUFPLGFBQWEiLCJmaWxlIjoiLi9zcmMvQXBwLm1vZHVsZXMuc2Nzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9BcHAubW9kdWxlcy5zY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/App.modules.scss\n");

/***/ }),

/***/ "./src/custom.css":
/*!************************!*\
  !*** ./src/custom.css ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_custom_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/sass-loader/dist/cjs.js!./custom.css */ \"./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/custom.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_custom_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_custom_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3VzdG9tLmNzcz84ZDAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlGO0FBQ3pGLFlBQTBJOztBQUUxSTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsMEdBQUcsQ0FBQyxvSUFBTzs7OztBQUlULG1NQUFPLGFBQWEiLCJmaWxlIjoiLi9zcmMvY3VzdG9tLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9jdXN0b20uY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/custom.css\n");

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/sass-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js?!./node_modules/sass-loader/dist/cjs.js!./src/index.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_css_loader_dist_cjs_js_ref_5_1_node_modules_sass_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguY3NzPzQ3NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUY7QUFDekYsWUFBeUk7O0FBRXpJOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSwwR0FBRyxDQUFDLG1JQUFPOzs7O0FBSVQsa01BQU8sYUFBYSIsImZpbGUiOiIuL3NyYy9pbmRleC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.css\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\r\nvar react_dom_1 = __importDefault(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\r\nvar App_1 = __importDefault(__webpack_require__(/*! ./App */ \"./src/App.js\"));\r\n__webpack_require__(/*! ./index.css */ \"./src/index.css\");\r\nreact_dom_1.default.render(react_1.default.createElement(App_1.default, null), document.getElementById('root'));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlHQUF5QjtBQUN6Qiw2R0FBZ0M7QUFDaEMsOEVBQXdCO0FBQ3hCLDBEQUFvQjtBQUVwQixtQkFBUSxDQUFDLE1BQU0sQ0FBQyw4QkFBQyxhQUFHLE9BQUUsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMiLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nXHJcbmltcG9ydCBBcHAgZnJvbSBcIi4vQXBwXCI7XHJcbmltcG9ydCAnLi9pbmRleC5jc3MnXHJcblxyXG5SZWFjdERPTS5yZW5kZXIoPEFwcC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });